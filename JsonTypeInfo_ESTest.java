package com.fasterxml.jackson.annotation;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;

import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * This test suite verifies the functionality of the {@link JsonTypeInfo.Id} enum and the {@link JsonTypeInfo.Value} class.
 *
 * The original test was auto-generated by EvoSuite and was difficult to understand.
 * This version has been refactored for clarity and maintainability by:
 * 1. Using descriptive test method names.
 * 2. Structuring tests with the Arrange-Act-Assert pattern.
 * 3. Using clear and simple test data.
 * 4. Adding explanatory messages to assertions.
 * 5. Replacing a confusing mock-based test with a clear, positive alternative.
 */
@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class JsonTypeInfo_ESTest extends JsonTypeInfo_ESTest_scaffolding {

    // ========================================================================
    // Tests for JsonTypeInfo.Id
    // ========================================================================

    @Test
    public void id_getDefaultPropertyName_shouldReturnNull_forCustomId() {
        // Arrange
        JsonTypeInfo.Id id = JsonTypeInfo.Id.CUSTOM;

        // Act
        String defaultPropertyName = id.getDefaultPropertyName();

        // Assert
        assertNull("The 'CUSTOM' Id type should not have a default property name.", defaultPropertyName);
    }

    @Test
    public void id_getDefaultPropertyName_shouldReturnCorrectName_forNameId() {
        // Arrange
        JsonTypeInfo.Id id = JsonTypeInfo.Id.NAME;

        // Act
        String defaultPropertyName = id.getDefaultPropertyName();

        // Assert
        assertEquals("The 'NAME' Id type should have a default property name of '@type'.", "@type", defaultPropertyName);
    }

    // ========================================================================
    // Tests for JsonTypeInfo.Value
    // ========================================================================

    @Test
    public void value_getters_shouldReturnDefaults_forEmptyValue() {
        // Arrange
        JsonTypeInfo.Value emptyValue = JsonTypeInfo.Value.EMPTY;

        // Assert
        assertEquals(JsonTypeInfo.Id.NONE, emptyValue.getIdType());
        assertEquals(JsonTypeInfo.As.PROPERTY, emptyValue.getInclusionType());
        assertNull(emptyValue.getPropertyName());
        assertNull(emptyValue.getDefaultImpl());
        assertFalse(emptyValue.getIdVisible());
        assertNull(emptyValue.getRequireTypeIdForSubtypes());
    }

    @Test
    public void value_construct_shouldCreateInstanceWithGivenProperties() {
        // Arrange
        JsonTypeInfo.Id idType = JsonTypeInfo.Id.CLASS;
        JsonTypeInfo.As inclusion = JsonTypeInfo.As.WRAPPER_OBJECT;
        String propertyName = "typeInfo";
        Class<?> defaultImpl = String.class;

        // Act
        JsonTypeInfo.Value value = JsonTypeInfo.Value.construct(idType, inclusion, propertyName, defaultImpl, true, Boolean.TRUE);

        // Assert
        assertEquals(idType, value.getIdType());
        assertEquals(inclusion, value.getInclusionType());
        assertEquals(propertyName, value.getPropertyName());
        assertEquals(defaultImpl, value.getDefaultImpl());
        assertTrue(value.getIdVisible());
        assertEquals(Boolean.TRUE, value.getRequireTypeIdForSubtypes());
    }

    @Test
    public void value_construct_shouldUseDefaultPropertyName_whenPropertyNameIsNull() {
        // Arrange
        JsonTypeInfo.Id idTypeWithDefault = JsonTypeInfo.Id.NAME; // Has default property "@type"

        // Act
        JsonTypeInfo.Value value = JsonTypeInfo.Value.construct(idTypeWithDefault, JsonTypeInfo.As.PROPERTY, null, null, false, null);

        // Assert
        assertEquals("Should use the default property name from the Id type.", "@type", value.getPropertyName());
    }

    @Test
    public void value_from_shouldReturnNull_whenSourceIsNull() {
        // Act & Assert
        assertNull(JsonTypeInfo.Value.from(null));
    }

    @Test
    public void value_from_shouldCreateValueFromAnnotation() {
        // Arrange
        JsonTypeInfo mockAnnotation = mock(JsonTypeInfo.class);
        when(mockAnnotation.use()).thenReturn(JsonTypeInfo.Id.CLASS);
        when(mockAnnotation.include()).thenReturn(JsonTypeInfo.As.WRAPPER_OBJECT);
        when(mockAnnotation.property()).thenReturn("className");
        when(mockAnnotation.defaultImpl()).thenReturn(Object.class);
        when(mockAnnotation.visible()).thenReturn(true);
        when(mockAnnotation.requireTypeIdForSubtypes()).thenReturn(OptBoolean.TRUE);

        // Act
        JsonTypeInfo.Value value = JsonTypeInfo.Value.from(mockAnnotation);

        // Assert
        assertNotNull(value);
        assertEquals(JsonTypeInfo.Id.CLASS, value.getIdType());
        assertEquals(JsonTypeInfo.As.WRAPPER_OBJECT, value.getInclusionType());
        assertEquals("className", value.getPropertyName());
        assertEquals(Object.class, value.getDefaultImpl());
        assertTrue(value.getIdVisible());
        assertEquals(Boolean.TRUE, value.getRequireTypeIdForSubtypes());
    }

    @Test
    public void value_withIdType_shouldReturnNewInstance_forDifferentType() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY;

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withIdType(JsonTypeInfo.Id.CLASS);

        // Assert
        assertNotSame("A new Value instance should be created for a different Id type.", originalValue, updatedValue);
        assertEquals(JsonTypeInfo.Id.CLASS, updatedValue.getIdType());
    }

    @Test
    public void value_withIdType_shouldReturnSameInstance_forSameType() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY.withIdType(JsonTypeInfo.Id.CLASS);

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withIdType(JsonTypeInfo.Id.CLASS);

        // Assert
        assertSame("The same instance should be returned if the Id type is unchanged.", originalValue, updatedValue);
    }

    @Test
    public void value_withInclusionType_shouldReturnNewInstance_forDifferentInclusion() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY; // Default is PROPERTY

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withInclusionType(JsonTypeInfo.As.WRAPPER_OBJECT);

        // Assert
        assertNotSame("A new Value instance should be created for a different inclusion type.", originalValue, updatedValue);
        assertEquals(JsonTypeInfo.As.WRAPPER_OBJECT, updatedValue.getInclusionType());
    }

    @Test
    public void value_withInclusionType_shouldReturnSameInstance_forSameInclusion() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY.withInclusionType(JsonTypeInfo.As.WRAPPER_OBJECT);

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withInclusionType(JsonTypeInfo.As.WRAPPER_OBJECT);

        // Assert
        assertSame("The same instance should be returned if the inclusion type is unchanged.", originalValue, updatedValue);
    }

    @Test
    public void value_withDefaultImpl_shouldReturnNewInstance_forDifferentImpl() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY;

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withDefaultImpl(String.class);

        // Assert
        assertNotSame("A new Value instance should be created for a different default implementation.", originalValue, updatedValue);
        assertEquals(String.class, updatedValue.getDefaultImpl());
    }

    @Test
    public void value_withDefaultImpl_shouldReturnSameInstance_forSameImpl() {
        // Arrange
        JsonTypeInfo.Value originalValue = JsonTypeInfo.Value.EMPTY.withDefaultImpl(String.class);

        // Act
        JsonTypeInfo.Value updatedValue = originalValue.withDefaultImpl(String.class);

        // Assert
        assertSame("The same instance should be returned if the default implementation is unchanged.", originalValue, updatedValue);
    }

    @Test
    public void value_equals_shouldReturnFalse_forNull() {
        // Arrange
        JsonTypeInfo.Value value = JsonTypeInfo.Value.EMPTY;

        // Act & Assert
        assertFalse(value.equals(null));
    }

    @Test
    public void value_equals_shouldReturnFalse_forDifferentObjectType() {
        // Arrange
        JsonTypeInfo.Value value = JsonTypeInfo.Value.EMPTY;

        // Act & Assert
        assertFalse(value.equals("a string"));
    }

    @Test
    public void value_equals_shouldReturnTrue_forSameInstance() {
        // Arrange
        JsonTypeInfo.Value value = JsonTypeInfo.Value.EMPTY;

        // Act & Assert
        assertTrue("An instance should be equal to itself.", value.equals(value));
    }

    @Test
    public void value_equals_shouldReturnFalse_whenPropertiesDiffer() {
        // Arrange
        JsonTypeInfo.Value value1 = JsonTypeInfo.Value.EMPTY;
        JsonTypeInfo.Value value2 = JsonTypeInfo.Value.EMPTY.withIdVisible(true);

        // Act & Assert
        assertFalse("Values with different properties should not be equal.", value1.equals(value2));
    }

    @Test
    public void value_toString_shouldProvideFullRepresentation() {
        // Arrange
        JsonTypeInfo.Value value = JsonTypeInfo.Value.construct(JsonTypeInfo.Id.CLASS, JsonTypeInfo.As.PROPERTY, "@class", Object.class, false, Boolean.FALSE);

        // Act
        String stringRepresentation = value.toString();

        // Assert
        assertEquals("JsonTypeInfo.Value(idType=CLASS,includeAs=PROPERTY,propertyName=@class,defaultImpl=java.lang.Object,idVisible=false,requireTypeIdForSubtypes=false)", stringRepresentation);
    }

    @Test
    public void value_isEnabled_shouldReturnFalse_forNullValue() {
        // Act & Assert
        assertFalse(JsonTypeInfo.Value.isEnabled(null));
    }

    @Test
    public void value_isEnabled_shouldReturnFalse_whenIdTypeIsNone() {
        // Arrange
        JsonTypeInfo.Value valueWithIdNone = JsonTypeInfo.Value.EMPTY; // idType is NONE

        // Act & Assert
        assertFalse("isEnabled should be false when IdType is NONE.", JsonTypeInfo.Value.isEnabled(valueWithIdNone));
    }

    @Test
    public void value_isEnabled_shouldReturnTrue_whenIdTypeIsNotNone() {
        // Arrange
        JsonTypeInfo.Value valueWithIdClass = JsonTypeInfo.Value.EMPTY.withIdType(JsonTypeInfo.Id.CLASS);

        // Act & Assert
        assertTrue("isEnabled should be true when IdType is not NONE.", JsonTypeInfo.Value.isEnabled(valueWithIdClass));
    }
}