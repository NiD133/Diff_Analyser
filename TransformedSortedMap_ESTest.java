/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved readability and maintainability
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NoSuchElementException;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.commons.collections4.Closure;
import org.apache.commons.collections4.Factory;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantFactory;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.ExceptionTransformer;
import org.apache.commons.collections4.functors.FactoryTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.collections4.functors.MapTransformer;
import org.apache.commons.collections4.map.TransformedSortedMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TransformedSortedMap_ESTest extends TransformedSortedMap_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testSubMapWithEmptyRange() throws Throwable {
      // Test that subMap with identical fromKey/toKey returns an empty map
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      LinkedList<Transformer<Integer, Integer>> transformers = new LinkedList<>();
      Transformer<Integer, Integer> valueTransformer = ChainedTransformer.chainedTransformer(transformers);
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(baseMap, null, valueTransformer);
      
      Integer key = -3410;
      SortedMap<Integer, Integer> emptySubMap = transformedMap.subMap(key, key);
      
      assertTrue(emptySubMap.isEmpty());
  }

  @Test(timeout = 4000)
  public void testHeadMapWithEmptyMap() throws Throwable {
      // Test headMap operation on an empty transformed map
      Integer constantValue = 3005;
      Factory<Integer> constantFactory = ConstantFactory.constantFactory(constantValue);
      Transformer<Object, Integer> valueTransformer = new FactoryTransformer<>(constantFactory);
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      
      Class<Integer>[] paramTypes = (Class<Integer>[]) Array.newInstance(Class.class, 7);
      Transformer<Integer, Integer> keyTransformer = 
          new InvokerTransformer<>("\"3Kz{N`TV^sYZ s\"p5Q", paramTypes, paramTypes);
      
      TransformedSortedMap<Integer, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      SortedMap<Integer, Integer> headMap = transformedMap.headMap(constantValue);
      assertTrue(headMap.isEmpty());
  }

  @Test(timeout = 4000)
  public void testTailMapWithEmptyMap() throws Throwable {
      // Test tailMap operation on an empty transformed map
      Integer constantKey = -2921;
      Transformer<Integer, Integer> keyTransformer = new ConstantTransformer<>(constantKey);
      
      Class<Object>[] paramTypes = (Class<Object>[]) Array.newInstance(Class.class, 2);
      Transformer<Object, Integer> valueTransformer = new InvokerTransformer<>(null, paramTypes, null);
      
      TreeMap<Integer, Object> baseMap = new TreeMap<>();
      TransformedSortedMap<Integer, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      SortedMap<Integer, Object> tailMap = transformedMap.tailMap(constantKey);
      assertTrue(tailMap.isEmpty());
  }

  @Test(timeout = 4000)
  public void testTailMapWithSingleEntry() throws Throwable {
      // Test tailMap includes existing entries when key matches
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer key = 850;
      Transformer<Object, Integer> valueTransformer = ConstantTransformer.constantTransformer(key);
      
      TransformedSortedMap<Integer, Integer> transformedMap = 
          TransformedSortedMap.transformingSortedMap(baseMap, null, valueTransformer);
      
      baseMap.put(key, key);
      SortedMap<Integer, Integer> tailMap = transformedMap.tailMap(key);
      assertFalse(tailMap.isEmpty());
  }

  @Test(timeout = 4000)
  public void testSubMapWithSingleEntry() throws Throwable {
      // Test subMap includes entry when within key range
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer lowerBound = -1;
      Integer upperBound = 3152;
      baseMap.put(lowerBound, upperBound);
      
      Transformer<Integer, Integer> transformer = new ConstantTransformer<>(lowerBound);
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(baseMap, transformer, transformer);
      
      SortedMap<Integer, Integer> subMap = transformedMap.subMap(lowerBound, upperBound);
      assertFalse(subMap.isEmpty());
  }

  @Test(timeout = 4000)
  public void testLastKeyWithMockComparatorReturnsNull() throws Throwable {
      // Test lastKey behavior with a custom comparator that returns null
      Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(1, 1).when(mockComparator).compare(any(), any());
      
      TreeMap<Object, Integer> baseMap = new TreeMap<>(mockComparator);
      Integer value = 61;
      baseMap.put(value, value);
      
      Transformer<Object, Object> keyTransformer = MapTransformer.mapTransformer(new TreeMap<>());
      Transformer<Integer, Integer> valueTransformer = new ConstantTransformer<>(value);
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      assertNull(transformedMap.lastKey());
  }

  @Test(timeout = 4000)
  public void testLastKeyWithInvokerTransformer() throws Throwable {
      // Test lastKey transformation with InvokerTransformer
      Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(mockComparator).compare(any(), any());
      
      TreeMap<Object, Integer> baseMap = new TreeMap<>(mockComparator);
      Class<Object>[] paramTypes = (Class<Object>[]) Array.newInstance(Class.class, 3);
      Object key = Object.class;
      Integer value = 5;
      baseMap.put(key, value);
      
      Transformer<Object, Integer> transformer = new InvokerTransformer<>("Lu", paramTypes, paramTypes);
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformingSortedMap(baseMap, transformer, transformer);
      
      Object lastKey = transformedMap.lastKey();
      assertEquals("class java.lang.Object", lastKey.toString());
  }

  @Test(timeout = 4000)
  public void testHeadMapWithNegativeKey() throws Throwable {
      // Test headMap includes entry with negative key
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      LinkedList<Transformer<Integer, Integer>> transformers = new LinkedList<>();
      Transformer<Integer, Integer> transformer = ChainedTransformer.chainedTransformer(transformers);
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(baseMap, transformer, transformer);
      
      Integer negativeKey = -17;
      baseMap.put(negativeKey, negativeKey);
      
      SortedMap<Integer, Integer> headMap = transformedMap.headMap(0);
      assertEquals(1, headMap.size());
  }

  @Test(timeout = 4000)
  public void testGetSortedMapAfterTransformation() throws Throwable {
      // Test getSortedMap returns decorated map after transformation
      TreeMap<Closure<Object>, Object> baseMap = new TreeMap<>();
      Class<?>[] paramTypes = (Class<?>[]) Array.newInstance(Class.class, 7);
      Transformer<Object, Closure<Object>> transformer = 
          new InvokerTransformer<>("org.apache.commons.collections4.functors.ComparatorPredicate", paramTypes, paramTypes);
      
      TransformedSortedMap<Closure<Object>, Object> transformedMap = 
          new TransformedSortedMap<>(baseMap, transformer, transformer);
      TransformedSortedMap<Closure<Object>, Object> transformedAgain = 
          TransformedSortedMap.transformingSortedMap(transformedMap, transformer, transformer);
      
      SortedMap<Closure<Object>, Object> innerMap = transformedAgain.getSortedMap();
      assertEquals(0, innerMap.size());
  }

  @Test(timeout = 4000)
  public void testGetSortedMapAfterPut() throws Throwable {
      // Test getSortedMap reflects entries after put operation
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer key = 784;
      Transformer<Integer, Integer> transformer = ConstantTransformer.constantTransformer(key);
      
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(baseMap, transformer, transformer);
      transformedMap.put(key, key);
      
      TransformedSortedMap<Integer, Integer> transformedAgain = 
          TransformedSortedMap.transformedSortedMap(transformedMap, transformer, transformer);
      
      SortedMap<Integer, Integer> innerMap = transformedAgain.getSortedMap();
      assertEquals(1, innerMap.size());
  }

  @Test(timeout = 4000)
  public void testComparatorWithNaturalOrdering() throws Throwable {
      // Test comparator is null for natural ordering
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      Transformer<Object, Object> transformer = MapTransformer.mapTransformer(new TreeMap<>());
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, transformer, transformer);
      
      assertNull(transformedMap.comparator());
  }

  @Test(timeout = 4000)
  public void testTransformingWithNullMapThrowsException() {
      // Test transformingSortedMap throws NPE when map is null
      Transformer<Object, Integer> transformer = ConstantTransformer.nullTransformer();
      
      try {
          TransformedSortedMap.transformingSortedMap(null, transformer, transformer);
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          assertEquals("map", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testTransformedMapWithExceptionTransformer() {
      // Test transformedMap throws exception when transformer throws
      Transformer<Object, Integer> exceptionTransformer = ExceptionTransformer.exceptionTransformer();
      TreeMap<Object, Integer> baseMap = new TreeMap<>();
      baseMap.put(-1, -1);
      
      try {
          TransformedSortedMap.transformedSortedMap(baseMap, exceptionTransformer, exceptionTransformer);
          fail("Expected RuntimeException");
      } catch (RuntimeException e) {
          assertEquals("ExceptionTransformer invoked", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testTransformedMapCausesStackOverflow() {
      // Test infinite recursion leads to StackOverflowError
      TreeMap<Object, Predicate<Integer>> baseMap = new TreeMap<>();
      TransformedSortedMap<Object, Predicate<Integer>> transformedMap = 
          TransformedSortedMap.transformingSortedMap(baseMap, null, null);
      transformedMap.map = transformedMap; // Force recursion
      
      try {
          TransformedSortedMap.transformedSortedMap(transformedMap, null, null);
          fail("Expected StackOverflowError");
      } catch (StackOverflowError expected) {
      }
  }

  @Test(timeout = 4000)
  public void testTransformedMapWithNullMapThrowsException() {
      // Test transformedSortedMap throws NPE when map is null
      Transformer<Integer, Integer> transformer = MapTransformer.mapTransformer(null);
      
      try {
          TransformedSortedMap.transformedSortedMap(null, transformer, transformer);
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          assertEquals("map", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testPutWithInvalidKeyTypeThrowsException() {
      // Test put with incompatible key type throws ClassCastException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      Integer key = 1;
      baseMap.put(key, key);
      
      ConstantTransformer<Object, Object> transformer = new ConstantTransformer<>(baseMap);
      
      try {
          TransformedSortedMap.transformedSortedMap(baseMap, transformer, transformer);
          fail("Expected ClassCastException");
      } catch (ClassCastException e) {
          assertTrue(e.getMessage().contains("java.util.TreeMap cannot be cast to java.lang.Comparable"));
      }
  }

  @Test(timeout = 4000)
  public void testTailMapWithInvalidRangeThrowsException() {
      // Test tailMap with out-of-range key throws IllegalArgumentException
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer key = 512;
      SortedMap<Integer, Integer> emptySubMap = baseMap.subMap(key, key);
      
      Transformer<Integer, Integer> transformer = MapTransformer.mapTransformer(emptySubMap);
      TransformedSortedMap<Integer, Integer> transformedMap = 
          TransformedSortedMap.transformingSortedMap(emptySubMap, transformer, transformer);
      
      try {
          transformedMap.tailMap(key);
          fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException e) {
          assertTrue(e.getMessage().contains("fromKey out of range"));
      }
  }

  @Test(timeout = 4000)
  public void testTailMapWithIncompatibleKeyThrowsException() {
      // Test tailMap with incompatible key type throws ClassCastException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      Transformer<Object, Object> transformer = MapTransformer.mapTransformer(new TreeMap<>());
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, transformer, transformer);
      
      try {
          transformedMap.tailMap(baseMap); // Pass TreeMap as key (incomparable)
          fail("Expected ClassCastException");
      } catch (ClassCastException e) {
          assertTrue(e.getMessage().contains("java.util.TreeMap cannot be cast to java.lang.Comparable"));
      }
  }

  @Test(timeout = 4000)
  public void testSubMapWithInvalidRangeThrowsException() {
      // Test subMap with out-of-range keys throws IllegalArgumentException
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer key = 835;
      SortedMap<Integer, Integer> emptySubMap = baseMap.subMap(key, key);
      
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(emptySubMap, null, null);
      
      try {
          transformedMap.subMap(key, key);
          fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException e) {
          assertTrue(e.getMessage().contains("fromKey out of range"));
      }
  }

  @Test(timeout = 4000)
  public void testSubMapWithIncompatibleKeysThrowsException() {
      // Test subMap with incompatible key types throws ClassCastException
      TreeMap<Object, Integer> baseMap = new TreeMap<>();
      Transformer<Object, Object> keyTransformer = MapTransformer.mapTransformer(new TreeMap<>());
      Transformer<Object, Integer> valueTransformer = InvokerTransformer.invokerTransformer("i]oNU\\u7I%x");
      
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);
      
      Integer lowerBound = 1;
      String upperBound = "invalid_key";
      
      try {
          transformedMap.subMap(lowerBound, upperBound);
          fail("Expected ClassCastException");
      } catch (ClassCastException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testHeadMapWithNullKeyThrowsException() {
      // Test headMap with null key throws NullPointerException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, null, null);
      
      try {
          transformedMap.headMap(null);
          fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testHeadMapWithInvalidRangeThrowsException() {
      // Test headMap with out-of-range key throws IllegalArgumentException
      TreeMap<Integer, Integer> baseMap = new TreeMap<>();
      Integer negativeKey = -1116;
      NavigableMap<Integer, Integer> headMap = baseMap.headMap(negativeKey, true);
      
      TransformedSortedMap<Integer, Integer> transformedMap = 
          new TransformedSortedMap<>(headMap, null, null);
      
      try {
          transformedMap.headMap(0);
          fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException e) {
          assertTrue(e.getMessage().contains("toKey out of range"));
      }
  }

  @Test(timeout = 4000)
  public void testHeadMapWithIncompatibleKeyThrowsException() {
      // Test headMap with incompatible key type throws ClassCastException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      Transformer<Object, Object> transformer = MapTransformer.mapTransformer(new TreeMap<>());
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, transformer, transformer);
      
      try {
          transformedMap.headMap(baseMap); // Pass TreeMap as key (incomparable)
          fail("Expected ClassCastException");
      } catch (ClassCastException e) {
          assertTrue(e.getMessage().contains("java.util.TreeMap cannot be cast to java.lang.Comparable"));
      }
  }

  @Test(timeout = 4000)
  public void testConstructorWithNullMapThrowsException() {
      // Test constructor throws NPE when map is null
      try {
          new TransformedSortedMap<>(null, null, null);
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          assertEquals("map", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testFirstKeyWithMockComparatorReturnsNull() throws Throwable {
      // Test firstKey returns null when comparator breaks natural order
      Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(1, 1).when(mockComparator).compare(any(), any());
      
      TreeMap<Object, Integer> baseMap = new TreeMap<>(mockComparator);
      Integer value = 61;
      baseMap.put(value, value);
      
      Transformer<Object, Object> keyTransformer = MapTransformer.mapTransformer(new TreeMap<>());
      Transformer<Integer, Integer> valueTransformer = new ConstantTransformer<>(value);
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      assertNull(transformedMap.firstKey());
  }

  @Test(timeout = 4000)
  public void testFirstKeyOnEmptyMapThrowsException() {
      // Test firstKey throws NoSuchElementException on empty map
      Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      TreeMap<Object, Integer> baseMap = new TreeMap<>(mockComparator);
      
      Transformer<Object, Object> keyTransformer = MapTransformer.mapTransformer(new TreeMap<>());
      Transformer<Integer, Integer> valueTransformer = new ConstantTransformer<>(61);
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      try {
          transformedMap.firstKey();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testSubMapWithNullKeyThrowsException() {
      // Test subMap with null key throws NullPointerException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformingSortedMap(baseMap, null, null);
      
      try {
          transformedMap.subMap(null, baseMap);
          fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testLastKeyOnEmptyMapThrowsException() {
      // Test lastKey throws NoSuchElementException on empty map
      Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      TreeMap<Object, Integer> baseMap = new TreeMap<>(mockComparator);
      
      Transformer<Object, Object> keyTransformer = MapTransformer.mapTransformer(new TreeMap<>());
      Transformer<Integer, Integer> valueTransformer = new ConstantTransformer<>(61);
      TransformedSortedMap<Object, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, keyTransformer, valueTransformer);
      
      try {
          transformedMap.lastKey();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testTailMapWithNullKeyThrowsException() {
      // Test tailMap with null key throws NullPointerException
      TreeMap<Object, Object> baseMap = new TreeMap<>();
      TransformedSortedMap<Object, Object> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, null, null);
      
      try {
          transformedMap.tailMap(null);
          fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
  }

  @Test(timeout = 4000)
  public void testComparatorWithMockComparator() throws Throwable {
      // Test comparator returns custom comparator instance
      Comparator<Integer> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(null).when(mockComparator).toString();
      
      TreeMap<Integer, Integer> baseMap = new TreeMap<>(mockComparator);
      Transformer<Object, Integer> transformer = InvokerTransformer.invokerTransformer("i]oNU\\u7I%x");
      TransformedSortedMap<Integer, Integer> transformedMap = 
          TransformedSortedMap.transformedSortedMap(baseMap, transformer, transformer);
      
      Comparator<? super Integer> resultComparator = transformedMap.comparator();
      assertSame(mockComparator, resultComparator);
  }
}