/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 15:34:53 GMT 2025
 */

package org.apache.commons.cli;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PatternOptionBuilder;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

import java.util.HashMap;
import java.util.Map;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class PatternOptionBuilder_ESTest extends PatternOptionBuilder_ESTest_scaffolding {

    // Tests for isValueCode method
    @Test(timeout = 4000)
    public void testIsValueCode_ValueCodes_ReturnsTrue() {
        char[] valueCodes = {'%', ':', '<', '#', '/', '@', '+', '*', '!', '>'};
        for (char c : valueCodes) {
            assertTrue(PatternOptionBuilder.isValueCode(c));
        }
    }

    @Test(timeout = 4000)
    public void testIsValueCode_NonValueCodes_ReturnsFalse() {
        char[] nonValueCodes = {',', '.', '?', '=', ';', '9', '8', '7', '6', '5', '4', '3', '2', '1', '0', '-', ')', '(', '\'', '&', '$', 'y'};
        for (char c : nonValueCodes) {
            assertFalse(PatternOptionBuilder.isValueCode(c));
        }
    }

    // Tests for getValueType method
    @Test(timeout = 4000)
    public void testGetValueType_MappedValueCodes_ReturnsExpectedClass() {
        Map<Character, Class<?>> testCases = new HashMap<>();
        testCases.put('+', Class.class);
        testCases.put('@', Object.class);
        testCases.put('*', File[].class);
        testCases.put('<', FileInputStream.class);
        testCases.put('%', Number.class);
        testCases.put('#', Date.class);
        testCases.put(':', String.class);
        testCases.put('/', URL.class);
        testCases.put('>', File.class);

        for (Map.Entry<Character, Class<?>> entry : testCases.entrySet()) {
            assertEquals(entry.getValue(), PatternOptionBuilder.getValueType(entry.getKey()));
        }
    }

    @Test(timeout = 4000)
    public void testGetValueType_UnmappedChars_ReturnsNull() {
        char[] unmappedChars = {'!', ',', '.', '?', '=', ';', '9', '8', '7', '6', '5', '4', '3', '2', '1', '0', '-', ')', '(', '\'', '&', '$', 'y'};
        for (char c : unmappedChars) {
            assertNull(PatternOptionBuilder.getValueType(c));
        }
    }

    // Tests for getValueClass (deprecated)
    @Test(timeout = 4000)
    public void testGetValueClass_ForColon_ReturnsStringClass() {
        Object result = PatternOptionBuilder.getValueClass(':');
        assertNotNull(result);
        assertEquals(String.class, result);
    }

    // Tests for parsePattern method
    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testParsePattern_NullInput_ThrowsNullPointerException() {
        PatternOptionBuilder.parsePattern(null);
    }

    @Test(timeout = 4000)
    public void testParsePattern_EmptyPattern_ReturnsEmptyOptions() {
        Options options = PatternOptionBuilder.parsePattern("");
        assertNotNull(options);
        assertTrue(options.getOptions().isEmpty());
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void testParsePattern_WithIllegalOptionCharacter_ThrowsIllegalArgumentException() {
        PatternOptionBuilder.parsePattern("4K<:s%L=GX$");
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void testParsePattern_WithSingleQuote_ThrowsIllegalArgumentException() {
        PatternOptionBuilder.parsePattern("The option '%s' contains an illegal character : '%s'.");
    }

    @Test(timeout = 4000)
    public void testParsePattern_ComplexPattern1_ReturnsOptions() {
        Options options = PatternOptionBuilder.parsePattern("0dpy>mb!!Q*1_");
        assertNotNull(options);
    }

    @Test(timeout = 4000)
    public void testParsePattern_ComplexPattern2_ReturnsOptions() {
        Options options = PatternOptionBuilder.parsePattern("fWDS2@qUKbfHF+");
        assertNotNull(options);
    }

    // Test for constructor
    @Test(timeout = 4000)
    public void testConstructor() {
        PatternOptionBuilder builder = new PatternOptionBuilder();
        // Constructor test for coverage
    }
}