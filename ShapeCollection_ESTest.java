/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability and maintainability
 */

package org.locationtech.spatial4j.shape;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.junit.Assert.assertThrows;
import java.util.*;
import java.util.function.Predicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.locationtech.spatial4j.context.SpatialContext;
import org.locationtech.spatial4j.context.SpatialContextFactory;
import org.locationtech.spatial4j.distance.GeodesicSphereDistCalc;
import org.locationtech.spatial4j.shape.Point;
import org.locationtech.spatial4j.shape.Rectangle;
import org.locationtech.spatial4j.shape.Shape;
import org.locationtech.spatial4j.shape.ShapeCollection;
import org.locationtech.spatial4j.shape.SpatialRelation;
import org.locationtech.spatial4j.shape.impl.PointImpl;
import org.locationtech.spatial4j.shape.jts.JtsPoint;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class ShapeCollection_ESTest extends ShapeCollection_ESTest_scaffolding {

    // ============================================================
    //  Constructor Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void constructor_ShouldThrowNPE_WhenContextIsNull() {
        List<JtsPoint> shapes = new ArrayList<>();
        assertThrows(NullPointerException.class, () -> 
            new ShapeCollection<>(shapes, null)
        );
    }

    @Test(timeout = 4000)
    public void constructor_ShouldThrowIAE_WhenListNotRandomAccess() {
        SpatialContext ctx = SpatialContext.GEO;
        List<JtsPoint> nonRandomAccessList = new LinkedList<>();
        assertThrows(IllegalArgumentException.class, () -> 
            new ShapeCollection<>(nonRandomAccessList, ctx)
        );
    }

    // ============================================================
    //  Size & Collection Behavior Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void size_ShouldReturnZero_WhenCollectionEmpty() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertEquals(0, collection.size());
    }

    @Test(timeout = 4000)
    public void size_ShouldReturnCorrectCount_WhenCollectionHasElements() {
        List<JtsPoint> shapes = new Vector<>();
        SpatialContext ctx = SpatialContext.GEO;
        shapes.add(null);
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertEquals(1, collection.size());
    }

    @Test(timeout = 4000)
    public void getShapes_ShouldReturnSameList() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertSame(shapes, collection.getShapes());
    }

    // ============================================================
    //  Area Calculation Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void getArea_ShouldReturnZero_WhenCollectionEmpty() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        SpatialContext otherCtx = new SpatialContext(new SpatialContextFactory());
        assertEquals(0.0, collection.getArea(otherCtx), 0.01);
    }

    @Test(timeout = 4000)
    public void getArea_ShouldThrowNPE_WhenCollectionContainsNull() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        shapes.add(null);
        SpatialContext otherCtx = new SpatialContext(new SpatialContextFactory());
        assertThrows(NullPointerException.class, () -> 
            collection.getArea(otherCtx)
        );
    }

    // ============================================================
    //  Bounding Box Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void computeBoundingBox_ShouldReturnNaNBox_WhenCollectionEmpty() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContextFactory factory = new SpatialContextFactory();
        SpatialContext ctx = new SpatialContext(factory);
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        Rectangle bbox = collection.computeBoundingBox(shapes, ctx);
        
        assertEquals(Double.NaN, bbox.getMinX(), 0.01);
        assertEquals(Double.NaN, bbox.getMinY(), 0.01);
        assertEquals(Double.NaN, bbox.getMaxX(), 0.01);
        assertEquals(Double.NaN, bbox.getMaxY(), 0.01);
    }

    @Test(timeout = 4000)
    public void computeBoundingBox_ShouldThrowNPE_WhenCollectionContainsNull() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        shapes.add(null);
        SpatialContext otherCtx = new SpatialContext(new SpatialContextFactory());
        assertThrows(NullPointerException.class, () -> 
            collection.computeBoundingBox(shapes, otherCtx)
        );
    }

    // ============================================================
    //  Buffering Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void getBuffered_ShouldThrowNPE_WhenContextNull() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertThrows(NullPointerException.class, () -> 
            collection.getBuffered(1983.31, null)
        );
    }

    @Test(timeout = 4000)
    public void getBuffered_ShouldReturnBufferedCollection() {
        List<ShapeCollection<JtsPoint>> shapes = new Stack<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> inner = new ShapeCollection<>(new ArrayList<>(), ctx);
        shapes.add(inner);
        ShapeCollection<ShapeCollection<JtsPoint>> collection = 
            new ShapeCollection<>(shapes, ctx);
        
        Shape buffered = collection.getBuffered(938.8456, ctx);
        assertEquals(1, buffered.size());
    }

    // ============================================================
    //  Spatial Relation Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void relate_ShouldReturnIntersects_ForWorldBounds() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        Rectangle worldBounds = ctx.getWorldBounds();
        assertEquals(SpatialRelation.INTERSECTS, collection.relate(worldBounds));
    }

    @Test(timeout = 4000)
    public void relate_ShouldReturnDisjoint_ForPointOutside() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContextFactory factory = new SpatialContextFactory();
        SpatialContext ctx = new SpatialContext(factory);
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        Point point = new PointImpl(2180.0, -2963.967974, ctx);
        assertEquals(SpatialRelation.DISJOINT, collection.relate(point));
    }

    // ============================================================
    //  Edge Case & Exception Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void get_ShouldThrowIOOB_WhenIndexInvalid() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertThrows(IndexOutOfBoundsException.class, () -> 
            collection.get(1341)
        );
    }

    @Test(timeout = 4000)
    public void computeMutualDisjoint_ShouldThrowNPE_WhenInputNull() {
        assertThrows(NullPointerException.class, () -> 
            ShapeCollection.computeMutualDisjoint(null)
        );
    }

    // ============================================================
    //  Special Case Tests
    // ============================================================
    
    @Test(timeout = 4000)
    public void toString_ShouldHandleLargeCollections() {
        List<JtsPoint> shapes = new ArrayList<>();
        SpatialContext ctx = SpatialContext.GEO;
        for (int i = 0; i < 25; i++) {
            shapes.add(null);
        }
        ShapeCollection<JtsPoint> collection = new ShapeCollection<>(shapes, ctx);
        assertTrue(collection.toString().endsWith("...23)"));
    }

    @Test(timeout = 4000)
    public void computeMutualDisjoint_ShouldReturnTrue_WhenAllEmpty() {
        List<ShapeCollection<JtsPoint>> collections = new Stack<>();
        SpatialContext ctx = SpatialContext.GEO;
        ShapeCollection<JtsPoint> col1 = new ShapeCollection<>(new ArrayList<>(), ctx);
        ShapeCollection<JtsPoint> col2 = new ShapeCollection<>(new ArrayList<>(), ctx);
        collections.add(col1);
        collections.add(col2);
        assertTrue(ShapeCollection.computeMutualDisjoint(collections));
    }
    
    // Additional tests for equals, hashCode, getCenter, etc. would follow similar patterns...
}