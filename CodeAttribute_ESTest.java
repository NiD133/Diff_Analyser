/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:58:52 GMT 2025
 */

package org.apache.commons.compress.harmony.unpack200.bytecode;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.PipedOutputStream;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.compress.harmony.unpack200.Segment;
import org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationsAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.Attribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPClass;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionTableEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTableAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTypeTableAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager;
import org.apache.commons.compress.harmony.unpack200.bytecode.RuntimeVisibleorInvisibleAnnotationsAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.SourceFileAttribute;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class CodeAttribute_ESTest extends CodeAttribute_ESTest_scaffolding {

    // ====================== BASIC FUNCTIONALITY TESTS ======================
    
    @Test(timeout = 4000)
    public void testGetLengthWithExceptionTable() throws Throwable {
        // Setup: Create CodeAttribute with exception table entry
        byte[] codeBytes = new byte[4];
        OperandManager operandManager = new OperandManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(-2553, 85, codeBytes, null, operandManager, exceptionTable);
        
        // Add exception table entry
        CPUTF8 exceptionClass = new CPUTF8("i2f", 38);
        CPClass cpClass = new CPClass(exceptionClass, 85);
        exceptionTable.add(new ExceptionTableEntry(87, 38, 87, cpClass));
        
        // Verify length calculation includes exception table
        int length = codeAttr.getLength();
        assertEquals(24, length);
        assertEquals(85, codeAttr.maxLocals);
        assertEquals(-2553, codeAttr.maxStack);
    }

    @Test(timeout = 4000)
    public void testCodeAttributeCreationWithByteArray() throws Throwable {
        // Setup: Create CodeAttribute with specific byte array
        byte[] codeBytes = new byte[7];
        codeBytes[4] = (byte) -60; // Special instruction
        int[] dummyIntArray = new int[7];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        
        // Create attribute and verify properties
        CodeAttribute codeAttr = new CodeAttribute(28, 17, codeBytes, null, operandManager, exceptionTable);
        assertEquals(17, codeAttr.maxLocals);
        assertEquals(28, codeAttr.maxStack);
        assertEquals(9, codeAttr.codeLength);
    }

    @Test(timeout = 4000)
    public void testGetNestedClassFileEntriesWithExceptionTable() throws Throwable {
        // Setup: Create CodeAttribute with exception table
        byte[] codeBytes = new byte[10];
        OperandManager operandManager = new OperandManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        exceptionTable.addFirst(new ExceptionTableEntry(25, 25, 25, null));
        CodeAttribute codeAttr = new CodeAttribute(25, 25, codeBytes, null, operandManager, exceptionTable);
        
        // Verify nested entries
        ClassFileEntry[] nestedEntries = codeAttr.getNestedClassFileEntries();
        assertEquals(11, nestedEntries.length);
        assertEquals(25, codeAttr.maxStack);
        assertEquals(25, codeAttr.maxLocals);
        assertEquals(10, codeAttr.codeLength);
    }

    @Test(timeout = 4000)
    public void testAddLocalVariableTypeTableAttribute() throws Throwable {
        // Setup: Create CodeAttribute and add LocalVariableTypeTableAttribute
        byte[] codeBytes = new byte[7];
        OperandManager operandManager = new OperandManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(1, 1, codeBytes, null, operandManager, exceptionTable);
        
        // Add attribute
        codeAttr.addAttribute(new LocalVariableTypeTableAttribute(1, null, null, null, null, null));
        
        // Verify properties
        assertEquals(1, codeAttr.maxLocals);
        assertEquals(0, exceptionTable.size());
        assertEquals(1, codeAttr.maxStack);
        assertEquals(7, codeAttr.codeLength);
    }

    @Test(timeout = 4000)
    public void testGetStartPCs() throws Throwable {
        // Setup: Create basic CodeAttribute
        int[] dummyIntArray = new int[0];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[12];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Verify startPCs retrieval
        codeAttr.getStartPCs();
        assertEquals(12, codeAttr.codeLength);
        assertEquals(0, exceptionTable.size());
        assertEquals(0, codeAttr.maxStack);
        assertEquals(0, codeAttr.maxLocals);
    }

    // ====================== ATTRIBUTE HANDLING TESTS ======================
    
    @Test(timeout = 4000)
    public void testWriteBodyWithAddedCodeAttribute() throws Throwable {
        // Setup: Create nested CodeAttributes
        byte[] codeBytes = new byte[4];
        OperandManager operandManager = new OperandManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute parentAttr = new CodeAttribute(85, 85, codeBytes, null, operandManager, exceptionTable);
        
        // Resolve constant pool
        ClassConstantPool pool = new ClassConstantPool();
        pool.resolve(null);
        parentAttr.resolve(pool);
        
        // Add child attribute
        CodeAttribute childAttr = new CodeAttribute(39, 100, codeBytes, null, operandManager, parentAttr.exceptionTable);
        childAttr.resolve(pool);
        parentAttr.addAttribute(childAttr);
        
        // Write and verify
        MockFileOutputStream mockFileStream = new MockFileOutputStream("!", true);
        DataOutputStream dataStream = new DataOutputStream(mockFileStream);
        parentAttr.writeBody(dataStream);
        
        assertEquals(85, parentAttr.maxLocals);
        assertEquals(4, parentAttr.codeLength);
    }

    @Test(timeout = 4000)
    public void testGetLengthWithLocalVariableTableAttribute() throws Throwable {
        // Setup: Create CodeAttribute with LocalVariableTableAttribute
        int[] dummyIntArray = new int[1];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[0];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(939, 1168, codeBytes, null, operandManager, exceptionTable);
        
        // Add attribute
        CPUTF8[] dummyCPUTF8Array = new CPUTF8[1];
        codeAttr.addAttribute(new LocalVariableTableAttribute(-2518, dummyIntArray, dummyIntArray, dummyCPUTF8Array, dummyCPUTF8Array, dummyIntArray));
        
        // Verify length
        int length = codeAttr.getLength();
        assertEquals(1168, codeAttr.maxLocals);
        assertEquals(939, codeAttr.maxStack);
        assertEquals(-25160, length);
    }

    // ====================== EXCEPTION HANDLING TESTS ======================
    
    @Test(timeout = 4000)
    public void testWriteBodyWithNullAttributeThrowsException() throws Throwable {
        // Setup: Create CodeAttribute with null attribute
        byte[] codeBytes = new byte[1];
        int[] dummyIntArray = new int[1];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, null, null, null, null, dummyIntArray, null, null, null, null, null, dummyIntArray, dummyIntArray);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(3668, 3534, codeBytes, null, operandManager, exceptionTable);
        
        // Resolve constant pool
        ClassConstantPool pool = new ClassConstantPool();
        pool.resolve(null);
        codeAttr.resolve(pool);
        
        // Add null attribute
        codeAttr.addAttribute(null);
        
        // Attempt to write
        MockFileOutputStream mockFileStream = new MockFileOutputStream("fconst_1", true);
        DataOutputStream dataStream = new DataOutputStream(mockFileStream);
        
        try {
            codeAttr.writeBody(dataStream);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void testWriteBodyToPipedOutputStreamThrowsException() throws Throwable {
        // Setup: Create CodeAttribute and disconnected pipe
        int[] dummyIntArray = new int[1];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[3];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Attempt to write to disconnected pipe
        PipedOutputStream pipe = new PipedOutputStream();
        DataOutputStream dataStream = new DataOutputStream(pipe);
        
        try {
            codeAttr.writeBody(dataStream);
            fail("Expected IOException");
        } catch (IOException e) {
            assertEquals("Pipe not connected", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testResolveWithUnresolvedConstantPoolThrowsException() throws Throwable {
        // Setup: Create CodeAttribute with unresolved constant pool
        int[] dummyIntArray = new int[3];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[8];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Attempt to resolve with unresolved pool
        try {
            codeAttr.resolve(new ClassConstantPool());
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            assertEquals("Constant pool is not yet resolved; this does not make any sense", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testRenumberWithNullListThrowsException() throws Throwable {
        // Setup: Create CodeAttribute
        int[] dummyIntArray = new int[8];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[7];
        CodeAttribute codeAttr = new CodeAttribute(-1, 66, codeBytes, null, operandManager, null);
        
        // Attempt to renumber with null
        try {
            codeAttr.renumber(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void testGetNestedClassFileEntriesWithNullExceptionTableEntryThrowsException() throws Throwable {
        // Setup: Create CodeAttribute with null exception table entry
        int[] dummyIntArray = new int[0];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[4];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        exceptionTable.add(null);
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Attempt to get nested entries
        try {
            codeAttr.getNestedClassFileEntries();
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    // ====================== EDGE CASE TESTS ======================
    
    @Test(timeout = 4000)
    public void testCodeAttributeCreationWithNegativeMaxLocalsThrowsException() throws Throwable {
        // Setup: Attempt to create with negative maxLocals
        byte[] codeBytes = new byte[9];
        codeBytes[2] = (byte) -46;
        int[] dummyIntArray = new int[5];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        
        try {
            new CodeAttribute(141, -3388, codeBytes, null, operandManager, exceptionTable);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void testWriteBodyWithSourceFileAttributeThrowsException() throws Throwable {
        // Setup: Create CodeAttribute with unresolved SourceFileAttribute
        byte[] codeBytes = new byte[10];
        OperandManager operandManager = new OperandManager(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(158, 158, codeBytes, null, operandManager, exceptionTable);
        
        // Resolve constant pool
        ClassConstantPool pool = new ClassConstantPool();
        pool.resolve(null);
        codeAttr.resolve(pool);
        
        // Add unresolved attribute
        CPUTF8 sourceFileName = new CPUTF8("gp");
        codeAttr.addAttribute(new SourceFileAttribute(sourceFileName));
        
        // Attempt to write
        MockFileOutputStream mockFileStream = new MockFileOutputStream("gp", false);
        DataOutputStream dataStream = new DataOutputStream(mockFileStream);
        
        try {
            codeAttr.writeBody(dataStream);
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            assertEquals("Entry has not been resolved", e.getMessage());
        }
    }

    // ====================== ADDITIONAL TESTS ======================
    
    @Test(timeout = 4000)
    public void testToString() throws Throwable {
        // Setup: Create basic CodeAttribute
        byte[] codeBytes = new byte[2];
        int[] dummyIntArray = new int[6];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, null, dummyIntArray, null, null);
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(97, 97, codeBytes, null, operandManager, exceptionTable);
        
        // Verify toString output
        String result = codeAttr.toString();
        assertEquals("Code: 14 bytes", result);
        assertEquals(97, codeAttr.maxStack);
        assertEquals(97, codeAttr.maxLocals);
    }

    @Test(timeout = 4000)
    public void testRenumberWithByteCodeOffsets() throws Throwable {
        // Setup: Create CodeAttribute and renumber with its own offsets
        int[] dummyIntArray = new int[3];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[3];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Renumber
        codeAttr.renumber(codeAttr.byteCodeOffsets);
        
        // Verify properties
        assertEquals(0, exceptionTable.size());
        assertEquals(0, codeAttr.maxStack);
        assertEquals(0, codeAttr.maxLocals);
        assertEquals(3, codeAttr.codeLength);
    }

    @Test(timeout = 4000)
    public void testResolveWithNullConstantPoolThrowsException() throws Throwable {
        // Setup: Create CodeAttribute
        int[] dummyIntArray = new int[8];
        OperandManager operandManager = new OperandManager(dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray, dummyIntArray);
        byte[] codeBytes = new byte[3];
        LinkedList<ExceptionTableEntry> exceptionTable = new LinkedList<>();
        CodeAttribute codeAttr = new CodeAttribute(0, 0, codeBytes, null, operandManager, exceptionTable);
        
        // Attempt to resolve with null pool
        try {
            codeAttr.resolve(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }
}