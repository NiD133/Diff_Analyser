/*
 * This file was automatically generated by EvoSuite
 * Wed Jul 23 13:28:15 GMT 2025
 */

package com.fasterxml.jackson.core.format;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.format.DataFormatMatcher;
import com.fasterxml.jackson.core.format.InputAccessor;
import com.fasterxml.jackson.core.format.MatchStrength;
import java.io.ByteArrayInputStream;
import java.io.CharConversionException;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.PipedInputStream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
) 
public class DataFormatMatcher_ESTest extends DataFormatMatcher_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void testCreateMatcherWithPipedInputStreamReturnsSolidMatch() throws Throwable {
        PipedInputStream pipedInputStream = new PipedInputStream();
        byte[] buffer = new byte[6];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(pipedInputStream, buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.SOLID_MATCH);
        
        JsonFactory matchedFactory = matcher.getMatch();
        assertNotNull(matchedFactory);
        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testCreateParserWithInvalidBufferThrowsArrayIndexOutOfBounds() throws Throwable {
        byte[] buffer = new byte[6];
        ByteArrayInputStream inputStream = new ByteArrayInputStream(buffer);
        JsonFactory factory = new JsonFactory();
        // Create matcher with a buffer length (1) shorter than the data (2 bytes needed)
        DataFormatMatcher matcher = new DataFormatMatcher(
            inputStream, buffer, 2, 1, factory, MatchStrength.SOLID_MATCH
        );
        
        try {
            matcher.createParserWithMatch();
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testCreateParserWithMockFileInputStreamThrowsIOException() throws Throwable {
        byte[] buffer = new byte[3];
        FileDescriptor fileDescriptor = new FileDescriptor();
        MockFileInputStream fileInputStream = new MockFileInputStream(fileDescriptor);
        InputAccessor.Std inputAccessor = new InputAccessor.Std(fileInputStream, buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.FULL_MATCH);
        
        try {
            matcher.createParserWithMatch();
            fail("Expected IOException");
        } catch (IOException e) {
            // Expected due to mocked file stream
        }
    }

    @Test(timeout = 4000)
    public void testCreateParserWithInvalidByteSequenceThrowsCharConversionException() throws Throwable {
        byte[] buffer = new byte[9];
        buffer[2] = (byte) 0xA3; // Invalid UCS-4 sequence
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        ObjectCodec codec = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());
        JsonFactory factory = new JsonFactory(codec);
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.WEAK_MATCH);
        
        try {
            matcher.createParserWithMatch();
            fail("Expected CharConversionException");
        } catch (CharConversionException e) {
            // Expected due to invalid byte sequence
            assertTrue(e.getMessage().contains("UCS-4"));
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithNullBufferThrowsNullPointerException() throws Throwable {
        byte[] buffer = new byte[1];
        ByteArrayInputStream inputStream = new ByteArrayInputStream(buffer);
        JsonFactory factory = new JsonFactory();
        
        try {
            new DataFormatMatcher(
                inputStream, null, '"', '"', factory, MatchStrength.INCONCLUSIVE
            );
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected due to null buffer
        }
    }

    @Test(timeout = 4000)
    public void testGetDataStreamWithWeakMatchReturnsValidStream() throws Throwable {
        byte[] buffer = new byte[9];
        FileDescriptor fileDescriptor = new FileDescriptor();
        MockFileInputStream fileInputStream = new MockFileInputStream(fileDescriptor);
        InputAccessor.Std inputAccessor = new InputAccessor.Std(fileInputStream, buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.WEAK_MATCH);
        
        InputStream dataStream = matcher.getDataStream();
        assertNotNull(dataStream);
        assertTrue(matcher.hasMatch());
        assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testHasMatchWithWeakMatchAndEmptyBufferReturnsTrue() throws Throwable {
        byte[] buffer = new byte[0];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.WEAK_MATCH);
        
        assertTrue(matcher.hasMatch());
        assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testHasMatchWhenNoMatchReturnsFalse() throws Throwable {
        byte[] buffer = new byte[0];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        DataFormatMatcher matcher = inputAccessor.createMatcher(null, MatchStrength.NO_MATCH);
        
        assertFalse(matcher.hasMatch());
        assertEquals(MatchStrength.NO_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testGetMatchWhenNoMatchReturnsNull() throws Throwable {
        byte[] buffer = new byte[6];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        DataFormatMatcher matcher = inputAccessor.createMatcher(null, MatchStrength.INCONCLUSIVE);
        
        assertNull(matcher.getMatch());
    }

    @Test(timeout = 4000)
    public void testGetDataStreamWithWeakMatchReturnsStreamWithFullBuffer() throws Throwable {
        byte[] buffer = new byte[12];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.WEAK_MATCH);
        
        InputStream dataStream = matcher.getDataStream();
        assertEquals(buffer.length, dataStream.available());
        assertTrue(matcher.hasMatch());
        assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testCreateParserWithWeakMatchReturnsParser() throws Throwable {
        byte[] buffer = new byte[9];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.WEAK_MATCH);
        
        JsonParser parser = matcher.createParserWithMatch();
        assertNotNull(parser);
        assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testCreateParserWhenNoMatchReturnsNull() throws Throwable {
        byte[] buffer = new byte[0];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        DataFormatMatcher matcher = inputAccessor.createMatcher(null, MatchStrength.NO_MATCH);
        
        assertNull(matcher.createParserWithMatch());
        assertEquals(MatchStrength.NO_MATCH, matcher.getMatchStrength());
    }

    @Test(timeout = 4000)
    public void testGetMatchStrengthWithNullStrengthReturnsInconclusive() throws Throwable {
        byte[] buffer = new byte[9];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        // Create matcher with null strength (should default to INCONCLUSIVE)
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, null);
        
        assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength());
        assertTrue(matcher.hasMatch());
    }

    @Test(timeout = 4000)
    public void testGetMatchStrengthWhenNoMatchReturnsNoMatch() throws Throwable {
        byte[] buffer = new byte[14];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.NO_MATCH);
        
        assertEquals(MatchStrength.NO_MATCH, matcher.getMatchStrength());
        assertTrue(matcher.hasMatch()); // Note: hasMatch is true because factory is non-null
    }

    @Test(timeout = 4000)
    public void testGetMatchedFormatNameWhenNoMatchReturnsNull() throws Throwable {
        byte[] buffer = new byte[41];
        ByteArrayInputStream inputStream = new ByteArrayInputStream(buffer);
        DataFormatMatcher matcher = new DataFormatMatcher(
            inputStream, buffer, 0, 0, null, MatchStrength.INCONCLUSIVE
        );
        
        assertNull(matcher.getMatchedFormatName());
    }

    @Test(timeout = 4000)
    public void testConstructorWithInvalidStartAndLengthThrowsIllegalArgumentException() throws Throwable {
        byte[] buffer = new byte[0];
        ByteArrayInputStream inputStream = new ByteArrayInputStream(buffer);
        JsonFactory factory = new JsonFactory();
        
        try {
            new DataFormatMatcher(
                inputStream, buffer, '"', '"', factory, MatchStrength.INCONCLUSIVE
            );
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("Illegal start/length"));
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithNegativeLengthThrowsIllegalArgumentException() throws Throwable {
        byte[] buffer = new byte[9];
        JsonFactory factory = new JsonFactory();
        
        try {
            new DataFormatMatcher(
                null, buffer, '"', -1442, factory, MatchStrength.WEAK_MATCH
            );
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("Illegal start/length"));
        }
    }

    @Test(timeout = 4000)
    public void testGetMatchedFormatNameWithSolidMatchReturnsFormatName() throws Throwable {
        byte[] buffer = new byte[4];
        InputAccessor.Std inputAccessor = new InputAccessor.Std(buffer);
        JsonFactory factory = new JsonFactory();
        DataFormatMatcher matcher = inputAccessor.createMatcher(factory, MatchStrength.SOLID_MATCH);
        
        assertEquals(JsonFactory.FORMAT_NAME_JSON, matcher.getMatchedFormatName());
        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());
    }
}