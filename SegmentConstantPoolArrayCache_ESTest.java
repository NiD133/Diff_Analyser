/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:59:28 GMT 2025
 */

package org.apache.commons.compress.harmony.unpack200;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPoolArrayCache;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class SegmentConstantPoolArrayCache_ESTest extends SegmentConstantPoolArrayCache_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void testArrayIsCached_ReturnsFalseWhenArraySizeChanged() throws Throwable {
        // Test that arrayIsCached returns false when the cached array size doesn't match
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] originalArray = new String[4];
        String[] modifiedArray = new String[5]; // Different size
        
        IdentityHashMap<String[], SegmentConstantPoolArrayCache.CachedArray> customMap = 
            new IdentityHashMap<>();
        cache.knownArrays = customMap;
        
        // Cache the modifiedArray but map it to originalArray (simulate stale cache)
        SegmentConstantPoolArrayCache.CachedArray cachedArray = cache.new CachedArray(modifiedArray);
        customMap.put(originalArray, cachedArray);
        
        // Verify cache check fails for originalArray due to size mismatch
        assertFalse("Should not recognize array with modified size", cache.arrayIsCached(originalArray));
    }

    @Test(timeout = 4000)
    public void testCachedArray_CacheIndexesCorrectlyUpdatesSize() throws Throwable {
        // Test that cacheIndexes operation updates the lastKnownSize
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[8];
        SegmentConstantPoolArrayCache.CachedArray cachedArray = cache.new CachedArray(testArray);
        
        cachedArray.cacheIndexes();
        assertEquals("Cached size should match array length", 8, cachedArray.lastKnownSize());
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_ReturnsNullWhenKeyNotCached() throws Throwable {
        // Test null return when key isn't cached in lastArray
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[2];
        cache.lastArray = testArray;
        
        cache.cacheArray(testArray); // Cache the array
        cache.lastArray = testArray; // Set as last used
        
        // Request index for non-null key (not cached)
        List<Integer> indexes = cache.indexesForArrayKey(testArray, testArray[1]);
        assertNull("Should return null when key not cached", indexes);
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_ReturnsEmptyListWhenKeyIsNull() throws Throwable {
        // Test empty list return for null key in cached array
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        LinkedList<Integer> emptyList = new LinkedList<>();
        cache.lastIndexes = emptyList;
        
        String[] testArray = new String[2];
        cache.lastArray = testArray;
        cache.cacheArray(testArray);
        cache.lastArray = testArray;
        
        List<Integer> result = cache.indexesForArrayKey(testArray, null);
        assertTrue("Should return empty list for null key", result.isEmpty());
    }

    @Test(timeout = 4000)
    public void testArrayIsCached_ReturnsTrueAfterCaching() throws Throwable {
        // Test arrayIsCached returns true after successful caching
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[8];
        
        // Initial index lookup implicitly caches
        List<Integer> initialIndexes = cache.indexesForArrayKey(testArray, "Trying to cache an array that already exists");
        assertNotNull("Should cache array during first access", initialIndexes);
        
        // Verify array is properly cached
        assertTrue("Array should be recognized as cached", cache.arrayIsCached(testArray));
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_ThrowsNPEForNullArray() throws Throwable {
        // Test null array parameter handling
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        try {
            cache.indexesForArrayKey(null, "");
            fail("Expected NullPointerException for null array");
        } catch (NullPointerException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testCacheArray_ThrowsNPEForNullArray() throws Throwable {
        // Test null array caching
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        try {
            cache.cacheArray(null);
            fail("Expected NullPointerException for null array");
        } catch (NullPointerException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testArrayIsCached_ThrowsNPEWhenKnownArraysNull() throws Throwable {
        // Test null knownArrays map handling
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[4];
        cache.knownArrays = null;
        
        try {
            cache.arrayIsCached(testArray);
            fail("Expected NullPointerException when knownArrays is null");
        } catch (NullPointerException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testCachedArray_indexesForKey_ReturnsEmptyForMissingKey() throws Throwable {
        // Test key lookup miss in cached array
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[2];
        cache.lastArray = testArray;
        
        SegmentConstantPoolArrayCache.CachedArray cachedArray = cache.new CachedArray(cache.lastArray);
        List<Integer> indexes = cachedArray.indexesForKey("Ui/_\")");
        assertTrue("Should return empty list for missing key", indexes.isEmpty());
    }

    @Test(timeout = 4000)
    public void testCachedArray_indexesForKey_FindsExistingKey() throws Throwable {
        // Test key lookup finds correct index
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[8];
        testArray[1] = ""; // Place key at index 1
        
        SegmentConstantPoolArrayCache.CachedArray cachedArray = cache.new CachedArray(testArray);
        List<Integer> indexes = cachedArray.indexesForKey("");
        assertEquals("Should find one occurrence of key", 1, indexes.size());
        assertEquals("Should return correct index", Integer.valueOf(1), indexes.get(0));
    }

    @Test(timeout = 4000)
    public void testCachedArray_lastKnownSize_ReturnsCorrectSize() throws Throwable {
        // Test lastKnownSize returns correct array length
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[8];
        SegmentConstantPoolArrayCache.CachedArray cachedArray = cache.new CachedArray(testArray);
        assertEquals("Should return initial array size", 8, cachedArray.lastKnownSize());
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_ReturnsEmptyForMissingKey() throws Throwable {
        // Test key lookup miss after caching
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[1];
        
        // First access caches the array
        cache.indexesForArrayKey(testArray, " CZW9XcT");
        // Second access with same key
        List<Integer> indexes = cache.indexesForArrayKey(testArray, " CZW9XcT");
        
        assertTrue("Should return empty list for missing key", indexes.isEmpty());
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_HandlesNullKeysInArray() throws Throwable {
        // Test handling of null array elements
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[9]; // All nulls
        
        // Lookup for null key should find all indices
        List<Integer> nullIndexes = cache.indexesForArrayKey(testArray, testArray[0]); // null
        assertEquals("Should find all null indices", 9, nullIndexes.size());
        
        // Lookup for empty string should find nothing
        List<Integer> emptyIndexes = cache.indexesForArrayKey(testArray, "");
        assertTrue("Should not find empty string", emptyIndexes.isEmpty());
    }

    @Test(timeout = 4000)
    public void testCacheArray_ThrowsExceptionForDuplicateCache() throws Throwable {
        // Test duplicate caching prevention
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] testArray = new String[8];
        
        // First cache succeeds
        cache.cacheArray(testArray);
        
        try {
            // Second cache attempt should fail
            cache.cacheArray(testArray);
            fail("Should throw exception when caching same array twice");
        } catch (IllegalArgumentException e) {
            assertEquals("Exception message should match", 
                         "Trying to cache an array that already exists", 
                         e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testIndexesForArrayKey_FindsKeysAfterCaching() throws Throwable {
        // Test key lookup after caching with custom mapping
        SegmentConstantPoolArrayCache cache = new SegmentConstantPoolArrayCache();
        String[] lookupArray = new String[1]; // Array we'll use for lookup
        String[] cachedArray = new String[0]; // Array we've actually cached
        
        // Set up custom mapping: lookupArray -> cachedArray's CachedArray
        IdentityHashMap<String[], SegmentConstantPoolArrayCache.CachedArray> customMap = 
            new IdentityHashMap<>();
        cache.knownArrays = customMap;
        customMap.put(lookupArray, cache.new CachedArray(cachedArray));
        
        // Should find the cached array (even though it's mapped to lookupArray)
        List<Integer> indexes = cache.indexesForArrayKey(lookupArray, lookupArray[0]);
        
        assertNotNull("Should return index list", indexes);
        assertEquals("Should find one occurrence (null element)", 1, indexes.size());
    }
}