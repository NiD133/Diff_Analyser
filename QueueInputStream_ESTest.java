/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 01:03:16 GMT 2025
 */

package org.apache.commons.io.input;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.PriorityBlockingQueue;
import org.apache.commons.io.input.QueueInputStream;
import org.apache.commons.io.output.QueueOutputStream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class QueueInputStream_ESTest extends QueueInputStream_ESTest_scaffolding {

    // Tests for Builder methods
    @Test(timeout = 4000)
    public void testBuilderSetTimeoutReturnsSameBuilder() throws Throwable {
        QueueInputStream.Builder builder = QueueInputStream.builder();
        Duration timeout = ChronoUnit.HOURS.getDuration();
        QueueInputStream.Builder sameBuilder = builder.setTimeout(timeout);
        assertSame(builder, sameBuilder);
    }

    @Test(timeout = 4000)
    public void testBuilderSetBlockingQueueReturnsSameBuilder() throws Throwable {
        QueueInputStream.Builder builder = new QueueInputStream.Builder();
        LinkedBlockingDeque<Integer> queue = new LinkedBlockingDeque<>();
        QueueInputStream.Builder sameBuilder = builder.setBlockingQueue(queue);
        assertSame(builder, sameBuilder);
    }

    @Test(timeout = 4000)
    public void testBuilderSetNegativeTimeoutThrowsIllegalArgumentException() throws Throwable {
        QueueInputStream.Builder builder = QueueInputStream.builder();
        Duration negativeDuration = Duration.ofHours(-2277L);
        try {
            builder.setTimeout(negativeDuration);
            fail("Expected IllegalArgumentException for negative timeout");
        } catch (IllegalArgumentException e) {
            assertEquals("timeout must not be negative", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testBuilderSetNullTimeoutReturnsSameBuilder() throws Throwable {
        QueueInputStream.Builder builder = new QueueInputStream.Builder();
        QueueInputStream.Builder sameBuilder = builder.setTimeout(null);
        assertSame(builder, sameBuilder);
    }

    @Test(timeout = 4000)
    public void testBuilderGetReturnsNonNullInstance() throws Throwable {
        QueueInputStream.Builder builder = QueueInputStream.builder();
        QueueInputStream stream = builder.get();
        assertNotNull(stream);
    }

    @Test(timeout = 4000)
    public void testBuilderSetTimeoutWithSameDurationReturnsSameBuilder() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        Duration timeout = stream.getTimeout();
        QueueInputStream.Builder builder = QueueInputStream.builder();
        QueueInputStream.Builder sameBuilder = builder.setTimeout(timeout);
        assertSame(builder, sameBuilder);
    }

    // Tests for read operations
    @Test(timeout = 4000)
    public void testReadByteArrayWithOffsetAndLengthFromNonEmptyQueue() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        Integer value = -728;
        queue.add(value);
        QueueInputStream stream = new QueueInputStream(queue);
        byte[] buffer = new byte[8];
        int bytesRead = stream.read(buffer, 1, 1);
        assertEquals(1, bytesRead);
    }

    @Test(timeout = 4000)
    public void testReadByteArrayWithOffsetAndLengthFromEmptyQueueReturnsMinusOne() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        byte[] buffer = new byte[4];
        int bytesRead = stream.read(buffer, 1, 1);
        assertEquals(-1, bytesRead);
    }

    @Test(timeout = 4000)
    public void testReadReturnsZero() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        Integer value = 0;
        queue.add(value);
        QueueInputStream stream = new QueueInputStream(queue);
        int byteValue = stream.read();
        assertEquals(0, byteValue);
    }

    @Test(timeout = 4000)
    public void testReadFromEmptyQueueReturnsMinusOne() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        QueueInputStream stream = new QueueInputStream(queue);
        int byteValue = stream.read();
        assertEquals(-1, byteValue);
    }

    @Test(timeout = 4000)
    public void testSkipOneElement() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        Integer value = -728;
        queue.add(value);
        QueueInputStream stream = new QueueInputStream(queue);
        long skipped = stream.skip(4014L);
        assertEquals(1L, skipped);
    }

    @Test(timeout = 4000)
    public void testReadZeroBytesReturnsZero() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        QueueInputStream stream = new QueueInputStream(queue);
        byte[] buffer = new byte[8];
        int bytesRead = stream.read(buffer, 0, 0);
        assertEquals(0, bytesRead);
    }

    @Test(timeout = 4000)
    public void testReadNegativeIntegerReturnsExpectedByte() throws Throwable {
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        Integer value = -728;
        queue.add(value);
        QueueInputStream stream = new QueueInputStream(queue);
        int byteValue = stream.read();
        assertEquals(40, byteValue); // Least significant byte of -728
    }

    // Tests for exception cases
    @Test(timeout = 4000)
    public void testReadByteArrayWithInvalidOffsetAndLengthThrowsIndexOutOfBoundsException() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        byte[] buffer = new byte[0];
        try {
            stream.read(buffer, 2005, 2005);
            fail("Expected IndexOutOfBoundsException for invalid range");
        } catch (IndexOutOfBoundsException e) {
            assertEquals("Range [2005, 2005 + 2005) out of bounds for length 0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadByteArrayWithNegativeLengthThrowsIndexOutOfBoundsException() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        byte[] buffer = new byte[19];
        try {
            stream.read(buffer, 1557, -1357);
            fail("Expected IndexOutOfBoundsException for negative length");
        } catch (IndexOutOfBoundsException e) {
            assertEquals("Range [1557, 1557 + -1357) out of bounds for length 19", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadByteArrayWithNegativeOffsetThrowsIndexOutOfBoundsException() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        byte[] buffer = new byte[0];
        try {
            stream.read(buffer, -3123, -3123);
            fail("Expected IndexOutOfBoundsException for negative offset");
        } catch (IndexOutOfBoundsException e) {
            assertEquals("Range [-3123, -3123 + -3123) out of bounds for length 0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadNullByteArrayThrowsNullPointerException() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        try {
            stream.read(null, 16, 16);
            fail("Expected NullPointerException for null buffer");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    // Tests for other functionality
    @Test(timeout = 4000)
    public void testGetBlockingQueueReturnsNonNullWhenConstructedWithNull() throws Throwable {
        QueueInputStream stream = new QueueInputStream((BlockingQueue<Integer>) null);
        BlockingQueue<Integer> queue = stream.getBlockingQueue();
        assertNotNull(queue);
    }

    @Test(timeout = 4000)
    public void testNewQueueOutputStreamReturnsNonNull() throws Throwable {
        QueueInputStream stream = new QueueInputStream();
        QueueOutputStream outputStream = stream.newQueueOutputStream();
        assertNotNull(outputStream);
    }
}