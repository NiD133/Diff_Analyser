/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 01:03:16 GMT 2025
 */

package org.apache.commons.io.input;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.PriorityBlockingQueue;
import org.apache.commons.io.input.QueueInputStream;
import org.apache.commons.io.output.QueueOutputStream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class QueueInputStream_ESTest extends QueueInputStream_ESTest_scaffolding {

    // ========== Builder Tests ==========

    @Test(timeout = 4000)
    public void testBuilderSetTimeout_ReturnsBuilderInstance() throws Throwable {
        // Given
        QueueInputStream.Builder builder = QueueInputStream.builder();
        Duration oneHourTimeout = ChronoUnit.HOURS.getDuration();
        
        // When
        QueueInputStream.Builder result = builder.setTimeout(oneHourTimeout);
        
        // Then - builder pattern should return same instance for method chaining
        assertSame(builder, result);
    }

    @Test(timeout = 4000)
    public void testBuilderSetBlockingQueue_ReturnsBuilderInstance() throws Throwable {
        // Given
        QueueInputStream.Builder builder = new QueueInputStream.Builder();
        LinkedBlockingDeque<Integer> customQueue = new LinkedBlockingDeque<>();
        
        // When
        QueueInputStream.Builder result = builder.setBlockingQueue(customQueue);
        
        // Then - builder pattern should return same instance for method chaining
        assertSame(builder, result);
    }

    @Test(timeout = 4000)
    public void testBuilderSetNullTimeout_ReturnsBuilderInstance() throws Throwable {
        // Given
        QueueInputStream.Builder builder = new QueueInputStream.Builder();
        
        // When
        QueueInputStream.Builder result = builder.setTimeout(null);
        
        // Then - should handle null timeout gracefully
        assertSame(builder, result);
    }

    @Test(timeout = 4000)
    public void testBuilderSetNegativeTimeout_ThrowsIllegalArgumentException() throws Throwable {
        // Given
        QueueInputStream.Builder builder = QueueInputStream.builder();
        Duration negativeTimeout = Duration.ofHours(-2277L);
        
        // When & Then
        try {
            builder.setTimeout(negativeTimeout);
            fail("Expected IllegalArgumentException for negative timeout");
        } catch(IllegalArgumentException e) {
            assertEquals("timeout must not be negative", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testBuilderGet_CreatesQueueInputStream() throws Throwable {
        // Given
        QueueInputStream.Builder builder = QueueInputStream.builder();
        
        // When
        QueueInputStream inputStream = builder.get();
        
        // Then
        assertNotNull(inputStream);
    }

    // ========== Constructor Tests ==========

    @Test(timeout = 4000)
    public void testConstructorWithNullQueue_CreatesDefaultQueue() throws Throwable {
        // Given & When
        QueueInputStream inputStream = new QueueInputStream((BlockingQueue<Integer>) null);
        
        // Then - should create a default blocking queue when null is passed
        BlockingQueue<Integer> queue = inputStream.getBlockingQueue();
        assertNotNull(queue);
    }

    // ========== Read Tests ==========

    @Test(timeout = 4000)
    public void testReadSingleByte_WithDataInQueue_ReturnsData() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        queue.add(0); // Add byte value 0
        QueueInputStream inputStream = new QueueInputStream(queue);
        
        // When
        int result = inputStream.read();
        
        // Then
        assertEquals(0, result);
    }

    @Test(timeout = 4000)
    public void testReadSingleByte_WithEmptyQueue_ReturnsEndOfStream() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> emptyQueue = new PriorityBlockingQueue<>();
        QueueInputStream inputStream = new QueueInputStream(emptyQueue);
        
        // When
        int result = inputStream.read();
        
        // Then - should return -1 for end of stream
        assertEquals(-1, result);
    }

    @Test(timeout = 4000)
    public void testReadSingleByte_WithNegativeValue_ReturnsUnsignedByte() throws Throwable {
        // Given - negative integer should be converted to unsigned byte
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        queue.add(-728);
        QueueInputStream inputStream = new QueueInputStream(queue);
        
        // When
        int result = inputStream.read();
        
        // Then - negative value should be converted to unsigned byte (40 = -728 & 0xFF)
        assertEquals(40, result);
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithDataInQueue_ReadsOneByteSuccessfully() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        queue.add(-728);
        QueueInputStream inputStream = new QueueInputStream(queue);
        byte[] buffer = new byte[8];
        
        // When
        int bytesRead = inputStream.read(buffer, 1, 1);
        
        // Then
        assertEquals(1, bytesRead);
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithEmptyQueue_ReturnsEndOfStream() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        byte[] buffer = new byte[4];
        
        // When
        int bytesRead = inputStream.read(buffer, 1, 1);
        
        // Then
        assertEquals(-1, bytesRead);
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithZeroLength_ReturnsZero() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        QueueInputStream inputStream = new QueueInputStream(queue);
        byte[] buffer = new byte[8];
        
        // When - reading 0 bytes should return 0
        int bytesRead = inputStream.read(buffer, 0, 0);
        
        // Then
        assertEquals(0, bytesRead);
    }

    // ========== Read Error Handling Tests ==========

    @Test(timeout = 4000)
    public void testReadByteArray_WithInvalidRange_ThrowsIndexOutOfBoundsException() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        byte[] emptyBuffer = new byte[0];
        
        // When & Then
        try {
            inputStream.read(emptyBuffer, 2005, 2005);
            fail("Expected IndexOutOfBoundsException");
        } catch(IndexOutOfBoundsException e) {
            assertEquals("Range [2005, 2005 + 2005) out of bounds for length 0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithNegativeLength_ThrowsIndexOutOfBoundsException() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        byte[] buffer = new byte[19];
        
        // When & Then
        try {
            inputStream.read(buffer, 1557, -1357);
            fail("Expected IndexOutOfBoundsException for negative length");
        } catch(IndexOutOfBoundsException e) {
            assertEquals("Range [1557, 1557 + -1357) out of bounds for length 19", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithNegativeOffsetAndLength_ThrowsIndexOutOfBoundsException() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        byte[] emptyBuffer = new byte[0];
        
        // When & Then
        try {
            inputStream.read(emptyBuffer, -3123, -3123);
            fail("Expected IndexOutOfBoundsException for negative offset and length");
        } catch(IndexOutOfBoundsException e) {
            assertEquals("Range [-3123, -3123 + -3123) out of bounds for length 0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testReadByteArray_WithNullBuffer_ThrowsNullPointerException() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        
        // When & Then
        try {
            inputStream.read(null, 16, 16);
            fail("Expected NullPointerException for null buffer");
        } catch(NullPointerException e) {
            // Expected - null buffer should throw NPE
        }
    }

    // ========== Skip Tests ==========

    @Test(timeout = 4000)
    public void testSkip_WithDataInQueue_SkipsAvailableBytes() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        queue.add(-728);
        QueueInputStream inputStream = new QueueInputStream(queue);
        
        // When - try to skip more bytes than available
        long bytesSkipped = inputStream.skip(4014L);
        
        // Then - should only skip the 1 available byte
        assertEquals(1L, bytesSkipped);
    }

    // ========== Utility Method Tests ==========

    @Test(timeout = 4000)
    public void testNewQueueOutputStream_CreatesConnectedOutputStream() throws Throwable {
        // Given
        QueueInputStream inputStream = new QueueInputStream();
        
        // When
        QueueOutputStream outputStream = inputStream.newQueueOutputStream();
        
        // Then
        assertNotNull(outputStream);
    }

    @Test(timeout = 4000)
    public void testGetTimeout_ReturnsConfiguredTimeout() throws Throwable {
        // Given
        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        QueueInputStream inputStream = new QueueInputStream(queue);
        Duration timeout = inputStream.getTimeout();
        
        // When - use the timeout to configure a new builder
        QueueInputStream.Builder builder = QueueInputStream.builder();
        QueueInputStream.Builder result = builder.setTimeout(timeout);
        
        // Then
        assertSame(builder, result);
    }
}