/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 00:55:51 GMT 2025
 */

package org.apache.commons.io.input;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.PipedReader;
import java.io.StringReader;
import java.nio.CharBuffer;
import org.apache.commons.io.input.CloseShieldReader;
import org.apache.commons.io.input.TaggedReader;
import org.apache.commons.io.input.TeeReader;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockIOException;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class ProxyReader_ESTest extends ProxyReader_ESTest_scaffolding {

    // ========================================================================
    // TeeReader Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void teeReader_beforeRead_zeroBytes_doesNotThrow() throws Throwable {
        PipedReader pipedReader = new PipedReader(1018);
        CharArrayWriter writer = new CharArrayWriter(1018);
        TeeReader teeReader = new TeeReader(pipedReader, writer);
        
        // Should handle zero read count without exceptions
        teeReader.beforeRead(0);
    }

    // ========================================================================
    // CloseShieldReader Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void closeShieldReader_afterRead_doesNotThrow() throws Throwable {
        StringReader baseReader = new StringReader("");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        
        // After read should execute without exceptions
        reader.afterRead(1139);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_ready_afterClose_returnsFalse() throws Throwable {
        StringReader baseReader = new StringReader("content");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        reader.close();
        
        assertFalse("Reader should not be ready after close", reader.ready());
    }

    @Test(timeout = 4000)
    public void closeShieldReader_readCharBuffer_emptySource_returnsMinusOne() throws Throwable {
        StringReader baseReader = new StringReader("");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        CharBuffer buffer = CharBuffer.allocate(10);
        
        int result = reader.read(buffer);
        assertEquals("Should return -1 for empty source", -1, result);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_readCharBuffer_nonEmptySource_returnsBytesRead() throws Throwable {
        StringReader baseReader = new StringReader("org.apache.commons.io.input.ProxyReader");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        CharBuffer buffer = CharBuffer.allocate(1366);
        
        int result = reader.read(buffer);
        assertEquals("Should return number of characters read", 39, result);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_readSingleChar_returnsCharacter() throws Throwable {
        StringReader baseReader = new StringReader("$");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        
        int result = reader.read();
        assertEquals("Should return correct character", '$', result);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_readCharArray_zeroLength_returnsZero() throws Throwable {
        StringReader baseReader = new StringReader("content");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        char[] buffer = new char[0];
        
        int result = reader.read(buffer);
        assertEquals("Zero-length read should return 0", 0, result);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_readCharArray_afterClose_returnsMinusOne() throws Throwable {
        StringReader baseReader = new StringReader("content");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        reader.close();
        char[] buffer = new char[10];
        
        int result = reader.read(buffer, 0, 1041);
        assertEquals("Should return -1 after close", -1, result);
    }

    @Test(timeout = 4000)
    public void closeShieldReader_ready_withContent_returnsTrue() throws Throwable {
        StringReader baseReader = new StringReader("content");
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        
        assertTrue("Reader should be ready with content", reader.ready());
    }

    @Test(timeout = 4000)
    public void closeShieldReader_skip_negativeValue_throwsException() {
        PipedReader baseReader = new PipedReader();
        CloseShieldReader reader = CloseShieldReader.wrap(baseReader);
        
        try {
            reader.skip(-1);
            fail("Expected IllegalArgumentException for negative skip value");
        } catch (IOException e) {
            verifyException("java.io.Reader", e);
        }
    }

    // ========================================================================
    // TaggedReader Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void taggedReader_reset_doesNotThrow() throws Throwable {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        
        // Should execute without exceptions
        reader.reset();
    }

    @Test(timeout = 4000)
    public void taggedReader_mark_doesNotThrow() throws Throwable {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        
        // Should execute without exceptions
        reader.mark(47);
    }

    @Test(timeout = 4000)
    public void taggedReader_skip_validValue_returnsBytesSkipped() throws Throwable {
        StringReader baseReader = new StringReader("sample content");
        TaggedReader reader = new TaggedReader(baseReader);
        
        long skipped = reader.skip(75);
        assertEquals("Should return number of characters skipped", 14, skipped);
    }

    @Test(timeout = 4000)
    public void taggedReader_readCharArrayOffset_validData_returnsBytesRead() throws Throwable {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        char[] buffer = new char[4];
        
        int read = reader.read(buffer, 1, 1);
        assertArrayEquals("Buffer should contain read data", 
            new char[] {'\u0000', 'c', '\u0000', '\u0000'}, buffer);
        assertEquals("Should return correct read count", 1, read);
    }

    @Test(timeout = 4000)
    public void taggedReader_readCharArray_validData_returnsBytesRead() throws Throwable {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        char[] buffer = new char[6];
        
        int read = reader.read(buffer);
        assertEquals("Should return number of characters read", 6, read);
    }

    @Test(timeout = 4000)
    public void taggedReader_readCharArray_emptySource_returnsMinusOne() throws Throwable {
        StringReader baseReader = new StringReader("");
        TaggedReader reader = new TaggedReader(baseReader);
        char[] buffer = new char[3];
        
        int result = reader.read(buffer);
        assertEquals("Should return -1 for empty source", -1, result);
    }

    @Test(timeout = 4000)
    public void taggedReader_markSupported_stringReader_returnsTrue() throws Throwable {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        
        assertTrue("markSupported should delegate to underlying reader", reader.markSupported());
    }

    @Test(timeout = 4000)
    public void taggedReader_readSingleChar_emptySource_returnsMinusOne() throws Throwable {
        StringReader baseReader = new StringReader("");
        TaggedReader reader = new TaggedReader(baseReader);
        
        int result = reader.read();
        assertEquals("Should return -1 for empty source", -1, result);
    }

    @Test(timeout = 4000)
    public void taggedReader_skip_negativeValue_throwsException() {
        PipedReader baseReader = new PipedReader();
        TaggedReader reader = new TaggedReader(baseReader);
        
        try {
            reader.skip(-1);
            fail("Expected IllegalArgumentException for negative skip value");
        } catch (IOException e) {
            verifyException("java.io.Reader", e);
        }
    }

    @Test(timeout = 4000)
    public void taggedReader_mark_negativeValue_throwsException() {
        StringReader baseReader = new StringReader("content");
        TaggedReader reader = new TaggedReader(baseReader);
        
        try {
            reader.mark(-1520);
            fail("Expected IllegalArgumentException for negative mark value");
        } catch (IOException e) {
            verifyException("java.io.StringReader", e);
        }
    }

    @Test(timeout = 4000)
    public void taggedReader_handleIOException_validException_throwsTaggedException() {
        PipedReader baseReader = new PipedReader(2398);
        TaggedReader reader = new TaggedReader(baseReader);
        MockIOException ex = new MockIOException("test");
        
        try {
            reader.handleIOException(ex);
            fail("Expected IOException to be rethrown");
        } catch (IOException e) {
            assertEquals("Exception message should be preserved", "test", e.getMessage());
        }
    }

    // ========================================================================
    // Exception Handling Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void pipedReader_read_unconnected_throwsIOException() {
        PipedReader baseReader = new PipedReader();
        TaggedReader reader = new TaggedReader(baseReader);
        
        try {
            reader.read();
            fail("Expected IOException for unconnected PipedReader");
        } catch (IOException e) {
            verifyException("org.apache.commons.io.input.TaggedReader", e);
        }
    }

    @Test(timeout = 4000)
    public void pipedReader_ready_unconnected_throwsIOException() {
        PipedReader baseReader = new PipedReader();
        TaggedReader reader = new TaggedReader(baseReader);
        
        try {
            reader.ready();
            fail("Expected IOException for unconnected PipedReader");
        } catch (IOException e) {
            verifyException("org.apache.commons.io.input.TaggedReader", e);
        }
    }

    @Test(timeout = 4000)
    public void pipedReader_readCharArray_unconnected_throwsIOException() {
        PipedReader baseReader = new PipedReader();
        TaggedReader reader = new TaggedReader(baseReader);
        char[] buffer = new char[10];
        
        try {
            reader.read(buffer, 0, 10);
            fail("Expected IOException for unconnected PipedReader");
        } catch (IOException e) {
            verifyException("org.apache.commons.io.input.TaggedReader", e);
        }
    }

    @Test(timeout = 4000)
    public void pipedReader_readCharBuffer_unconnected_throwsIOException() {
        PipedReader baseReader = new PipedReader();
        TaggedReader reader = new TaggedReader(baseReader);
        CharBuffer buffer = CharBuffer.allocate(10);
        
        try {
            reader.read(buffer);
            fail("Expected IOException for unconnected PipedReader");
        } catch (IOException e) {
            verifyException("org.apache.commons.io.input.TaggedReader", e);
        }
    }
}