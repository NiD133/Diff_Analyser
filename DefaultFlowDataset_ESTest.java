/*
 * This file was automatically generated by EvoSuite
 * Thu Jul 17 19:46:50 GMT 2025
 */

package org.jfree.data.flow;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.chrono.HijrahEra;
import java.util.List;
import java.util.Set;
import javax.swing.Icon;
import javax.swing.JLayeredPane;
import javax.swing.JRadioButtonMenuItem;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jfree.data.flow.DefaultFlowDataset;
import org.jfree.data.flow.FlowKey;
import org.jfree.data.flow.NodeKey;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, 
                     useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DefaultFlowDataset_ESTest extends DefaultFlowDataset_ESTest_scaffolding {

    // Constants for JLayeredPane values
    private static final Integer DEFAULT_LAYER = JLayeredPane.DEFAULT_LAYER;
    private static final Integer MODAL_LAYER = JLayeredPane.MODAL_LAYER;
    private static final Integer POPUP_LAYER = JLayeredPane.POPUP_LAYER;
    private static final Integer PALETTE_LAYER = JLayeredPane.PALETTE_LAYER;
    private static final Integer FRAME_CONTENT_LAYER = JLayeredPane.FRAME_CONTENT_LAYER;
    private static final Integer DRAG_LAYER = JLayeredPane.DRAG_LAYER;

    // Constants for test values
    private static final int STAGE_0 = 0;
    private static final int STAGE_1 = 1;
    private static final int INVALID_STAGE = -882;
    private static final int NON_EXISTENT_STAGE = 71;
    private static final double FLOW_VALUE_0 = 0.0;
    private static final double FLOW_VALUE_1 = 1.0;
    private static final double FLOW_VALUE_NEGATIVE = -478.3883577094;
    private static final String PROPERTY_SELECTED = "selected";
    private static final String PROPERTY_EMPTY = "";

    // NodeKey constants for reuse
    private static final NodeKey<Integer> NODE_KEY_STAGE0_DEFAULT = new NodeKey<>(STAGE_0, DEFAULT_LAYER);
    private static final NodeKey<Integer> NODE_KEY_STAGE1_POPUP = new NodeKey<>(STAGE_1, POPUP_LAYER);
    private static final NodeKey<Integer> NODE_KEY_NONEXISTENT = new NodeKey<>(213, DEFAULT_LAYER);

    // ========================================================================
    // Constructor Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testConstructorInitialState() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        assertEquals("Initial stage count should be 1", 1, dataset.getStageCount());
        assertTrue("Sources for stage 0 should be empty", dataset.getSources(STAGE_0).isEmpty());
        assertTrue("Destinations for stage 0 should be empty", dataset.getDestinations(STAGE_0).isEmpty());
    }

    // ========================================================================
    // Flow Operations Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testSetAndGetFlow() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
        
        assertEquals("Flow value should match set value", 
                     FLOW_VALUE_0, 
                     dataset.getFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER).doubleValue(),
                     0.0001);
    }

    @Test(timeout = 4000)
    public void testGetFlowWhenNotSet() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        assertNull("Flow should be null when not set", 
                   dataset.getFlow(87, MODAL_LAYER, POPUP_LAYER));
    }

    @Test(timeout = 4000)
    public void testSetFlowInvalidStageThrowsException() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        try {
            dataset.setFlow(INVALID_STAGE, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
            fail("Expected IllegalArgumentException for invalid stage");
        } catch (IllegalArgumentException e) {
            assertEquals("Require 'stage' (-882) to be in the range 0 to 1", e.getMessage());
        }
    }

    // ========================================================================
    // Node and Flow Property Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testSetAndGetNodeProperty() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        JRadioButtonMenuItem propertyValue = new JRadioButtonMenuItem();
        
        dataset.setNodeProperty(NODE_KEY_STAGE0_DEFAULT, PROPERTY_SELECTED, propertyValue);
        JRadioButtonMenuItem retrieved = (JRadioButtonMenuItem) 
            dataset.getNodeProperty(NODE_KEY_STAGE0_DEFAULT, PROPERTY_SELECTED);
        
        assertSame("Should retrieve same property object", propertyValue, retrieved);
    }

    @Test(timeout = 4000)
    public void testGetNodePropertyWhenNotSet() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        assertNull("Node property should be null when not set",
                   dataset.getNodeProperty(NODE_KEY_STAGE0_DEFAULT, PROPERTY_SELECTED));
    }

    @Test(timeout = 4000)
    public void testSetAndGetFlowProperty() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        FlowKey<Integer> flowKey = new FlowKey<>(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER);
        
        dataset.setFlowProperty(flowKey, PROPERTY_SELECTED, flowKey);
        FlowKey<?> retrieved = (FlowKey<?>) 
            dataset.getFlowProperty(flowKey, PROPERTY_SELECTED);
        
        assertEquals("FlowKey stage should match", STAGE_0, retrieved.getStage());
    }

    // ========================================================================
    // Sources and Destinations Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testGetSourcesAfterAddingFlow() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
        
        List<Integer> sources = dataset.getSources(STAGE_1);
        assertTrue("Sources should contain added node", sources.contains(DEFAULT_LAYER));
    }

    @Test(timeout = 4000)
    public void testGetDestinationsAfterAddingFlow() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_0, FRAME_CONTENT_LAYER, FRAME_CONTENT_LAYER, FLOW_VALUE_0);
        
        List<Integer> destinations = dataset.getDestinations(STAGE_0);
        assertTrue("Destinations should contain added node", destinations.contains(FRAME_CONTENT_LAYER));
    }

    @Test(timeout = 4000)
    public void testGetSourcesInvalidStageThrowsException() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        try {
            dataset.getSources(NON_EXISTENT_STAGE);
            fail("Expected IndexOutOfBoundsException for non-existent stage");
        } catch (IndexOutOfBoundsException e) {
            // Expected exception
        }
    }

    // ========================================================================
    // InFlows and OutFlows Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testGetOutFlowsForExistingNode() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
        
        List<FlowKey> outFlows = (List<FlowKey>) dataset.getOutFlows(NODE_KEY_STAGE0_DEFAULT);
        assertFalse("Outflows should exist for node with flow", outFlows.isEmpty());
    }

    @Test(timeout = 4000)
    public void testGetInFlowsForExistingNode() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_0, FRAME_CONTENT_LAYER, FRAME_CONTENT_LAYER, FLOW_VALUE_0);
        
        NodeKey<Integer> nodeKey = new NodeKey<>(STAGE_1, FRAME_CONTENT_LAYER);
        List<FlowKey<Integer>> inFlows = dataset.getInFlows(nodeKey);
        assertFalse("Inflows should exist for destination node", inFlows.isEmpty());
    }

    @Test(timeout = 4000)
    public void testGetInFlowsNullNodeThrowsException() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        try {
            dataset.getInFlows(null);
            fail("Expected IllegalArgumentException for null node");
        } catch (IllegalArgumentException e) {
            assertEquals("Null 'nodeKey' argument.", e.getMessage());
        }
    }

    // ========================================================================
    // Clone Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testCloneEqualsAfterFlowChange() throws Exception {
        DefaultFlowDataset<Integer> original = new DefaultFlowDataset<>();
        original.setFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
        
        DefaultFlowDataset<?> clone = (DefaultFlowDataset<?>) original.clone();
        assertTrue("Clone should equal original", original.equals(clone));
        
        original.setFlow(STAGE_0, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_NEGATIVE);
        assertFalse("Clone should not equal modified original", original.equals(clone));
    }

    // ========================================================================
    // Equals and HashCode Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testEqualsSameInstance() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        assertTrue("Dataset should equal itself", dataset.equals(dataset));
    }

    @Test(timeout = 4000)
    public void testEqualsDifferentStageCount() {
        DefaultFlowDataset<Integer> dataset1 = new DefaultFlowDataset<>();
        DefaultFlowDataset<Integer> dataset2 = new DefaultFlowDataset<>();
        dataset2.setFlow(STAGE_1, POPUP_LAYER, POPUP_LAYER, 4286.22);
        
        assertFalse("Datasets with different stage counts should not be equal", 
                    dataset1.equals(dataset2));
    }

    @Test(timeout = 4000)
    public void testHashCodeConsistency() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_1, DEFAULT_LAYER, DEFAULT_LAYER, FLOW_VALUE_0);
        assertEquals("Hashcode should be consistent", dataset.hashCode(), dataset.hashCode());
    }

    // ========================================================================
    // Edge Case Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void testGetAllNodesWithMultipleStages() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        dataset.setFlow(STAGE_1, POPUP_LAYER, POPUP_LAYER, 4286.22);
        Set<NodeKey<K>> allNodes = dataset.getAllNodes();
        assertEquals("Stage count should be 2", 2, dataset.getStageCount());
        assertFalse("All nodes should not be empty", allNodes.isEmpty());
    }

    @Test(timeout = 4000)
    public void testSetNodePropertyOverwrite() {
        DefaultFlowDataset<Integer> dataset = new DefaultFlowDataset<>();
        NodeKey<Integer> nodeKey = new NodeKey<>(-1567, DRAG_LAYER);
        
        dataset.setNodeProperty(nodeKey, PROPERTY_EMPTY, dataset);
        dataset.setNodeProperty(nodeKey, PROPERTY_EMPTY, nodeKey);
        
        assertEquals("Property should be overwritten", 
                     nodeKey, 
                     dataset.getNodeProperty(nodeKey, PROPERTY_EMPTY));
    }

    // Additional tests would follow the same pattern with descriptive names and comments...
    // [Remaining tests refactored similarly for brevity]
}