package org.apache.commons.compress.archivers.zip;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import java.util.zip.ZipException;

// Note: The original test was auto-generated by EvoSuite. This version is refactored for human readability.
// The class name and inheritance are kept from the original for context.
public class ExtraFieldUtils_ESTestTest25 extends ExtraFieldUtils_ESTest_scaffolding {

    /**
     * Tests that ExtraFieldUtils.parse, when using a lenient parsing mode,
     * will silently skip a malformed extra field whose declared length
     * exceeds the available data, and return an empty array instead of throwing an exception.
     */
    @Test(timeout = 4000)
    public void parseWithLenientModeShouldSkipExtraFieldWithInvalidLength() {
        // Arrange: Create extra field data where a field's declared length
        // exceeds the size of the remaining byte array.
        // Extra field format: Header ID (2 bytes) + Data Size (2 bytes) + Data
        
        // We create a 9-byte array. The first 4 bytes are for the header and size.
        // This leaves 5 bytes for data. We will declare a size much larger than 5.
        byte[] malformedExtraFieldData = new byte[9];
        
        // Set Header ID = 0x0000 (bytes at index 0 and 1 are already 0 by default)
        
        // Set Data Size = 0xD100 = 53504 (read little-endian from bytes at indices 2 and 3).
        // This is achieved by setting the most significant byte of the size field.
        malformedExtraFieldData[3] = (byte) 0xD1; // This creates a length of 53504

        final boolean isForLocalFileHeader = true;
        final ExtraFieldParsingBehavior lenientParsingMode =
                ZipArchiveEntry.ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT;

        // Act: Parse the malformed data using the lenient mode.
        ZipExtraField[] parsedFields = null;
        try {
            parsedFields = ExtraFieldUtils.parse(
                    malformedExtraFieldData, isForLocalFileHeader, lenientParsingMode);
        } catch (ZipException e) {
            fail("Parsing with lenient mode should not have thrown a ZipException for this malformed data.");
        }

        // Assert: The parser should silently skip the malformed field and return an empty array.
        assertNotNull("The result of parsing should not be null.", parsedFields);
        assertEquals("No extra fields should be parsed from the malformed data.", 0, parsedFields.length);
    }
}