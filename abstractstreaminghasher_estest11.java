package com.google.common.hash;

import static org.junit.Assert.fail;

import java.nio.BufferOverflowException;
import org.junit.Test;

/**
 * This test class contains a test case for AbstractStreamingHasher, focusing on its behavior after
 * the hash has been computed.
 * Note: The original class was generated by the EvoSuite test generation tool.
 */
public class AbstractStreamingHasher_ESTestTest11 extends AbstractStreamingHasher_ESTest_scaffolding {

    /**
     * Verifies that attempting to add more bytes to a hasher after its {@code hash()} method has
     * been called results in an exception. Once a hash is computed, the hasher instance should be
     * considered finalized and immutable.
     */
    @Test
    public void putBytes_afterHashIsCalculated_throwsException() {
        // Arrange: Create a hasher and calculate its hash to put it in a "used" state.
        // A concrete implementation of AbstractStreamingHasher is needed for the test.
        Hasher hasher = new Crc32cHashFunction.Crc32cHasher();
        hasher.hash(); // This finalizes the hasher, making it unusable for further updates.

        byte[] additionalBytes = new byte[2];

        // Act & Assert: Attempting to add more bytes should fail.
        try {
            hasher.putBytes(additionalBytes, 1, 1);
            fail("Expected a BufferOverflowException because the hasher has already been used.");
        } catch (BufferOverflowException expected) {
            // This is the expected behavior. The internal buffer is flipped by the hash() call
            // and has no remaining capacity for new data, leading to this exception.
        }
    }
}