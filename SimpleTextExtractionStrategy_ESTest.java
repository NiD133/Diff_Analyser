/*
 * This file was automatically generated by EvoSuite
 * Thu Jul 17 18:30:28 GMT 2025
 */

package com.itextpdf.text.pdf.parser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.itextpdf.text.pdf.CMapAwareDocumentFont;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfSigLockDictionary;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.parser.GraphicsState;
import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.MarkedContentInfo;
import com.itextpdf.text.pdf.parser.Matrix;
import com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import java.nio.CharBuffer;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashSet;
import javax.swing.text.Segment;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class SimpleTextExtractionStrategy_ESTest extends SimpleTextExtractionStrategy_ESTest_scaffolding {

    // Test basic text rendering functionality
    @Test(timeout = 4000)
    public void renderTextShouldAppendToResultantText()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        PdfDate pdfDate = new PdfDate();
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = new Matrix();
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = new PdfAction();
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        
        TextRenderInfo textInfo = new TextRenderInfo(pdfDate, graphicsState, matrix, markedContentSet);
        
        // First render call processes the text chunk
        strategy.renderText(textInfo);
        
        // Manually append additional text
        strategy.appendTextChunk("Cp1257");
        
        // Second render call should process another chunk
        strategy.renderText(textInfo);
        
        assertEquals("Cp1257", strategy.getResultantText());
    }

    // Test text appending with StringBuffer
    @Test(timeout = 4000)
    public void appendTextChunkWithStringBufferShouldUpdateResult()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        StringBuffer buffer = new StringBuffer(",.,u/K'~XTk8go");
        
        strategy.appendTextChunk(buffer);
        String result = strategy.getResultantText();
        
        assertEquals(",.,u/K'~XTk8go", result);
    }

    // Test exception handling for unsupported charsets
    @Test(timeout = 4000)
    public void renderTextShouldThrowWhenFontHasUnsupportedCharset()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = graphicsState.getCtm();
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = new PdfAction("UnicodeBig", "UnicodeBig", "", "PDF");
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        PdfString pdfString = new PdfString("MacRoman", "Times-BoldItalic");
        TextRenderInfo textInfo = new TextRenderInfo(pdfString, graphicsState, matrix, markedContentSet);

        try { 
            strategy.renderText(textInfo);
            fail("Expected UnsupportedCharsetException for 'Times-BoldItalic'");
        } catch(UnsupportedCharsetException e) {
            assertEquals("Times-BoldItalic", e.getMessage());
        }
    }

    // Test exception handling for illegal charset names
    @Test(timeout = 4000)
    public void renderTextShouldThrowWhenFontHasIllegalCharsetName()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = new Matrix();
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = PdfAction.createLaunch("", "", "PDF", "");
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        PdfString pdfString = new PdfString("Identity-H", ">|");
        TextRenderInfo textInfo = new TextRenderInfo(pdfString, graphicsState, matrix, markedContentSet);

        try { 
            strategy.renderText(textInfo);
            fail("Expected IllegalCharsetNameException for '>|'");
        } catch(IllegalCharsetNameException e) {
            assertEquals(">|", e.getMessage());
        }
    }

    // Test error handling in specific encoding scenarios
    @Test(timeout = 4000)
    public void renderTextShouldThrowErrorForSpecificEncoding()  {
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = graphicsState.getCtm();
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = new PdfAction("");
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        PdfString pdfString = new PdfString("Cp1252", "Cp1250");
        TextRenderInfo textInfo = new TextRenderInfo(pdfString, graphicsState, matrix, markedContentSet);

        try { 
            strategy.renderText(textInfo);
            fail("Expected NoSuchMethodError due to encoding issue");
        } catch(NoSuchMethodError e) {
            assertTrue(e.getMessage().contains("java.nio.ByteBuffer.rewind()"));
        }
    }

    // Test Segment handling with invalid parameters
    @Test(timeout = 4000)
    public void appendTextChunkShouldThrowWhenSegmentArrayIsNull()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        Segment segment = new Segment((char[]) null, 2087, 2087);

        try { 
            strategy.appendTextChunk(segment);
            fail("Expected NullPointerException for null char array");
        } catch(NullPointerException e) {
            // Expected due to null character array
        }
    }

    @Test(timeout = 4000)
    public void appendTextChunkShouldThrowForNegativeSegmentCount()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        char[] charArray = new char[2];
        Segment segment = new Segment(charArray, -26, -26);

        try { 
            strategy.appendTextChunk(segment);
            fail("Expected IndexOutOfBoundsException for negative count");
        } catch(IndexOutOfBoundsException e) {
            assertTrue(e.getMessage().contains("start 0, end -26"));
        }
    }

    @Test(timeout = 4000)
    public void appendTextChunkShouldThrowWhenSegmentOffsetInvalid()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        char[] charArray = new char[0];
        Segment segment = new Segment(charArray, 1, 1);

        try { 
            strategy.appendTextChunk(segment);
            fail("Expected ArrayIndexOutOfBoundsException for invalid offset");
        } catch(ArrayIndexOutOfBoundsException e) {
            assertEquals("1", e.getMessage());
        }
    }

    // Test text rendering after manual text appending
    @Test(timeout = 4000)
    public void renderTextAfterManualAppendShouldNotOverwrite()  {
        PdfDate pdfDate = new PdfDate();
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = graphicsState.ctm;
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = new PdfAction();
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        TextRenderInfo textInfo = new TextRenderInfo(pdfDate, graphicsState, matrix, markedContentSet);
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        
        strategy.renderText(textInfo);
        strategy.appendTextChunk("Inserting row at position ");
        strategy.renderText(textInfo);
        
        assertEquals("Inserting row at position ", strategy.getResultantText());
    }

    // Test exception when rendering after appending CharBuffer
    @Test(timeout = 4000)
    public void renderTextAfterAppendingCharBufferShouldThrow()  {
        PdfDate pdfDate = new PdfDate();
        GraphicsState graphicsState = new GraphicsState();
        Matrix matrix = graphicsState.ctm;
        LinkedHashSet<MarkedContentInfo> markedContentSet = new LinkedHashSet<>();
        PdfAction pdfAction = PdfAction.createLaunch("", "", "PDF", "");
        CMapAwareDocumentFont font = new CMapAwareDocumentFont(pdfAction);
        graphicsState.font = font;
        TextRenderInfo textInfo = new TextRenderInfo(pdfDate, graphicsState, matrix, markedContentSet);
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        CharBuffer buffer = CharBuffer.allocate(1037);
        
        strategy.appendTextChunk(buffer);

        try { 
            strategy.renderText(textInfo);
            fail("Expected NullPointerException when rendering after CharBuffer append");
        } catch(NullPointerException e) {
            // Expected due to internal state
        }
    }

    // Test lifecycle methods
    @Test(timeout = 4000)
    public void beginTextBlockShouldNotChangeResult()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        strategy.beginTextBlock();
        assertEquals("", strategy.getResultantText());
    }

    @Test(timeout = 4000)
    public void endTextBlockShouldNotChangeResult()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        strategy.endTextBlock();
        assertEquals("", strategy.getResultantText());
    }

    // Test initial state
    @Test(timeout = 4000)
    public void resultantTextShouldBeEmptyInitially()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        assertEquals("", strategy.getResultantText());
    }

    // Test image rendering has no effect
    @Test(timeout = 4000)
    public void renderImageShouldNotChangeResult()  {
        SimpleTextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
        PdfSigLockDictionary.LockPermissions permissions = 
            PdfSigLockDictionary.LockPermissions.FORM_FILLING_AND_ANNOTATION;
        PdfSigLockDictionary lockDict = new PdfSigLockDictionary(permissions);
        GraphicsState graphicsState = new GraphicsState();
        HashSet<MarkedContentInfo> contentSet = new HashSet<>();
        
        ImageRenderInfo imageInfo = ImageRenderInfo.createForXObject(
            graphicsState, null, lockDict, contentSet
        );
        
        strategy.renderImage(imageInfo);
        assertEquals("", strategy.getResultantText());
    }
}