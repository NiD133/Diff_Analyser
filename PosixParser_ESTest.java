package org.apache.commons.cli;

import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.*;

/**
 * A refactored test suite for the PosixParser class, focusing on understandability and maintainability.
 * The original tests were generated by EvoSuite and were difficult to comprehend.
 * These tests clarify the behavior of the `flatten` and `burstToken` methods.
 */
public class PosixParserTest {

    private PosixParser parser;
    private Options options;

    @Before
    public void setUp() {
        parser = new PosixParser();
        options = new Options();
    }

    // --- Tests for flatten() method ---

    @Test(expected = NullPointerException.class)
    public void flatten_shouldThrowNullPointerException_whenArgumentsArrayIsNull() throws Exception {
        // Arrange: No specific arrangement needed besides a null array.
        
        // Act: Call flatten with null arguments.
        parser.flatten(options, null, true);
        
        // Assert: Expects NullPointerException, declared in @Test annotation.
    }

    @Test
    public void flatten_shouldTreatRecognizedShortOptionAsSingleToken() throws Exception {
        // Arrange
        options.addOption("j", "java-home", true, "Java home directory");
        String[] arguments = {"-j", "/usr/lib/jvm"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        assertArrayEquals(new String[]{"-j", "/usr/lib/jvm"}, result);
    }

    @Test
    public void flatten_shouldBurstCombinedShortOptions() throws Exception {
        // Arrange
        options.addOption("a", false, "Option A");
        options.addOption("b", false, "Option B");
        String[] arguments = {"-ab"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        assertArrayEquals(new String[]{"-a", "-b"}, result);
    }

    @Test
    public void flatten_shouldStopBurstingAtFirstUnrecognizedOption() throws Exception {
        // Arrange
        options.addOption("a", false, "Option A");
        // 'c' is not a recognized option
        String[] arguments = {"-ac"};

        // Act
        // When stopAtNonOption is true, parsing stops at the first non-option token.
        String[] result = parser.flatten(options, arguments, true);

        // Assert
        // It should add "--" to signal the end of options, then the token that caused the stop.
        assertArrayEquals(new String[]{"-a", "--", "c"}, result);
    }
    
    @Test
    public void flatten_shouldSplitLongOptionWithEqualsIntoOptionAndValue() throws Exception {
        // Arrange
        options.addOption("f", "file", true, "File to process");
        String[] arguments = {"--file=report.txt"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        assertArrayEquals(new String[]{"--file", "report.txt"}, result);
    }

    @Test(expected = ParseException.class)
    public void flatten_shouldThrowException_whenLongOptionIsAmbiguous() throws Exception {
        // Arrange
        options.addOption(null, "verbose", false, "Enable verbose mode");
        options.addOption(null, "version", false, "Print version information");
        String[] arguments = {"--ver"};

        // Act
        parser.flatten(options, arguments, false);

        // Assert: Expects ParseException for ambiguous option.
    }

    @Test
    public void flatten_shouldTreatUnrecognizedLongOptionAsArgument() throws Exception {
        // Arrange
        String[] arguments = {"--unrecognized-opt"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        assertArrayEquals(new String[]{"--unrecognized-opt"}, result);
    }

    @Test
    public void flatten_shouldStopParsingAtDoubleDash() throws Exception {
        // Arrange
        options.addOption("v", false, "verbose");
        String[] arguments = {"-v", "--", "filename", "-v"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        // "--" stops option processing; subsequent arguments are treated as-is.
        assertArrayEquals(new String[]{"-v", "--", "filename", "-v"}, result);
    }

    @Test
    public void flatten_shouldTreatSingleDashAsArgument() throws Exception {
        // Arrange
        String[] arguments = {"-"};

        // Act
        String[] result = parser.flatten(options, arguments, false);

        // Assert
        assertArrayEquals(new String[]{"-"}, result);
    }

    @Test
    public void flatten_shouldStopParsingAtFirstNonOption_whenStopAtNonOptionIsTrue() throws Exception {
        // Arrange
        options.addOption("v", false, "verbose");
        String[] arguments = {"arg1", "-v", "arg2"};

        // Act
        String[] result = parser.flatten(options, arguments, true);

        // Assert
        // "arg1" is not an option, so parsing stops. "--" is not added in this case.
        assertArrayEquals(new String[]{"arg1", "-v", "arg2"}, result);
    }

    // --- Tests for burstToken() method ---
    // Note: burstToken is a protected method that relies on state initialized by flatten().
    // These tests call flatten() first to create a valid state for the parser.

    @Test(expected = NullPointerException.class)
    public void burstToken_shouldThrowNullPointerException_whenParserIsNotInitialized() {
        // Arrange: A new parser instance without calling flatten().
        PosixParser uninitializedParser = new PosixParser();

        // Act: Call burstToken on the uninitialized parser.
        uninitializedParser.burstToken("-abc", false);

        // Assert: Expects NullPointerException because internal `options` is null.
    }

    @Test
    public void burstToken_shouldDoNothing_forEmptyToken() throws Exception {
        // Arrange
        // Initialize parser state by calling flatten.
        parser.flatten(options, new String[]{}, false);

        // Act
        // This call should not throw an exception or modify state.
        parser.burstToken("", true);
        
        // Assert: No exception was thrown. No return value to check.
    }

    @Test
    public void burstToken_shouldDoNothing_forTokenNotStartingWithDash() throws Exception {
        // Arrange
        parser.flatten(options, new String[]{}, false);

        // Act
        parser.burstToken("notAnOption", true);

        // Assert: No exception was thrown.
    }
}