/*
 * This file was automatically generated by EvoSuite
 * Refactored for understandability
 */

package org.apache.commons.collections4.properties;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.Reader;
import java.io.StringReader;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.apache.commons.collections4.Equator;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.AllPredicate;
import org.apache.commons.collections4.functors.CloneTransformer;
import org.apache.commons.collections4.functors.ComparatorPredicate;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.DefaultEquator;
import org.apache.commons.collections4.functors.EqualPredicate;
import org.apache.commons.collections4.functors.ExceptionTransformer;
import org.apache.commons.collections4.functors.IfTransformer;
import org.apache.commons.collections4.functors.NOPTransformer;
import org.apache.commons.collections4.functors.NonePredicate;
import org.apache.commons.collections4.functors.NotNullPredicate;
import org.apache.commons.collections4.functors.NullIsTruePredicate;
import org.apache.commons.collections4.functors.NullPredicate;
import org.apache.commons.collections4.functors.SwitchTransformer;
import org.apache.commons.collections4.properties.OrderedProperties;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class OrderedProperties_ESTest extends OrderedProperties_ESTest_scaffolding {

    // Test Case: Removing a key-value pair when present
    @Test(timeout = 4000)
    public void testRemoveKeyValuePairWhenPresent() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer key = -1107;
        ConstantTransformer<Object, Integer> transformer = new ConstantTransformer<>(key);
        Object value = properties.computeIfAbsent(key, transformer);
        boolean removed = properties.remove(key, value);
        assertTrue("Key-value pair should be removed", removed);
    }

    // Test Case: Iterating over empty properties with BiConsumer
    @Test(timeout = 4000)
    public void testForEachOnEmptyProperties() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        BiConsumer<Object, Object> mockConsumer = mock(BiConsumer.class, new ViolatedAssumptionAnswer());
        properties.forEach(mockConsumer);
        assertTrue("Properties should be empty", properties.isEmpty());
    }

    // Test Case: putIfAbsent returns existing value when key exists
    @Test(timeout = 4000)
    public void testPutIfAbsentWhenKeyExists() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        properties.setProperty("aMWow", "aMWow");
        Object existingValue = properties.putIfAbsent("aMWow", "aMWow");
        assertEquals("Existing value should be returned", "aMWow", existingValue);
    }

    // Test Case: Merging with null value
    @Test(timeout = 4000)
    public void testMergeWithNullValue() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        BiFunction<Object, Object, Integer> mockFunction = mock(BiFunction.class, new ViolatedAssumptionAnswer());
        Object result = properties.merge(properties, null, mockFunction);
        assertNull("Result should be null", result);
        assertTrue("Properties should be empty", properties.isEmpty());
    }

    // Test Case: KeySet contains added key
    @Test(timeout = 4000)
    public void testKeySetContainsAddedKey() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer key = 61;
        properties.put(key, key);
        Set<Object> keySet = properties.keySet();
        assertTrue("KeySet should contain added key", keySet.contains(key));
    }

    // Test Case: Loading properties from reader populates entry set
    @Test(timeout = 4000)
    public void testLoadFromReaderPopulatesEntrySet() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        StringReader reader = new StringReader("N\"e,'{*4`uWJGD{G");
        properties.load(reader);
        Set<Map.Entry<Object, Object>> entrySet = properties.entrySet();
        assertFalse("Entry set should not be empty", entrySet.isEmpty());
    }

    // Test Case: Cloning and modifying properties causes exception on toString
    @Test(timeout = 4000)
    public void testCloneModifyThenToStringThrowsException() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        HashMap<Integer, Integer> map = new HashMap<>();
        Integer key = 0;
        properties.putIfAbsent(key, map);
        Object clone = properties.clone();
        properties.remove(key);
        try {
            clone.toString();
            fail("Expected NoSuchElementException");
        } catch (NoSuchElementException e) {
            // Expected due to underlying iterator
        }
    }

    // Test Case: Self-referential key causes StackOverflowError in toString
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesStackOverflowInToString() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        properties.putIfAbsent(keySet, keySet);
        try {
            properties.toString();
            fail("Expected StackOverflowError");
        } catch (StackOverflowError e) {
            // Expected due to recursive call
        }
    }

    // Test Case: Self-referential key causes NullPointerException in toString
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesNPEInToString() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        properties.put(properties, properties);
        properties.setProperty("R8_.+(qv;A*", "");
        try {
            properties.toString();
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected in test environment
        }
    }

    // Test Case: Removing null key throws NullPointerException
    @Test(timeout = 4000)
    public void testRemoveNullKeyThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.remove(null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: Removing null key without value throws NullPointerException
    @Test(timeout = 4000)
    public void testRemoveNullKeyWithoutValueThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.remove(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Hashtable
        }
    }

    // Test Case: putIfAbsent with null key throws NullPointerException
    @Test(timeout = 4000)
    public void testPutIfAbsentWithNullKeyThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.putIfAbsent(null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: putAll with null map throws NullPointerException
    @Test(timeout = 4000)
    public void testPutAllWithNullMapThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.putAll(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from OrderedProperties
        }
    }

    // Test Case: Self-referential key causes StackOverflowError on put
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesStackOverflowOnPut() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        Set<Map.Entry<Object, Object>> entrySet = properties.entrySet();
        properties.putIfAbsent(keySet, keySet);
        Comparator<Object> mockComparator = mock(Comparator.class, new ViolatedAssumptionAnswer());
        ComparatorPredicate.Criterion criterion = ComparatorPredicate.Criterion.LESS;
        ComparatorPredicate<Object> predicate = new ComparatorPredicate<>(entrySet, mockComparator, criterion);
        try {
            properties.put(keySet, predicate);
            fail("Expected StackOverflowError");
        } catch (StackOverflowError e) {
            // Expected due to recursive call
        }
    }

    // Test Case: Put with null key throws NullPointerException
    @Test(timeout = 4000)
    public void testPutWithNullKeyThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.put(null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Hashtable
        }
    }

    // Test Case: Self-referential key causes StackOverflowError on merge
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesStackOverflowOnMerge() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        DefaultEquator<Object> equator = DefaultEquator.defaultEquator();
        Predicate<Object> predicate = EqualPredicate.equalPredicate(keySet, equator);
        BiFunction<Object, Object, Integer> mockFunction = mock(BiFunction.class, new ViolatedAssumptionAnswer());
        try {
            properties.merge(keySet, predicate, mockFunction);
            fail("Expected StackOverflowError");
        } catch (StackOverflowError e) {
            // Expected due to recursive call
        }
    }

    // Test Case: Merge with null function throws NullPointerException
    @Test(timeout = 4000)
    public void testMergeWithNullFunctionThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        try {
            properties.merge(keySet, keySet, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: Self-referential key causes StackOverflowError on forEach
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesStackOverflowOnForEach() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        properties.putIfAbsent(keySet, keySet);
        BiConsumer<Object, Object> mockConsumer = mock(BiConsumer.class, new ViolatedAssumptionAnswer());
        try {
            properties.forEach(mockConsumer);
            fail("Expected StackOverflowError");
        } catch (StackOverflowError e) {
            // Expected due to recursive call
        }
    }

    // Test Case: computeIfAbsent with exception transformer throws RuntimeException
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithExceptionTransformerThrowsRuntimeException() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Transformer<Object, Integer> exceptionTransformer = ExceptionTransformer.exceptionTransformer();
        try {
            properties.computeIfAbsent("{}", exceptionTransformer);
            fail("Expected RuntimeException");
        } catch (RuntimeException e) {
            assertEquals("Exception message", "ExceptionTransformer invoked", e.getMessage());
        }
    }

    // Test Case: computeIfAbsent with conditional transformer
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithConditionalTransformer() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer key = 95;
        Predicate<Object>[] predicates = (Predicate<Object>[]) Array.newInstance(Predicate.class, 5);
        Predicate<Object> nullPredicate = NullPredicate.nullPredicate();
        predicates[0] = nullPredicate;
        NonePredicate<Object> nonePredicate = new NonePredicate<>(predicates);
        predicates[1] = nonePredicate;
        predicates[4] = predicates[1];
        IfTransformer<Object, Integer> ifTransformer = new IfTransformer<>(predicates[4], null, null);
        // Expected to throw exception due to null transformer
        properties.computeIfAbsent(key, ifTransformer);
    }

    // Test Case: computeIfAbsent with null function throws NullPointerException
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithNullFunctionThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.computeIfAbsent(null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: computeIfAbsent with switch transformer throws ArrayIndexOutOfBoundsException
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithSwitchTransformerThrowsException() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        LinkedHashSet<Predicate<Object>> predicateSet = new LinkedHashSet<>();
        Predicate<Object> predicate = AllPredicate.allPredicate(predicateSet);
        NullIsTruePredicate<Object> nullIsTruePredicate = new NullIsTruePredicate<>(predicate);
        Predicate<Object>[] predicates = (Predicate<Object>[]) Array.newInstance(Predicate.class, 9);
        predicates[0] = nullIsTruePredicate;
        Transformer<Object, Integer>[] transformers = (Transformer<Object, Integer>[]) Array.newInstance(Transformer.class, 0);
        Transformer<Object, Integer> nullTransformer = ConstantTransformer.nullTransformer();
        SwitchTransformer<Object, Integer> switchTransformer = new SwitchTransformer<>(predicates, transformers, nullTransformer);
        try {
            properties.computeIfAbsent(predicate, switchTransformer);
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            assertEquals("Index", 0, e.getMessage());
        }
    }

    // Test Case: Compute with null function throws NullPointerException
    @Test(timeout = 4000)
    public void testComputeWithNullFunctionThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.compute(new Object(), null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: computeIfAbsent with NOP transformer returns empty set
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithNopTransformer() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Map.Entry<Object, Object>> entrySet = properties.entrySet();
        Transformer<Object, Object> nopTransformer = NOPTransformer.nopTransformer();
        LinkedHashSet<?> result = (LinkedHashSet<?>) properties.computeIfAbsent(entrySet, nopTransformer);
        assertEquals("Result should be empty", 0, result.size());
    }

    // Test Case: toString with non-empty properties returns non-null string
    @Test(timeout = 4000)
    public void testToStringWithNonEmptyProperties() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        HashMap<Integer, Integer> map = new HashMap<>();
        Integer key = 0;
        properties.putIfAbsent(key, map);
        Object anotherKey = new Object();
        properties.putIfAbsent(anotherKey, anotherKey);
        String result = properties.toString();
        assertNotNull("Result should not be null", result);
    }

    // Test Case: toString on empty properties returns empty representation
    @Test(timeout = 4000)
    public void testToStringOnEmptyProperties() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        String result = properties.toString();
        assertEquals("Empty properties string", "{}", result);
    }

    // Test Case: Remove non-existent key-value pair returns false
    @Test(timeout = 4000)
    public void testRemoveNonExistentKeyValuePair() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer key = 0;
        boolean result = properties.remove(key, properties);
        assertFalse("Remove should fail", result);
    }

    // Test Case: Remove non-existent key returns null
    @Test(timeout = 4000)
    public void testRemoveNonExistentKey() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer key = -1;
        Object result = properties.remove(key);
        assertNull("Result should be null", result);
    }

    // Test Case: Put returns previous value
    @Test(timeout = 4000)
    public void testPutReturnsPreviousValue() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        properties.setProperty("^H@/z9H|#X@Pm", "^H@/z9H|#X@Pm");
        Object result = properties.put("^H@/z9H|#X@Pm", "^H@/z9H|#X@Pm");
        assertEquals("Previous value", "^H@/z9H|#X@Pm", result);
    }

    // Test Case: computeIfAbsent with constant transformer returns value
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithConstantTransformer() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        HashMap<Integer, Integer> map = new HashMap<>();
        Integer constantValue = 0;
        ConstantTransformer<Object, Integer> constantTransformer = new ConstantTransformer<>(constantValue);
        Object result = properties.computeIfAbsent(map, constantTransformer);
        assertEquals("Constant value", constantValue, result);
    }

    // Test Case: computeIfAbsent with null transformer returns null
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithNullTransformer() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Predicate<Integer> key = NotNullPredicate.notNullPredicate();
        Transformer<Object, Integer> nullTransformer = ConstantTransformer.nullTransformer();
        Object result = properties.computeIfAbsent(key, nullTransformer);
        assertNull("Result should be null", result);
    }

    // Test Case: Compute with mock function returns new value
    @Test(timeout = 4000)
    public void testComputeWithMockFunctionReturnsNewValue() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Enumeration<?> propertyNames = properties.propertyNames();
        BiFunction<Object, Object, Object> mockFunction = mock(BiFunction.class);
        when(mockFunction.apply(any(), any())).thenReturn(properties);
        OrderedProperties result = (OrderedProperties) properties.compute(propertyNames, mockFunction);
        assertEquals("Size after compute", 1, result.size());
    }

    // Test Case: Compute with mock function returning null removes mapping
    @Test(timeout = 4000)
    public void testComputeWithMockFunctionReturnsNull() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Enumeration<?> propertyNames = properties.propertyNames();
        BiFunction<Object, Object, Object> mockFunction = mock(BiFunction.class);
        when(mockFunction.apply(any(), any())).thenReturn(null);
        Object result = properties.compute(propertyNames, mockFunction);
        assertNull("Result should be null", result);
    }

    // Test Case: putAll with empty map leaves properties empty
    @Test(timeout = 4000)
    public void testPutAllWithEmptyMap() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        HashMap<Integer, Integer> emptyMap = new HashMap<>();
        properties.putAll(emptyMap);
        assertTrue("Properties should be empty", properties.isEmpty());
    }

    // Test Case: Merge with constant transformer returns value
    @Test(timeout = 4000)
    public void testMergeWithConstantTransformer() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Integer constantValue = -1107;
        ConstantTransformer<Object, Integer> constantTransformer = new ConstantTransformer<>(constantValue);
        BiFunction<Object, Object, Object> mockFunction = mock(BiFunction.class);
        Object result = properties.merge(Integer.class, constantTransformer, mockFunction);
        assertNotNull("Result should not be null", result);
    }

    // Test Case: Clear empties properties
    @Test(timeout = 4000)
    public void testClearEmptiesProperties() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        properties.clear();
        assertTrue("Properties should be empty", properties.isEmpty());
    }

    // Test Case: Self-referential key causes StackOverflowError on compute
    @Test(timeout = 4000)
    public void testSelfReferentialKeyCausesStackOverflowOnCompute() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Set<Object> keySet = properties.keySet();
        properties.put(keySet, keySet);
        BiFunction<Object, Object, Object> mockFunction = mock(BiFunction.class);
        try {
            properties.compute(properties, mockFunction);
            fail("Expected StackOverflowError");
        } catch (StackOverflowError e) {
            // Expected due to recursive call
        }
    }

    // Test Case: computeIfAbsent with clone transformer throws exception
    @Test(timeout = 4000)
    public void testComputeIfAbsentWithCloneTransformerThrowsException() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Enumeration<Object> keys = properties.keys();
        Transformer<Object, Object> cloneTransformer = CloneTransformer.cloneTransformer();
        try {
            properties.computeIfAbsent(keys, cloneTransformer);
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Exception message", "The prototype must be cloneable via a public clone method", e.getMessage());
        }
    }

    // Test Case: forEach with null consumer throws NullPointerException
    @Test(timeout = 4000)
    public void testForEachWithNullConsumerThrowsNPE() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        try {
            properties.forEach(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected from Objects.requireNonNull
        }
    }

    // Test Case: toString with self-referential mapping
    @Test(timeout = 4000)
    public void testToStringWithSelfReferentialMapping() throws Throwable {
        OrderedProperties properties = new OrderedProperties();
        Object previousValue = properties.put(properties, properties);
        assertNull("Previous value should be null", previousValue);
        String result = properties.toString();
        assertEquals("String representation", "{(this Map)=(this Map)}", result);
    }
}