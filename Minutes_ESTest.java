/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 19 14:18:34 GMT 2025
 */

package org.joda.time;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTimeFieldType;
import org.joda.time.Days;
import org.joda.time.Duration;
import org.joda.time.DurationFieldType;
import org.joda.time.Hours;
import org.joda.time.Instant;
import org.joda.time.Minutes;
import org.joda.time.Partial;
import org.joda.time.PeriodType;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadableInterval;
import org.joda.time.ReadablePartial;
import org.joda.time.ReadablePeriod;
import org.joda.time.Seconds;
import org.joda.time.Weeks;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Minutes_ESTest extends Minutes_ESTest_scaffolding {

    // Comparison Tests: isLessThan()
    @Test(timeout = 4000)
    public void testIsLessThanWhenMaxValueComparedWithSmallerValue() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes maxMinutes = Minutes.MAX_VALUE;
        assertFalse(maxMinutes.isLessThan(twoMinutes));
    }

    @Test(timeout = 4000)
    public void testIsLessThanWhenZeroComparedWithNull() {
        Minutes zeroMinutes = Minutes.ZERO;
        assertFalse(zeroMinutes.isLessThan(null));
    }

    @Test(timeout = 4000)
    public void testIsLessThanWhenMinValueComparedWithNull() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        assertTrue(minMinutes.isLessThan(null));
    }

    @Test(timeout = 4000)
    public void testIsLessThanWhenValueComparedWithSameValue() {
        Minutes minutes = Minutes.minutes(31);
        assertFalse(minutes.isLessThan(minutes));
    }

    @Test(timeout = 4000)
    public void testIsLessThanWhenSmallerComparedWithLarger() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes thirtyOneMinutes = Minutes.minutes(31);
        assertTrue(twoMinutes.isLessThan(thirtyOneMinutes));
    }

    // Comparison Tests: isGreaterThan()
    @Test(timeout = 4000)
    public void testIsGreaterThanWhenTwoComparedWithThree() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes threeMinutes = Minutes.THREE;
        assertFalse(twoMinutes.isGreaterThan(threeMinutes));
    }

    @Test(timeout = 4000)
    public void testIsGreaterThanWhenZeroComparedWithNull() {
        Minutes zeroMinutes = Minutes.ZERO;
        assertFalse(zeroMinutes.isGreaterThan(null));
    }

    @Test(timeout = 4000)
    public void testIsGreaterThanWhenPositiveValueComparedWithNull() {
        Minutes minutes = Minutes.minutes(1431);
        assertTrue(minutes.isGreaterThan(null));
    }

    @Test(timeout = 4000)
    public void testIsGreaterThanWhenTwoComparedWithZero() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes zeroMinutes = Minutes.ZERO;
        assertTrue(twoMinutes.isGreaterThan(zeroMinutes));
    }

    @Test(timeout = 4000)
    public void testIsGreaterThanWhenValueComparedWithItself() {
        Minutes oneMinute = Minutes.ONE;
        assertFalse(oneMinute.isGreaterThan(oneMinute));
    }

    // Conversion Tests: toStandardWeeks()
    @Test(timeout = 4000)
    public void testToStandardWeeksForMaxValue() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        Weeks weeks = maxMinutes.toStandardWeeks();
        assertEquals(213044, weeks.getWeeks());
    }

    @Test(timeout = 4000)
    public void testToStandardWeeksForMinValue() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        Weeks weeks = minMinutes.toStandardWeeks();
        assertEquals(-213044, weeks.getWeeks());
    }

    // Conversion Tests: toStandardSeconds()
    @Test(timeout = 4000)
    public void testToStandardSecondsForZero() {
        Minutes zeroMinutes = Minutes.ZERO;
        Seconds seconds = zeroMinutes.toStandardSeconds();
        assertEquals(0, seconds.getSeconds());
    }

    @Test(timeout = 4000)
    public void testToStandardSecondsForOne() {
        Minutes oneMinute = Minutes.ONE;
        Seconds seconds = oneMinute.toStandardSeconds();
        assertEquals(60, seconds.getSeconds());
    }

    @Test(timeout = 4000)
    public void testToStandardSecondsForMinValueThrowsException() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        try {
            minMinutes.toStandardSeconds();
            fail("Expected ArithmeticException for overflow");
        } catch (ArithmeticException e) {
            // Multiplication overflows an int: -2147483648 * 60
        }
    }

    // Conversion Tests: toStandardHours()
    @Test(timeout = 4000)
    public void testToStandardHours() {
        Minutes minutes = Minutes.minutes(1431);
        Hours hours = minutes.toStandardHours();
        assertEquals(23, hours.getHours());
    }

    @Test(timeout = 4000)
    public void testToStandardHoursForMinValue() {
        Minutes minMinutes = Minutes.minutes(Integer.MIN_VALUE);
        Hours hours = minMinutes.toStandardHours();
        assertEquals(-35791394, hours.getHours());
    }

    // Conversion Tests: toStandardDuration()
    @Test(timeout = 4000)
    public void testToStandardDurationForMaxValue() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        Duration duration = maxMinutes.toStandardDuration();
        assertEquals(1491308L, duration.getStandardDays());
    }

    @Test(timeout = 4000)
    public void testToStandardDurationForOne() {
        Minutes oneMinute = Minutes.ONE;
        Duration duration = oneMinute.toStandardDuration();
        assertEquals(60000L, duration.getMillis());
    }

    @Test(timeout = 4000)
    public void testToStandardDurationForMinValue() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        Duration duration = minMinutes.toStandardDuration();
        assertEquals(-2147483648L, duration.getStandardMinutes());
    }

    // Arithmetic Tests: plus()
    @Test(timeout = 4000)
    public void testPlusMinutesWithNull() {
        Minutes zeroMinutes = Minutes.ZERO;
        Minutes result = zeroMinutes.plus((Minutes) null);
        assertSame(zeroMinutes, result);
    }

    @Test(timeout = 4000)
    public void testPlusMinutes() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes result = twoMinutes.plus(-2);
        assertEquals(0, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testPlusValue() {
        Minutes zeroMinutes = Minutes.ZERO;
        Minutes result = zeroMinutes.plus(-2104);
        assertEquals(-2104, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testPlusWhenResultIsZero() {
        Minutes oneMinute = Minutes.ONE;
        Minutes zeroMinutes = Minutes.minutes(0);
        Minutes result = oneMinute.minus(oneMinute);
        assertEquals(0, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testPlusMaxValueThrowsException() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        try {
            maxMinutes.plus(Integer.MAX_VALUE);
            fail("Expected ArithmeticException for overflow");
        } catch (ArithmeticException e) {
            // The calculation caused an overflow: 2147483647 + 2147483647
        }
    }

    // Arithmetic Tests: minus()
    @Test(timeout = 4000)
    public void testMinusMinutesWithNull() {
        Minutes zeroMinutes = Minutes.ZERO;
        Minutes result = zeroMinutes.minus((Minutes) null);
        assertSame(zeroMinutes, result);
    }

    @Test(timeout = 4000)
    public void testMinusMinutes() {
        Minutes twoMinutes = Minutes.TWO;
        Minutes threeMinutes = Minutes.THREE;
        Minutes result = twoMinutes.minus(threeMinutes);
        assertEquals(-1, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinusValue() {
        Minutes oneMinute = Minutes.ONE;
        Minutes result = oneMinute.minus(-241);
        assertEquals(242, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinusMinValueThrowsException() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        try {
            minMinutes.minus(minMinutes);
            fail("Expected ArithmeticException for overflow");
        } catch (ArithmeticException e) {
            // Integer.MIN_VALUE cannot be negated
        }
    }

    // Arithmetic Tests: multipliedBy()
    @Test(timeout = 4000)
    public void testMultipliedByForZero() {
        Minutes zeroMinutes = Minutes.minutesIn(null);
        Minutes result = zeroMinutes.multipliedBy(1995);
        assertEquals(0, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMultipliedByPositive() {
        Minutes minutes = Minutes.minutes(1431);
        Minutes result = minutes.multipliedBy(3012);
        assertEquals(4310172, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMultipliedByNegative() {
        Minutes oneMinute = Minutes.ONE;
        Minutes result = oneMinute.multipliedBy(-5447);
        assertEquals(-5447, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMultipliedByMaxValueThrowsException() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        try {
            maxMinutes.multipliedBy(-4433);
            fail("Expected ArithmeticException for overflow");
        } catch (ArithmeticException e) {
            // Multiplication overflows an int: 2147483647 * -4433
        }
    }

    // Arithmetic Tests: dividedBy()
    @Test(timeout = 4000)
    public void testDividedBy() {
        Minutes threeMinutes = Minutes.THREE;
        Minutes result = threeMinutes.dividedBy(2);
        assertEquals(1, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testDividedByForZero() {
        Minutes zeroMinutes = Minutes.ZERO;
        Minutes result = zeroMinutes.dividedBy(1);
        assertSame(zeroMinutes, result);
    }

    @Test(timeout = 4000)
    public void testDividedByByZeroThrowsException() {
        Minutes minutes = Minutes.minutesIn(null);
        try {
            minutes.dividedBy(0);
            fail("Expected ArithmeticException for division by zero");
        } catch (ArithmeticException e) {
            // / by zero
        }
    }

    // Arithmetic Tests: negated()
    @Test(timeout = 4000)
    public void testNegatedForZero() {
        Minutes zeroMinutes = Minutes.minutesIn(null);
        Minutes result = zeroMinutes.negated();
        assertEquals(0, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testNegated() {
        Minutes threeMinutes = Minutes.THREE;
        Minutes result = threeMinutes.negated();
        assertEquals(-3, result.getMinutes());
    }

    @Test(timeout = 4000)
    public void testNegatedMinValueThrowsException() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        try {
            minMinutes.negated();
            fail("Expected ArithmeticException for overflow");
        } catch (ArithmeticException e) {
            // Integer.MIN_VALUE cannot be negated
        }
    }

    // Factory Tests: minutesIn()
    @Test(timeout = 4000)
    public void testMinutesInWithNullInterval() {
        Minutes minutes = Minutes.minutesIn(null);
        assertEquals(0, minutes.getMinutes());
    }

    // Factory Tests: minutesBetween()
    @Test(timeout = 4000)
    public void testMinutesBetweenSameInstants() {
        Instant instant = Instant.now();
        Minutes minutes = Minutes.minutesBetween(instant, instant);
        assertEquals(0, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinutesBetweenSamePartials() {
        DateTimeFieldType[] types = { DateTimeFieldType.year() };
        int[] values = { 2023 };
        Partial partial = new Partial(types, values);
        Minutes minutes = Minutes.minutesBetween(partial, partial);
        assertEquals(0, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinutesBetweenNullPartialsThrowsException() {
        try {
            Minutes.minutesBetween((ReadablePartial) null, (ReadablePartial) null);
            fail("Expected IllegalArgumentException for null partials");
        } catch (IllegalArgumentException e) {
            // ReadablePartial objects must not be null
        }
    }

    @Test(timeout = 4000)
    public void testMinutesBetweenNullInstantsThrowsException() {
        try {
            Minutes.minutesBetween((ReadableInstant) null, (ReadableInstant) null);
            fail("Expected IllegalArgumentException for null instants");
        } catch (IllegalArgumentException e) {
            // ReadableInstant objects must not be null
        }
    }

    // Factory Tests: minutes()
    @Test(timeout = 4000)
    public void testMinutes() {
        Minutes minutes = Minutes.minutes(3);
        assertEquals(3, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinutesMaxValue() {
        Minutes minutes = Minutes.minutes(Integer.MAX_VALUE);
        assertEquals(Integer.MAX_VALUE, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testMinutesMinValue() {
        Minutes minutes = Minutes.minutes(Integer.MIN_VALUE);
        assertEquals(Integer.MIN_VALUE, minutes.getMinutes());
    }

    // Getter Tests
    @Test(timeout = 4000)
    public void testGetMinutesForZero() {
        Minutes zeroMinutes = Minutes.minutesIn(null);
        assertEquals(0, zeroMinutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testGetMinutesForMaxValue() {
        Seconds seconds = Seconds.MAX_VALUE;
        Minutes minutes = seconds.toStandardMinutes();
        assertEquals(35791394, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testGetMinutesForMinValue() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        assertEquals(Integer.MIN_VALUE, minMinutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testGetFieldType() {
        Minutes minMinutes = Minutes.MIN_VALUE;
        assertEquals("minutes", minMinutes.getFieldType().toString());
    }

    @Test(timeout = 4000)
    public void testGetPeriodType() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        assertEquals(1, maxMinutes.getPeriodType().size());
    }

    // Conversion Tests: toStandardDays()
    @Test(timeout = 4000)
    public void testToStandardDaysForMaxValue() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        Days days = maxMinutes.toStandardDays();
        assertEquals(1491308, days.getDays());
    }

    @Test(timeout = 4000)
    public void testToStandardDaysForZero() {
        Minutes zeroMinutes = Minutes.ZERO;
        Days days = zeroMinutes.toStandardDays();
        assertEquals(0, days.getDays());
    }

    // toString() Tests
    @Test(timeout = 4000)
    public void testToString() {
        Minutes maxMinutes = Minutes.MAX_VALUE;
        assertEquals("PT2147483647M", maxMinutes.toString());
    }

    // parseMinutes() Tests
    @Test(timeout = 4000)
    public void testParseMinutesNull() {
        Minutes minutes = Minutes.parseMinutes(null);
        assertEquals(0, minutes.getMinutes());
    }

    @Test(timeout = 4000)
    public void testParseMinutesInvalidFormat() {
        try {
            Minutes.parseMinutes("UT");
            fail("Expected IllegalArgumentException for invalid format");
        } catch (IllegalArgumentException e) {
            // Invalid format: "UT"
        }
    }

    // standardMinutesIn() Tests
    @Test(timeout = 4000)
    public void testStandardMinutesInNullPeriod() {
        Minutes minutes = Minutes.standardMinutesIn(null);
        assertEquals(0, minutes.getMinutes());
    }
}