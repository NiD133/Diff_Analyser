package org.apache.commons.jxpath.ri.compiler;

import org.junit.Test;
import static org.junit.Assert.assertThrows;

/**
 * This test class focuses on edge cases for CoreOperation evaluation.
 * Note: The original class name 'CoreOperation_ESTestTest6' was generated by a tool.
 * A more descriptive name like 'CoreOperationRecursiveEvaluationTest' would be preferable.
 */
public class CoreOperation_ESTestTest6 {

    /**
     * Tests that evaluating an expression that recursively contains itself as an
     * argument causes a StackOverflowError.
     *
     * This scenario can occur if an expression tree is constructed incorrectly.
     * The test ensures that such a recursive evaluation doesn't lead to an
     * unhandled infinite loop, but instead fails predictably with a StackOverflowError.
     */
    @Test
    public void computeValueWithRecursiveExpressionShouldThrowStackOverflowError() {
        // Arrange: Create a recursive expression structure.
        // The goal is to build: subtract(and(self, null), null)
        // where 'self' refers to the 'and' operation itself.

        // 1. Define the operands for an 'and' operation.
        Expression[] andOperands = new Expression[2]; // Initially [null, null]
        CoreOperationAnd recursiveAndOperation = new CoreOperationAnd(andOperands);

        // 2. Create the recursion by setting the first operand of the 'and'
        // operation to be the operation itself.
        andOperands[0] = recursiveAndOperation;

        // 3. Create a parent 'subtract' operation that uses the recursive 'and'
        // operation as its first argument. The second argument remains null.
        CoreOperation subtractOperation = new CoreOperationSubtract(recursiveAndOperation, andOperands[1]);

        // Act & Assert:
        // Attempting to compute the value of the subtract operation will trigger
        // the infinite recursion within the 'and' operation. We expect this to
        // fail with a StackOverflowError.
        assertThrows(StackOverflowError.class, () -> {
            // The EvalContext can be null because the stack overflow occurs before
            // the context is ever accessed during the recursive calls.
            subtractOperation.computeValue(null);
        });
    }
}