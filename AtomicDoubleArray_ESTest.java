/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 18:59:41 GMT 2025
 */

package com.google.common.util.concurrent;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.util.concurrent.AtomicDoubleArray;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleUnaryOperator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AtomicDoubleArray_ESTest extends AtomicDoubleArray_ESTest_scaffolding {

    // Identity operator for reuse in multiple tests
    private static final DoubleUnaryOperator identityOperator = DoubleUnaryOperator.identity();

    // Tests for basic operations: constructor, length, get, set
    @Test(timeout = 4000)
    public void length_returnsCorrectSize() {
        AtomicDoubleArray array = new AtomicDoubleArray(1027);
        assertEquals(1027, array.length());
    }

    @Test(timeout = 4000)
    public void length_emptyArray_returnsZero() {
        double[] empty = new double[0];
        AtomicDoubleArray array = new AtomicDoubleArray(empty);
        assertEquals(0, array.length());
    }

    @Test(timeout = 4000)
    public void get_initialValue_returnsZero() {
        AtomicDoubleArray array = new AtomicDoubleArray(10);
        assertEquals(0.0, array.get(5), 0.01);
    }

    @Test(timeout = 4000)
    public void set_updatesValueCorrectly() {
        double[] initial = new double[8];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        array.set(2, 2358.26006);
        assertEquals(2358.26006, array.get(2), 0.01);
    }

    @Test(timeout = 4000)
    public void lazySet_updatesValue() {
        double[] initial = new double[8];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        array.lazySet(0, 0.0);
        assertEquals(0.0, array.get(0), 0.01);
    }

    // Tests for compare-and-set operations
    @Test(timeout = 4000)
    public void compareAndSet_successWhenExpectedValueMatches() {
        AtomicDoubleArray array = new AtomicDoubleArray(1027);
        boolean result = array.compareAndSet(1025, 0.0, 1027);
        assertTrue(result);
        assertEquals(1027.0, array.get(1025), 0.01);
    }

    @Test(timeout = 4000)
    public void compareAndSet_failsWhenExpectedValueDiffers() {
        double[] initial = { -1583.803774 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        boolean result = array.compareAndSet(0, 0.0, 690.74034879);
        assertFalse(result);
        assertEquals(-1583.803774, array.get(0), 0.01);
    }

    @Test(timeout = 4000)
    public void weakCompareAndSet_succeedsWhenValueMatches() {
        double[] initial = new double[9];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        boolean result = array.weakCompareAndSet(0, 0.0, -1.0);
        assertTrue(result);
        assertEquals(-1.0, array.get(0), 0.01);
    }

    // Tests for getAndSet
    @Test(timeout = 4000)
    public void getAndSet_returnsPreviousValue() {
        double[] initial = { 0, 540.0 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double prev = array.getAndSet(1, 2806.574374631918);
        assertEquals(540.0, prev, 0.01);
        assertEquals(2806.574374631918, array.get(1), 0.01);
    }

    @Test(timeout = 4000)
    public void getAndSet_updatesValue() {
        double[] initial = { -1583.803774 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double prev = array.getAndSet(0, -1710.836556);
        assertEquals(-1583.803774, prev, 0.01);
        assertEquals(-1710.836556, array.get(0), 0.01);
    }

    // Tests for addition operations
    @Test(timeout = 4000)
    public void getAndAdd_returnsPreviousValueAndUpdates() {
        double[] initial = new double[12];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double prev = array.getAndAdd(4, 4.0);
        assertEquals(0.0, prev, 0.01);
        assertEquals(4.0, array.get(4), 0.01);
    }

    @Test(timeout = 4000)
    public void addAndGet_returnsUpdatedValue() {
        double[] initial = new double[8];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double updated = array.addAndGet(0, 1775.31884);
        assertEquals(1775.31884, updated, 0.01);
        assertEquals(1775.31884, array.get(0), 0.01);
    }

    @Test(timeout = 4000)
    public void addAndGet_withNegativeIncrement_updatesCorrectly() {
        double[] initial = { -970.960157577528 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double updated = array.addAndGet(0, 0.0);
        assertEquals(-970.960157577528, updated, 0.01);
    }

    // Tests for update operations (getAndUpdate, updateAndGet)
    @Test(timeout = 4000)
    public void getAndUpdate_returnsPreviousValue() {
        double[] initial = { -1583.803774 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        double prev = array.getAndUpdate(0, identityOperator);
        assertEquals(-1583.803774, prev, 0.01);
    }

    @Test(timeout = 4000)
    public void updateAndGet_appliesOperator() {
        double[] initial = new double[12];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        array.getAndAdd(4, 4.0); // Set to 4.0
        double result = array.updateAndGet(4, identityOperator);
        assertEquals(4.0, result, 0.01);
    }

    @Test(timeout = 4000)
    public void updateAndGet_afterAdd_appliesIdentityCorrectly() {
        AtomicDoubleArray array = new AtomicDoubleArray(993);
        array.getAndAdd(75, -692.410613387175);
        double result = array.updateAndGet(75, identityOperator);
        assertEquals(-692.410613387175, result, 0.01);
    }

    // Tests for accumulate operations
    @Test(timeout = 4000)
    public void getAndAccumulate_returnsPreviousValue() {
        double[] initial = { 354.258 };
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        DoubleBinaryOperator mockOperator = mock(DoubleBinaryOperator.class);
        when(mockOperator.applyAsDouble(anyDouble(), anyDouble())).thenReturn(-1.0);

        double prev = array.getAndAccumulate(1, -2032.2, mockOperator);
        assertEquals(354.258, prev, 0.01);
        assertEquals(-1.0, array.get(1), 0.01);
    }

    @Test(timeout = 4000)
    public void accumulateAndGet_appliesOperator() {
        double[] initial = new double[9];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        DoubleBinaryOperator mockOperator = mock(DoubleBinaryOperator.class);
        when(mockOperator.applyAsDouble(anyDouble(), anyDouble())).thenReturn(1.0);

        double result = array.accumulateAndGet(0, 0.0, mockOperator);
        assertEquals(1.0, result, 0.01);
    }

    @Test(timeout = 4000)
    public void accumulateAndGet_withCustomOperator_updatesValue() {
        AtomicDoubleArray array = new AtomicDoubleArray(3740);
        DoubleBinaryOperator mockOperator = mock(DoubleBinaryOperator.class);
        when(mockOperator.applyAsDouble(anyDouble(), anyDouble())).thenReturn(-1.0);

        double result = array.accumulateAndGet(67, 3740.0, mockOperator);
        assertEquals(-1.0, result, 0.01);
    }

    // Tests for toString
    @Test(timeout = 4000)
    public void toString_emptyArray_returnsEmptyBrackets() {
        double[] initial = new double[0];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        assertEquals("[]", array.toString());
    }

    // Negative tests for exceptions
    @Test(timeout = 4000, expected = IndexOutOfBoundsException.class)
    public void weakCompareAndSet_invalidIndex_throwsException() {
        AtomicDoubleArray array = new AtomicDoubleArray(93);
        array.weakCompareAndSet(93, 93, 93);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void updateAndGet_nullOperator_throwsException() {
        AtomicDoubleArray array = new AtomicDoubleArray(1109);
        array.updateAndGet(156, null);
    }

    @Test(timeout = 4000)
    public void getAndSet_invalidIndex_throwsException() {
        AtomicDoubleArray array = new AtomicDoubleArray(3);
        try {
            array.getAndSet(3, 3.0);
            fail("Expected IndexOutOfBoundsException");
        } catch (IndexOutOfBoundsException e) {
            assertTrue(e.getMessage().contains("index 3"));
        }
    }

    @Test(timeout = 4000)
    public void getAndAccumulate_nullOperator_throwsException() {
        AtomicDoubleArray array = new AtomicDoubleArray(3);
        try {
            array.getAndAccumulate(3, 3.0, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void constructor_nullArray_throwsException() {
        try {
            new AtomicDoubleArray((double[]) null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void constructor_negativeLength_throwsException() {
        try {
            new AtomicDoubleArray(-1);
            fail("Expected NegativeArraySizeException");
        } catch (NegativeArraySizeException e) {
            // Expected
        }
    }

    // Additional edge cases
    @Test(timeout = 4000)
    public void addAndGet_thenGet_returnsUpdatedValue() {
        double[] initial = new double[8];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        array.addAndGet(0, 1775.31884);
        double value = array.get(0);
        assertEquals(1775.31884, value, 0.01);
    }

    @Test(timeout = 4000)
    public void getAndAccumulate_afterAdd_returnsCorrectValue() {
        double[] initial = new double[8];
        AtomicDoubleArray array = new AtomicDoubleArray(initial);
        DoubleBinaryOperator mockOperator = mock(DoubleBinaryOperator.class);
        when(mockOperator.applyAsDouble(anyDouble(), anyDouble())).thenReturn(-1.0);

        array.getAndAccumulate(0, 1303.997034846174, mockOperator);
        boolean result = array.compareAndSet(0, 0.0, 0.0); // Should fail because value is now -1.0
        assertFalse(result);
    }
}