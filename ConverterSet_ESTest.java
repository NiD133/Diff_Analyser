/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 19 14:17:54 GMT 2025
 */

package org.joda.time.convert;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Hours;
import org.joda.time.Interval;
import org.joda.time.MutablePeriod;
import org.joda.time.PeriodType;
import org.joda.time.Seconds;
import org.joda.time.chrono.CopticChronology;
import org.joda.time.convert.CalendarConverter;
import org.joda.time.convert.Converter;
import org.joda.time.convert.ConverterSet;
import org.joda.time.convert.LongConverter;
import org.joda.time.convert.NullConverter;
import org.joda.time.convert.ReadableDurationConverter;
import org.joda.time.convert.ReadableInstantConverter;
import org.joda.time.convert.ReadableIntervalConverter;
import org.joda.time.convert.ReadablePartialConverter;
import org.joda.time.convert.ReadablePeriodConverter;
import org.joda.time.convert.StringConverter;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ConverterSet_ESTest extends ConverterSet_ESTest_scaffolding {

    @Test(timeout = 4000, expected = IndexOutOfBoundsException.class)
    public void remove_invalidIndex_throwsIndexOutOfBoundsException() {
        Converter[] converters = new Converter[1];
        ConverterSet set = new ConverterSet(converters);
        set.remove(1, converters); // Index 1 is out of bounds for size 1
    }

    @Test(timeout = 4000)
    public void add_newConverterInstance_returnsNewSet() {
        Converter[] converters = new Converter[8];
        converters[0] = new ReadableInstantConverter();
        converters[1] = new ReadableIntervalConverter();
        converters[2] = new ReadablePeriodConverter();
        converters[3] = new CalendarConverter();
        
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet newSet = originalSet.add(new CalendarConverter(), converters);
        assertNotSame(originalSet, newSet);
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void creatingMutablePeriodWithNullObject_throwsIllegalArgumentException() {
        Hours hours = Hours.ONE;
        Seconds seconds = hours.toStandardSeconds();
        PeriodType periodType = seconds.getPeriodType();
        // Creating MutablePeriod with null object should fail due to missing converter
        new MutablePeriod((Object) null, periodType);
    }

    @Test(timeout = 4000)
    public void remove_existingConverter_reducesSetSize() {
        Converter[] converters = new Converter[1];
        converters[0] = StringConverter.INSTANCE;
        
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet reducedSet = originalSet.remove(converters[0], converters);
        assertEquals(0, reducedSet.size());
    }

    @Test(timeout = 4000)
    public void size_afterInitialization_returnsCorrectCount() {
        Converter[] converters = new Converter[1];
        ConverterSet set = new ConverterSet(converters);
        assertEquals(1, set.size());
    }

    @Test(timeout = 4000)
    public void remove_validIndex_returnsDifferentSet() {
        Converter[] converters = new Converter[7];
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet newSet = originalSet.remove(1, converters);
        assertNotSame(originalSet, newSet);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void remove_nullConverterElement_throwsNullPointerException() {
        Converter[] converters = new Converter[1]; // Contains null element
        ConverterSet set = new ConverterSet(converters);
        set.remove(converters[0], converters); // Attempt to remove null converter
    }

    @Test(timeout = 4000, expected = ArrayIndexOutOfBoundsException.class)
    public void remove_converterFromEmptySet_throwsArrayIndexOutOfBoundsException() {
        Converter[] converters = new Converter[0];
        ConverterSet set = new ConverterSet(converters);
        set.remove(StringConverter.INSTANCE, converters); // Empty set access
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void remove_indexFromNullConverterArray_throwsNullPointerException() {
        ConverterSet set = new ConverterSet(null);
        set.remove(291, null); // Null converter array
    }

    @Test(timeout = 4000, expected = NegativeArraySizeException.class)
    public void remove_negativeIndex_throwsNegativeArraySizeException() {
        Converter[] converters = new Converter[0];
        ConverterSet set = new ConverterSet(converters);
        set.remove(-3378, null); // Negative array size
    }

    @Test(timeout = 4000, expected = ArrayIndexOutOfBoundsException.class)
    public void remove_invalidNegativeIndex_throwsArrayIndexOutOfBoundsException() {
        Converter[] converters = new Converter[0];
        ConverterSet set = new ConverterSet(converters);
        set.remove(-785, converters); // Invalid index
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void copyInto_nullArray_throwsNullPointerException() {
        ConverterSet set = new ConverterSet(null);
        set.copyInto(null); // Null destination array
    }

    @Test(timeout = 4000, expected = ArrayIndexOutOfBoundsException.class)
    public void copyInto_smallerDestinationArray_throwsArrayIndexOutOfBoundsException() {
        Converter[] converters = new Converter[7];
        ConverterSet set = new ConverterSet(converters);
        Converter[] smallArray = new Converter[1];
        set.copyInto(smallArray); // Destination array too small
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void add_nullConverter_throwsNullPointerException() {
        Converter[] converters = new Converter[14]; // Contains nulls
        ConverterSet set = new ConverterSet(converters);
        set.add(converters[0], converters); // Adding null converter
    }

    @Test(timeout = 4000, expected = ArrayIndexOutOfBoundsException.class)
    public void add_converterToEmptySet_throwsArrayIndexOutOfBoundsException() {
        Converter[] converters = new Converter[0];
        ConverterSet set = new ConverterSet(converters);
        set.add(StringConverter.INSTANCE, converters); // Empty set access
    }

    @Test(timeout = 4000)
    public void select_unsupportedClass_returnsNull() {
        Converter[] converters = new Converter[1];
        converters[0] = NullConverter.INSTANCE;
        ConverterSet set = new ConverterSet(converters);
        Converter result = set.select(ConverterSet.Entry.class);
        assertNull(result);
    }

    @Test(timeout = 4000)
    public void select_classNotHandledByConverters_returnsNull() {
        Converter[] converters = new Converter[3];
        converters[0] = new ReadableIntervalConverter();
        converters[1] = new LongConverter();
        converters[2] = new ReadableDurationConverter();
        
        ConverterSet set = new ConverterSet(converters);
        Converter result = set.select(ConverterSet.Entry.class);
        assertNull(result);
    }

    @Test(timeout = 4000)
    public void select_nullClass_returnsNull() {
        Converter[] converters = new Converter[1];
        converters[0] = StringConverter.INSTANCE;
        ConverterSet set = new ConverterSet(converters);
        Converter result = set.select(null); // Null class input
        assertNull(result);
    }

    @Test(timeout = 4000)
    public void select_supportedClass_returnsCorrectConverter() {
        Converter[] converters = new Converter[5];
        LongConverter longConverter = LongConverter.INSTANCE;
        converters[0] = longConverter;
        converters[1] = new ReadablePartialConverter();
        converters[2] = new CalendarConverter();
        converters[3] = new ReadableIntervalConverter();
        converters[4] = new ReadableIntervalConverter();
        
        ConverterSet set = new ConverterSet(converters);
        Converter result = set.select(Long.class);
        assertSame(longConverter, result);
    }

    @Test(timeout = 4000, expected = IndexOutOfBoundsException.class)
    public void remove_indexExceedingSize_throwsIndexOutOfBoundsException() {
        Converter[] converters = new Converter[1];
        ConverterSet set = new ConverterSet(converters);
        set.remove(1968, converters); // Index 1968 is out of bounds
    }

    @Test(timeout = 4000)
    public void remove_nullConverterFromEmptySet_returnsSameSet() {
        Converter[] converters = new Converter[0];
        ConverterSet set = new ConverterSet(converters);
        ConverterSet result = set.remove(null, null);
        assertSame(set, result);
    }

    @Test(timeout = 4000)
    public void remove_existingConverter_returnsDifferentSet() {
        Converter[] converters = new Converter[2];
        converters[1] = ReadablePartialConverter.INSTANCE;
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet newSet = originalSet.remove(converters[1], converters);
        assertNotSame(originalSet, newSet);
    }

    @Test(timeout = 4000)
    public void add_converterToEmptySet_returnsNewSet() {
        Converter[] converters = new Converter[0];
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet newSet = originalSet.add(ReadableInstantConverter.INSTANCE, null);
        assertNotSame(originalSet, newSet);
    }

    @Test(timeout = 4000)
    public void add_differentConverterInstance_returnsNewSet() {
        Converter[] converters = new Converter[3];
        converters[0] = ReadableInstantConverter.INSTANCE;
        ConverterSet originalSet = new ConverterSet(converters);
        ConverterSet newSet = originalSet.add(new ReadableInstantConverter(), null);
        assertNotSame(originalSet, newSet);
    }

    @Test(timeout = 4000)
    public void add_duplicateConverterInstance_returnsSameSet() {
        Converter[] converters = new Converter[1];
        StringConverter converter = StringConverter.INSTANCE;
        converters[0] = converter;
        ConverterSet set = new ConverterSet(converters);
        ConverterSet result = set.add(converter, converters);
        assertSame(set, result);
    }

    @Test(timeout = 4000)
    public void add_existingConverterInstance_returnsSameSet() {
        Converter[] converters = new Converter[10];
        ReadableInstantConverter converter = new ReadableInstantConverter();
        converters[0] = converter;
        ConverterSet set = new ConverterSet(converters);
        ConverterSet result = set.add(converter, null);
        assertSame(set, result);
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void createInterval_withUnsupportedType_throwsIllegalArgumentException() {
        ConverterSet.Entry entry = new ConverterSet.Entry(ConverterSet.Entry.class, new ReadablePartialConverter());
        CopticChronology chronology = CopticChronology.getInstance();
        // Interval creation fails due to unsupported type
        new Interval(entry, chronology);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void select_nullClassWithNullConverter_throwsNullPointerException() {
        Converter[] converters = new Converter[1]; // Contains null
        ConverterSet set = new ConverterSet(converters);
        set.select(null); // Null class input with null converter in set
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void size_withNullConverterArray_throwsNullPointerException() {
        ConverterSet set = new ConverterSet(null);
        set.size(); // Accessing null array
    }

    @Test(timeout = 4000)
    public void copyInto_arrayOfSameSize_succeeds() {
        Converter[] converters = new Converter[7];
        ConverterSet set = new ConverterSet(converters);
        set.copyInto(converters); // Valid copy operation
        assertEquals(7, converters.length);
    }
}