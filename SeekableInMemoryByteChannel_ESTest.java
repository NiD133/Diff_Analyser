/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 18 13:43:59 GMT 2025
 */

package org.apache.commons.compress.utils;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SeekableByteChannel;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class SeekableInMemoryByteChannel_ESTest extends SeekableInMemoryByteChannel_ESTest_scaffolding {

    // ===== Constructor Tests =====
    @Test(timeout = 4000, expected = NullPointerException.class)
    public void constructor_withNullArray_throwsNullPointerException() {
        new SeekableInMemoryByteChannel((byte[]) null);
    }

    @Test(timeout = 4000, expected = NegativeArraySizeException.class)
    public void constructor_withNegativeSize_throwsNegativeArraySizeException() {
        new SeekableInMemoryByteChannel(-1);
    }

    @Test(timeout = 4000)
    public void constructor_withEmptyArray_initializesCorrectly() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        assertArrayEquals(new byte[]{}, channel.array());
        assertEquals(0L, channel.size());
        assertEquals(0L, channel.position());
    }

    @Test(timeout = 4000)
    public void constructor_withInitialArray_setsSizeCorrectly() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(122);
        assertEquals(122L, channel.size());
    }

    // ===== Close/Open State Tests =====
    @Test(timeout = 4000)
    public void isOpen_afterClose_returnsFalse() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.close();
        assertFalse(channel.isOpen());
    }

    @Test(timeout = 4000)
    public void isOpen_onNewChannel_returnsTrue() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        assertTrue(channel.isOpen());
    }

    // ===== Read Operation Tests =====
    @Test(timeout = 4000)
    public void read_onEmptyChannel_returnsMinusOne() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        ByteBuffer buffer = ByteBuffer.allocate(1098);
        assertEquals(-1, channel.read(buffer));
    }

    @Test(timeout = 4000)
    public void read_withEmptyBuffer_returnsZeroAndMaintainsPosition() throws IOException {
        byte[] data = new byte[5];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        channel.position(1L);
        ByteBuffer buffer = ByteBuffer.allocate(0);
        assertEquals(0, channel.read(buffer));
        assertEquals(1L, channel.position());
    }

    @Test(timeout = 4000)
    public void read_updatesPosition() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        ByteBuffer buffer = ByteBuffer.allocate(3);
        channel.read(buffer);
        assertEquals(1L, channel.position());
    }

    @Test(timeout = 4000)
    public void read_beyondSize_returnsMinusOne() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        SeekableByteChannel positionedChannel = channel.position(Integer.MAX_VALUE);
        ByteBuffer buffer = ByteBuffer.allocate(1098);
        assertEquals(-1, positionedChannel.read(buffer));
    }

    @Test(timeout = 4000, expected = ClosedChannelException.class)
    public void read_afterClose_throwsException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.close();
        channel.read(ByteBuffer.allocate(1));
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void read_withNullBuffer_throwsNullPointerException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.read(null);
    }

    // ===== Write Operation Tests =====
    @Test(timeout = 4000)
    public void write_withEmptyBuffer_returnsZeroAndMaintainsPosition() throws IOException {
        byte[] data = new byte[5];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        ByteBuffer buffer = ByteBuffer.allocate(0);
        assertEquals(0, channel.write(buffer));
        assertEquals(0L, channel.position());
        assertEquals(5L, channel.size());
    }

    @Test(timeout = 4000)
    public void write_expandsChannelCapacity() throws IOException {
        byte[] data = new byte[1];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        ByteBuffer buffer = ByteBuffer.allocate(86);
        assertEquals(86, channel.write(buffer));
        assertEquals("java.nio.HeapByteBuffer[pos=86 lim=86 cap=86]", buffer.toString());
    }

    @Test(timeout = 4000)
    public void write_largeData_handlesCorrectly() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        ByteBuffer buffer = ByteBuffer.allocate(1073741823);
        int written = channel.write(buffer);
        assertEquals(1073741823, written);
        assertEquals(1073741823, buffer.position());
    }

    @Test(timeout = 4000, expected = ClosedChannelException.class)
    public void write_afterClose_throwsException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.close();
        channel.write(ByteBuffer.allocate(1));
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void write_withNullBuffer_throwsNullPointerException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(958);
        channel.write(null);
    }

    @Test(timeout = 4000)
    public void write_withFullBuffer_returnsZero() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        ByteBuffer buffer = ByteBuffer.allocateDirect(1);
        channel.read(buffer); // Fill buffer, position advances to 1
        int written = channel.write(buffer); // Buffer has no remaining space
        assertEquals(0, written);
        assertEquals(1L, channel.position());
    }

    @Test(timeout = 4000)
    public void write_afterReadAndBufferClear_writesData() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        ByteBuffer buffer = ByteBuffer.allocateDirect(1);
        channel.read(buffer); // Position becomes 1
        buffer.clear(); // Reset buffer for writing
        int written = channel.write(buffer); // Write 1 byte at position 1
        assertEquals(1, written);
        assertEquals(0, buffer.remaining());
    }

    // ===== Position Management Tests =====
    @Test(timeout = 4000)
    public void position_setToZero_worksCorrectly() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        SeekableByteChannel result = channel.position(0L);
        assertEquals(0L, result.size());
    }

    @Test(timeout = 4000, expected = IOException.class)
    public void position_setBeyondIntegerMax_throwsException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.position(2147483669L);
    }

    @Test(timeout = 4000, expected = IOException.class)
    public void position_setNegative_throwsException() throws IOException {
        byte[] data = new byte[2];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        channel.position(-429L);
    }

    @Test(timeout = 4000, expected = ClosedChannelException.class)
    public void position_afterClose_throwsException() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.close();
        channel.position(1073741828L);
    }

    // ===== Truncation Tests =====
    @Test(timeout = 4000)
    public void truncate_toCurrentSize_maintainsState() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(122);
        SeekableByteChannel result = channel.truncate(122);
        assertEquals(0L, result.position());
    }

    @Test(timeout = 4000)
    public void truncate_largerThanSize_ignored() {
        byte[] data = new byte[3];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        SeekableByteChannel result = channel.truncate(Integer.MAX_VALUE);
        assertEquals(3L, result.size());
        assertEquals(0L, result.position());
    }

    @Test(timeout = 4000)
    public void truncate_toZero_resetsSize() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        channel.truncate(0);
        assertEquals(0L, channel.size());
    }

    @Test(timeout = 4000)
    public void truncate_afterRead_resetsSizeAndPosition() throws IOException {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(1);
        ByteBuffer buffer = ByteBuffer.allocateDirect(1);
        channel.read(buffer); // Position becomes 1
        channel.truncate(0); // Size becomes 0, position reset to 0
        assertEquals(0L, channel.size());
        assertEquals(0L, channel.position());
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void truncate_beyondIntegerMax_throwsException() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.truncate(2147483648L);
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void truncate_negativeSize_throwsException() {
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel();
        channel.truncate(-469L);
    }

    @Test(timeout = 4000)
    public void truncate_afterClose_maintainsClosedState() {
        byte[] data = new byte[0];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(data);
        channel.close();
        channel.truncate(6051L); // Should not throw
        assertFalse(channel.isOpen());
    }

    // ===== Array Access Tests =====
    @Test(timeout = 4000)
    public void array_returnsBackingArray() {
        byte[] expected = new byte[8];
        SeekableInMemoryByteChannel channel = new SeekableInMemoryByteChannel(expected);
        assertArrayEquals(expected, channel.array());
    }
}