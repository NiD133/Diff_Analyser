/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4.sequence;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

/**
 * Tests for SequencesComparator which compares two sequences and generates
 * edit scripts to transform one sequence into another.
 */
class SequencesComparatorTest {

    /**
     * A visitor that applies edit commands to transform a source sequence into a target sequence.
     * This is used to verify that the edit script generated by SequencesComparator actually works.
     */
    private static final class EditScriptExecutor<T> implements CommandVisitor<T> {
        private List<T> workingSequence;
        private int currentIndex;

        /**
         * Sets the initial sequence to be transformed.
         */
        public void setSourceSequence(final List<T> sourceSequence) {
            this.workingSequence = new ArrayList<>(sourceSequence);
            this.currentIndex = 0;
        }

        /**
         * Returns the current state of the sequence as a concatenated string.
         */
        public String getResultAsString() {
            final StringBuilder result = new StringBuilder();
            for (final T element : workingSequence) {
                result.append(element);
            }
            return result.toString();
        }

        @Override
        public void visitDeleteCommand(final T object) {
            workingSequence.remove(currentIndex);
            // Note: currentIndex doesn't increment because removal shifts elements left
        }

        @Override
        public void visitInsertCommand(final T object) {
            workingSequence.add(currentIndex, object);
            currentIndex++; // Move past the inserted element
        }

        @Override
        public void visitKeepCommand(final T object) {
            currentIndex++; // Move to next element without modification
        }
    }

    // Test data for string transformation scenarios
    private List<String> sourceStrings;
    private List<String> targetStrings;
    private int[] expectedModificationCounts;

    /**
     * Converts a string into a list of Character objects for sequence comparison.
     */
    private List<Character> stringToCharacterList(final String string) {
        final List<Character> characters = new ArrayList<>();
        for (int i = 0; i < string.length(); i++) {
            characters.add(string.charAt(i));
        }
        return characters;
    }

    @BeforeEach
    void setupTestData() {
        // Define pairs of strings to test transformation scenarios
        sourceStrings = Arrays.asList(
            "bottle",           // -> "noodle" (6 modifications)
            "nematode knowledge", // -> "empty bottle" (16 modifications)
            "",                 // -> "" (0 modifications - empty strings)
            "aa",               // -> "C" (3 modifications)
            "prefixed string",  // -> "prefix" (9 modifications)
            "ABCABBA",          // -> "CBABAC" (5 modifications)
            "glop glop",        // -> "pas glop pas glop" (8 modifications)
            "coq",              // -> "ane" (6 modifications)
            "spider-man"        // -> "klingon" (13 modifications)
        );

        targetStrings = Arrays.asList(
            "noodle",
            "empty bottle",
            "",
            "C",
            "prefix",
            "CBABAC",
            "pas glop pas glop",
            "ane",
            "klingon"
        );

        // Expected number of edit operations for each transformation
        expectedModificationCounts = new int[] {
            6, 16, 0, 3, 9, 5, 8, 6, 13
        };
    }

    /**
     * Tests that the edit script can successfully transform source strings into target strings.
     * This verifies the correctness of the generated edit commands.
     */
    @Test
    void testEditScriptExecution() {
        final EditScriptExecutor<Character> executor = new EditScriptExecutor<>();
        
        for (int i = 0; i < sourceStrings.size(); i++) {
            final String sourceString = sourceStrings.get(i);
            final String expectedTargetString = targetStrings.get(i);
            
            // Set up the executor with the source sequence
            executor.setSourceSequence(stringToCharacterList(sourceString));
            
            // Generate and execute the edit script
            final SequencesComparator<Character> comparator = 
                new SequencesComparator<>(
                    stringToCharacterList(sourceString),
                    stringToCharacterList(expectedTargetString)
                );
            
            comparator.getScript().visit(executor);
            
            // Verify the transformation was successful
            assertEquals(expectedTargetString, executor.getResultAsString(),
                String.format("Failed to transform '%s' into '%s'", sourceString, expectedTargetString));
        }
    }

    /**
     * Tests that the number of modifications in the edit script matches expected values.
     * This verifies the optimality of the generated edit scripts.
     */
    @Test
    void testModificationCounts() {
        for (int i = 0; i < sourceStrings.size(); i++) {
            final String sourceString = sourceStrings.get(i);
            final String targetString = targetStrings.get(i);
            final int expectedCount = expectedModificationCounts[i];
            
            final SequencesComparator<Character> comparator =
                new SequencesComparator<>(
                    stringToCharacterList(sourceString),
                    stringToCharacterList(targetString)
                );
            
            final int actualModifications = comparator.getScript().getModifications();
            
            assertEquals(expectedCount, actualModifications,
                String.format("Wrong modification count for transforming '%s' to '%s'", 
                    sourceString, targetString));
        }
    }

    /**
     * Tests that the algorithm produces minimal (optimal) edit scripts.
     * Uses random modifications to a base sequence and verifies the algorithm
     * finds an edit script with at most the same number of modifications.
     */
    @Test
    void testMinimalEditDistance() {
        // Create a base sequence using fictional "Shadok" language elements
        final String[] shadokVocabulary = {"GA", "BU", "ZO", "MEU"};
        final List<String> baseSequence = Arrays.asList(
            "GA", "ZO", "MEU", "BU", "GA", "GA", "ZO", "BU", "MEU", "GA",
            "ZO", "BU", "MEU", "ZO", "ZO", "GA", "BU", "MEU", "GA", "MEU"
        );

        final Random random = new Random(4564634237452342L); // Fixed seed for reproducibility

        // Test with increasing numbers of random modifications
        for (int numberOfModifications = 0; numberOfModifications <= 40; numberOfModifications += 5) {
            final List<String> modifiedSequence = new ArrayList<>(baseSequence);
            
            // Apply random insertions and deletions
            for (int i = 0; i < numberOfModifications; i++) {
                if (random.nextInt(2) == 0) {
                    // Random insertion
                    final int insertPosition = random.nextInt(modifiedSequence.size() + 1);
                    final String elementToInsert = shadokVocabulary[random.nextInt(4)];
                    modifiedSequence.add(insertPosition, elementToInsert);
                } else {
                    // Random deletion (only if sequence is not empty)
                    if (!modifiedSequence.isEmpty()) {
                        final int deletePosition = random.nextInt(modifiedSequence.size());
                        modifiedSequence.remove(deletePosition);
                    }
                }
            }

            // Verify the algorithm finds an optimal solution
            final SequencesComparator<String> comparator = 
                new SequencesComparator<>(baseSequence, modifiedSequence);
            final int algorithmModifications = comparator.getScript().getModifications();
            
            assertTrue(algorithmModifications <= numberOfModifications,
                String.format("Algorithm found %d modifications but only %d were applied", 
                    algorithmModifications, numberOfModifications));
        }
    }

    /**
     * Comprehensive test using all possible sequences up to a certain length.
     * Tests every possible transformation between sequences to ensure correctness.
     */
    @Test
    void testExhaustiveSequenceTransformations() {
        final int maxSequenceLength = 5;
        final String[] shadokAlphabet = {"GA", "BU", "ZO", "MEU"};
        
        // Generate all possible sequences up to maxSequenceLength
        final List<List<String>> allPossibleSequences = generateAllSequences(shadokAlphabet, maxSequenceLength);
        
        final EditScriptExecutor<String> executor = new EditScriptExecutor<>();

        // Test transformation between every pair of sequences
        for (final List<String> sourceSequence : allPossibleSequences) {
            for (final List<String> targetSequence : allPossibleSequences) {
                // Set up transformation
                executor.setSourceSequence(sourceSequence);
                
                // Generate and execute edit script
                final SequencesComparator<String> comparator = 
                    new SequencesComparator<>(sourceSequence, targetSequence);
                comparator.getScript().visit(executor);

                // Verify transformation correctness
                final String expectedResult = concatenateSequence(targetSequence);
                final String actualResult = executor.getResultAsString();
                
                assertEquals(expectedResult, actualResult,
                    String.format("Failed to transform %s into %s", sourceSequence, targetSequence));
            }
        }
    }

    /**
     * Generates all possible sequences up to the specified maximum length using the given alphabet.
     */
    private List<List<String>> generateAllSequences(final String[] alphabet, final int maxLength) {
        List<List<String>> sequences = new ArrayList<>();
        sequences.add(new ArrayList<>()); // Start with empty sequence
        
        for (int length = 0; length < maxLength; length++) {
            final List<List<String>> newSequences = new ArrayList<>();
            newSequences.add(new ArrayList<>()); // Always include empty sequence
            
            for (final String symbol : alphabet) {
                for (final List<String> existingSequence : sequences) {
                    final List<String> extendedSequence = new ArrayList<>(existingSequence);
                    extendedSequence.add(symbol);
                    newSequences.add(extendedSequence);
                }
            }
            sequences = newSequences;
        }
        
        return sequences;
    }

    /**
     * Concatenates all elements in a sequence into a single string.
     */
    private String concatenateSequence(final List<String> sequence) {
        final StringBuilder result = new StringBuilder();
        for (final String element : sequence) {
            result.append(element);
        }
        return result.toString();
    }
}