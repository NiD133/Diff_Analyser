/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 19 15:41:03 GMT 2025
 */

package com.google.gson.internal.bind;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.gson.Gson;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializer;
import com.google.gson.ToNumberPolicy;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.internal.Excluder;
import com.google.gson.internal.bind.DefaultDateTypeAdapter;
import com.google.gson.internal.bind.ObjectTypeAdapter;
import com.google.gson.internal.bind.TreeTypeAdapter;
import com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.BufferedWriter;
import java.io.CharArrayWriter;
import java.io.EOFException;
import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.time.temporal.ChronoField;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class TypeAdapterRuntimeTypeWrapper_ESTest extends TypeAdapterRuntimeTypeWrapper_ESTest_scaffolding {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test(timeout = 4000)
    public void writeEnumValueSucceeds() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        Class<ChronoField> enumType = ChronoField.class;
        TypeAdapter<ChronoField> enumAdapter = gson.getAdapter(enumType);
        TypeAdapterRuntimeTypeWrapper<ChronoField> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, enumAdapter, declaredType);

        PipedWriter pipedWriter = new PipedWriter();
        BufferedWriter bufferedWriter = new BufferedWriter(pipedWriter);
        JsonWriter jsonWriter = gson.newJsonWriter(bufferedWriter);
        ChronoField value = ChronoField.HOUR_OF_AMPM;

        // Act
        adapterWrapper.write(jsonWriter, value);

        // Assert
        assertFalse(jsonWriter.isLenient());
    }

    @Test(timeout = 4000)
    public void readFromEmptyStringReaderThrowsEOF() throws Throwable {
        // Arrange
        JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        Gson gson = new Gson();
        Class<Short> declaredType = Short.TYPE;
        Class<Integer> targetType = Integer.class;
        TypeToken<Integer> targetTypeToken = TypeToken.get(targetType);
        TypeAdapterFactory adapterFactory = TreeTypeAdapter.newFactory(targetTypeToken, mockSerializer);
        
        Class<ChronoField> fieldType = ChronoField.class;
        TypeToken<ChronoField> fieldTypeToken = TypeToken.get(fieldType);
        JsonSerializer<ChronoField> fieldSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        JsonDeserializer<ChronoField> fieldDeserializer = mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
        TreeTypeAdapter<ChronoField> treeAdapter = new TreeTypeAdapter<>(
            fieldSerializer, fieldDeserializer, gson, fieldTypeToken, adapterFactory
        );
        TypeAdapterRuntimeTypeWrapper<ChronoField> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, treeAdapter, declaredType);

        StringReader reader = new StringReader("");
        JsonReader jsonReader = new JsonReader(reader);

        // Act & Assert: Expect EOFException due to empty input
        thrown.expect(EOFException.class);
        adapterWrapper.read(jsonReader);
    }

    @Test(timeout = 4000)
    public void writeUnsupportedTypeThrowsUnsupportedOperation() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        CharArrayWriter charArrayWriter = new CharArrayWriter();
        MockPrintWriter mockPrintWriter = new MockPrintWriter(charArrayWriter, false);
        JsonWriter jsonWriter = new JsonWriter(charArrayWriter);

        // Act & Assert: Expect UnsupportedOperationException when writing unsupported type
        thrown.expect(UnsupportedOperationException.class);
        adapterWrapper.write(jsonWriter, mockPrintWriter);
    }

    @Test(timeout = 4000)
    public void writeAfterNullValueThrowsIllegalState() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        StringWriter stringWriter = new StringWriter(2099);
        MockPrintWriter mockPrintWriter = new MockPrintWriter(stringWriter);
        JsonWriter jsonWriter = new JsonWriter(mockPrintWriter);
        jsonWriter.nullValue(); // Puts writer in invalid state for next value

        // Act & Assert: Expect IllegalStateException due to multiple top-level values
        thrown.expect(IllegalStateException.class);
        thrown.expectMessage("JSON must have only one top-level value.");
        adapterWrapper.write(jsonWriter, stringWriter);
    }

    @Test(timeout = 4000)
    public void writeToUnconnectedPipeThrowsIOException() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Excluder excluder = new Excluder();
        Class<Integer> declaredType = Integer.TYPE;
        TypeToken<Integer> intToken = TypeToken.get(declaredType);
        Class<Object> objectClass = Object.class;
        TypeToken<Object> objectToken = TypeToken.get(objectClass);
        TypeAdapter<Object> objectAdapter = gson.getDelegateAdapter(excluder, objectToken);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        PipedWriter pipedWriter = new PipedWriter(); // Never connected
        JsonWriter jsonWriter = new JsonWriter(pipedWriter);

        // Act & Assert: Expect IOException due to unconnected pipe
        thrown.expect(IOException.class);
        thrown.expectMessage("Pipe not connected");
        adapterWrapper.write(jsonWriter, intToken);
    }

    @Test(timeout = 4000)
    public void readMalformedJsonThrowsIOException() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        String malformedJson = gson.toString(); // Not valid JSON
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        StringReader reader = new StringReader(malformedJson);
        JsonReader jsonReader = gson.newJsonReader(reader);

        // Act & Assert: Expect IOException for malformed JSON
        thrown.expect(IOException.class);
        thrown.expectMessage("malformed JSON");
        adapterWrapper.read(jsonReader);
    }

    @Test(timeout = 4000)
    public void readWithNullReaderThrowsNullPointer() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        // Act & Assert: Expect NullPointerException
        thrown.expect(NullPointerException.class);
        adapterWrapper.read(null);
    }

    @Test(timeout = 4000)
    public void readWithDelegateAdapterAndEmptyInputThrowsEOF() throws Throwable {
        // Arrange
        JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeToken<Object> objectToken = TypeToken.get(declaredType);
        TypeAdapterFactory adapterFactory = TreeTypeAdapter.newFactoryWithMatchRawType(objectToken, mockSerializer);
        TypeAdapter<Object> delegateAdapter = gson.getDelegateAdapter(adapterFactory, objectToken);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, delegateAdapter, declaredType);

        StringReader reader = new StringReader("");
        JsonReader jsonReader = gson.newJsonReader(reader);

        // Act & Assert: Expect EOFException
        thrown.expect(EOFException.class);
        thrown.expectMessage("End of input");
        adapterWrapper.read(jsonReader);
    }

    @Test(timeout = 4000)
    public void readFromUnconnectedPipedReaderThrowsRuntimeException() throws Throwable {
        // Arrange
        JsonSerializer<Integer> mockSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        JsonDeserializer<Integer> mockDeserializer = mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
        Class<Integer> declaredType = Integer.class;
        TypeToken<Integer> intToken = TypeToken.get(declaredType);
        TypeAdapterFactory adapterFactory = DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY;
        TreeTypeAdapter<Integer> treeAdapter = new TreeTypeAdapter<>(
            mockSerializer, mockDeserializer, null, intToken, adapterFactory, true
        );
        TypeAdapterRuntimeTypeWrapper<Integer> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(null, treeAdapter, declaredType);

        PipedReader pipedReader = new PipedReader(); // Never connected
        JsonReader jsonReader = new JsonReader(pipedReader);

        // Act & Assert: Expect RuntimeException wrapping IOException
        thrown.expect(RuntimeException.class);
        thrown.expectMessage("Pipe not connected");
        adapterWrapper.read(jsonReader);
    }

    @Test(timeout = 4000)
    public void writeClassTypeThrowsUnsupportedOperation() throws Throwable {
        // Arrange
        JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        JsonDeserializer<Object> mockDeserializer = mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
        Gson gson = new Gson();
        Class<Object> objectClass = Object.class;
        Class<Integer> intClass = Integer.class;
        TypeToken<Integer> intToken = TypeToken.get(intClass);
        TypeAdapterFactory adapterFactory = TreeTypeAdapter.newFactory(intToken, mockSerializer);
        TypeToken<Object> objectToken = TypeToken.get(objectClass);
        TreeTypeAdapter<Object> treeAdapter = new TreeTypeAdapter<>(null, mockDeserializer, gson, objectToken, adapterFactory);
        
        Class<Byte> declaredType = Byte.TYPE;
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, treeAdapter, declaredType);

        CharArrayWriter charArrayWriter = new CharArrayWriter();
        JsonWriter jsonWriter = new JsonWriter(charArrayWriter);

        // Act & Assert: Expect UnsupportedOperationException when writing Class
        thrown.expect(UnsupportedOperationException.class);
        thrown.expectMessage("forgot to register a type adapter");
        adapterWrapper.write(jsonWriter, treeAdapter);
    }

    @Test(timeout = 4000)
    public void writeWithNullWriterThrowsNullPointer() throws Throwable {
        // Arrange
        JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
        doReturn(null).when(mockSerializer).serialize(any(), any(), any());
        JsonDeserializer<Object> mockDeserializer = mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
        Gson gson = new Gson();
        Class<Object> objectClass = Object.class;
        TypeToken<Object> objectToken = TypeToken.get(objectClass);
        TypeAdapterFactory adapterFactory = TreeTypeAdapter.newFactory(objectToken, mockSerializer);
        TreeTypeAdapter<Object> treeAdapter = new TreeTypeAdapter<>(mockSerializer, mockDeserializer, gson, objectToken, adapterFactory);
        
        Class<Short> declaredType = Short.TYPE;
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, treeAdapter, declaredType);

        // Act & Assert: Expect NullPointerException
        thrown.expect(NullPointerException.class);
        adapterWrapper.write(null, gson);
    }

    @Test(timeout = 4000)
    public void writeNullValueThrowsNullPointer() throws Throwable {
        // Arrange
        JsonDeserializer<Object> mockDeserializer = mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
        Gson gson = new Gson();
        Class<Short> declaredType = Short.TYPE;
        Class<Object> objectClass = Object.class;
        TypeToken<Object> objectToken = TypeToken.get(objectClass);
        ToNumberPolicy numberPolicy = ToNumberPolicy.DOUBLE;
        TypeAdapterFactory adapterFactory = ObjectTypeAdapter.getFactory(numberPolicy);
        TreeTypeAdapter<Object> treeAdapter = new TreeTypeAdapter<>(null, mockDeserializer, gson, objectToken, adapterFactory);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, treeAdapter, declaredType);

        // Act & Assert: Expect NullPointerException
        thrown.expect(NullPointerException.class);
        adapterWrapper.write(null, objectToken);
    }

    @Test(timeout = 4000)
    public void writeNullValueWithNullWriterThrowsNullPointer() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        // Act & Assert: Expect NullPointerException
        thrown.expect(NullPointerException.class);
        adapterWrapper.write(null, null);
    }

    @Test(timeout = 4000)
    public void readFromPipedReaderThrowsIOException() throws Throwable {
        // Arrange
        Gson gson = new Gson();
        Class<Object> declaredType = Object.class;
        TypeAdapter<Object> objectAdapter = gson.getAdapter(declaredType);
        TypeAdapterRuntimeTypeWrapper<Object> adapterWrapper = 
            new TypeAdapterRuntimeTypeWrapper<>(gson, objectAdapter, declaredType);

        PipedReader pipedReader = new PipedReader(); // Never connected
        JsonReader jsonReader = gson.newJsonReader(pipedReader);

        // Act & Assert: Expect IOException due to unconnected pipe
        thrown.expect(IOException.class);
        thrown.expectMessage("Pipe not connected");
        adapterWrapper.read(jsonReader);
    }
}