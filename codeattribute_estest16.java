package org.apache.commons.compress.harmony.unpack200.bytecode;

import org.apache.commons.compress.harmony.unpack200.Segment;
import org.junit.Test;

import java.util.Collections;
import java.util.List;

import static org.junit.Assert.fail;

/**
 * This test class contains an improved version of a test originally generated by EvoSuite.
 * The focus of the improvement is on understandability and maintainability.
 */
public class CodeAttribute_ESTestTest16 extends CodeAttribute_ESTest_scaffolding {

    /**
     * Tests that the CodeAttribute constructor throws an ArrayIndexOutOfBoundsException
     * when a bytecode instruction is provided with a negative, and thus invalid,
     * branch target operand.
     * <p>
     * The constructor attempts to use this negative value as an index into an internal
     * list of bytecode offsets, which correctly results in the exception.
     * </p>
     */
    @Test(timeout = 4000)
    public void constructorShouldThrowExceptionForInvalidNegativeBranchTarget() {
        // ARRANGE: Set up the test conditions and inputs.

        // A bytecode sequence containing an 'ifne' (if not equal to zero) instruction.
        // The 'ifne' instruction requires a branch target operand.
        final byte IFNE_OPCODE = (byte) 0x9E; // Opcode for 'ifne' is 158.
        byte[] bytecodeSequence = {0, 0, 0, IFNE_OPCODE, 0, 0, 0};

        // Provide a negative branch target for the 'ifne' instruction. This is invalid
        // and is the condition we are testing.
        final int invalidBranchTarget = -98;
        int[] branchOperands = {invalidBranchTarget};

        // The OperandManager provides the operands for bytecode instructions.
        // For this test, only the branch operands list needs to be populated.
        // The other 20 operand lists can be empty.
        int[] emptyOperands = new int[0];
        OperandManager operandManager = new OperandManager(
                branchOperands, emptyOperands, emptyOperands, emptyOperands,
                emptyOperands, emptyOperands, emptyOperands, emptyOperands,
                emptyOperands, emptyOperands, emptyOperands, emptyOperands,
                emptyOperands, emptyOperands, emptyOperands, emptyOperands,
                emptyOperands, emptyOperands, emptyOperands, emptyOperands,
                emptyOperands
        );

        List<ExceptionTableEntry> exceptionTable = Collections.emptyList();
        final int arbitraryMaxStack = 10;
        final int arbitraryMaxLocals = 10;
        final Segment segment = null; // The segment is not used in this specific failure path.

        // ACT & ASSERT: Execute the code under test and verify the outcome.
        try {
            new CodeAttribute(arbitraryMaxStack, arbitraryMaxLocals, bytecodeSequence, segment, operandManager, exceptionTable);
            fail("Expected an ArrayIndexOutOfBoundsException due to the negative branch target.");
        } catch (ArrayIndexOutOfBoundsException e) {
            // This is the expected outcome. The constructor attempts to use the negative
            // branch target as an index, which correctly throws this exception.
        }
    }
}