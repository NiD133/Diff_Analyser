/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability
 */

package org.apache.commons.collections4.iterators;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ConcurrentModificationException;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import org.apache.commons.collections4.Closure;
import org.apache.commons.collections4.functors.InstanceofPredicate;
import org.apache.commons.collections4.functors.UniquePredicate;
import org.apache.commons.collections4.iterators.LoopingListIterator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class LoopingListIterator_ESTest extends LoopingListIterator_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testSetAfterPrevious_ThenHasPreviousIsTrue() throws Throwable {
      // Test that setting an element after moving to previous maintains hasPrevious state
      LinkedList<Integer> list = new LinkedList<>();
      Integer initialValue = new Integer(-844);
      list.add(initialValue);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      iterator.previous(); // Move to the only element (now at position 0)
      iterator.set(null); // Set the current element to null
      assertTrue(iterator.hasPrevious());
  }

  @Test(timeout = 4000)
  public void testSize_WithOneElement_ReturnsOne() throws Throwable {
      // Verify iterator correctly reports size for a single-element list
      LinkedList<Integer> list = new LinkedList<>();
      list.add(new Integer(0));
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      assertEquals(1, iterator.size());
  }

  @Test(timeout = 4000)
  public void testPreviousIndex_WithTwoElements_ReturnsOne() throws Throwable {
      // Verify previousIndex returns correct value when list has two elements
      LinkedList<Integer> list = new LinkedList<>();
      Integer value = new Integer(-3558);
      list.add(value);
      list.push(value); // Adds at front: [value, value]
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      assertEquals(1, iterator.previousIndex());
  }

  @Test(timeout = 4000)
  public void testAddElement_ThenNextIndexIsOne() throws Throwable {
      // Verify nextIndex updates correctly after adding an element
      LinkedList<InstanceofPredicate> list = new LinkedList<>();
      Class<Integer> integerClass = Integer.class;
      InstanceofPredicate predicate = new InstanceofPredicate(integerClass);
      list.add(predicate);
      LoopingListIterator<InstanceofPredicate> iterator = new LoopingListIterator<>(list);
      iterator.add(predicate);
      assertEquals(1, iterator.nextIndex());
  }

  @Test(timeout = 4000)
  public void testSet_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify set throws exception after list modification via removeIf
      LinkedList<Integer> list = new LinkedList<>();
      Integer value = new Integer(-844);
      list.add(value);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      iterator.previous(); // Move to element
      UniquePredicate<Object> uniquePredicate = new UniquePredicate<>();
      list.removeIf(uniquePredicate); // Modify list externally
      try {
          iterator.set(value);
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testReset_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify reset throws exception after list modification
      LinkedList<Integer> list = new LinkedList<>();
      List<Integer> subList = list.subList(0, 0);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(subList);
      list.add(new Integer(0)); // Modify backing list
      try {
          iterator.reset();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testRemove_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify remove throws exception after list modification
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      list.add(iterator); // Modify list after iterator creation
      try {
          iterator.remove();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testPreviousIndex_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify previousIndex throws exception after list modification
      LinkedList<Integer> list = new LinkedList<>();
      List<Integer> subList = list.subList(0, 0);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(subList);
      list.add(new Integer(0)); // Modify backing list
      try {
          iterator.previousIndex();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testPrevious_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify previous throws exception after list modification
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      list.add(iterator); // Modify list after iterator creation
      try {
          iterator.previous();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testNextIndex_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify nextIndex throws exception after list modification
      LinkedList<Integer> list = new LinkedList<>();
      List<Integer> subList = list.subList(0, 0);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(subList);
      list.add(new Integer(0)); // Modify backing list
      try {
          iterator.nextIndex();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testNext_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify next throws exception after list modification
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      list.add(iterator); // Modify list after iterator creation
      try {
          iterator.next();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testHasPrevious_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify hasPrevious throws exception after list modification
      LinkedList<Integer> list = new LinkedList<>();
      List<Integer> subList = list.subList(0, 0);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(subList);
      list.add(new Integer(0)); // Modify backing list
      try {
          iterator.hasPrevious();
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testAdd_AfterUnderlyingListModified_ThrowsConcurrentModificationException() throws Throwable {
      // Verify add throws exception after list modification
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      list.add(iterator); // Modify list after iterator creation
      try {
          iterator.add(list);
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testConstructor_WithModifiedSubList_ThrowsConcurrentModificationException() throws Throwable {
      // Verify constructor fails when subList is modified
      LinkedList<Integer> list = new LinkedList<>();
      List<Integer> subList = list.subList(0, 0);
      list.add(new Integer(0)); // Modify backing list
      try {
          new LoopingListIterator<>(subList);
          fail("Expected ConcurrentModificationException");
      } catch (ConcurrentModificationException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testConstructor_WithNullList_ThrowsNullPointerException() throws Throwable {
      // Verify constructor throws NPE when list is null
      try {
          new LoopingListIterator<>(null);
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          // Verify exception message
          assertEquals("collection", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testAdd_ThenPreviousIndexIsZero() throws Throwable {
      // Verify previousIndex returns 0 after adding an element
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      iterator.add(list);
      assertEquals(0, iterator.previousIndex());
  }

  @Test(timeout = 4000)
  public void testPreviousIndex_WithEmptyList_ThrowsNoSuchElementException() throws Throwable {
      // Verify previousIndex throws exception for empty list
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      try {
          iterator.previousIndex();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException e) {
          assertEquals("There are no elements for this iterator to loop on", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testAdd_ThenPreviousReturnsAddedElement() throws Throwable {
      // Verify previous returns the added element
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      iterator.add(list);
      LinkedList<?> result = (LinkedList<?>) iterator.previous();
      assertEquals(1, result.size());
  }

  @Test(timeout = 4000)
  public void testPrevious_WithEmptyList_ThrowsNoSuchElementException() throws Throwable {
      // Verify previous throws exception for empty list
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      try {
          iterator.previous();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException e) {
          assertEquals("There are no elements for this iterator to loop on", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testPrevious_WithNullElement_ReturnsNull() throws Throwable {
      // Verify previous returns null when list contains null
      LinkedList<Closure<Integer>> list = new LinkedList<>();
      list.add(null);
      LoopingListIterator<Closure<Integer>> iterator = new LoopingListIterator<>(list);
      assertNull(iterator.previous());
  }

  @Test(timeout = 4000)
  public void testAdd_ThenNextIndexIsZero() throws Throwable {
      // Verify nextIndex returns 0 after adding an element
      LinkedList<InstanceofPredicate> list = new LinkedList<>();
      LoopingListIterator<InstanceofPredicate> iterator = new LoopingListIterator<>(list);
      Class<Object> objectClass = Object.class;
      InstanceofPredicate predicate = new InstanceofPredicate(objectClass);
      iterator.add(predicate);
      assertEquals(0, iterator.nextIndex());
  }

  @Test(timeout = 4000)
  public void testNextIndex_WithEmptyList_ThrowsNoSuchElementException() throws Throwable {
      // Verify nextIndex throws exception for empty list
      LinkedList<LinkedList<Object>> list = new LinkedList<>();
      LoopingListIterator<LinkedList<Object>> iterator = new LoopingListIterator<>(list);
      try {
          iterator.nextIndex();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException e) {
          assertEquals("There are no elements for this iterator to loop on", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testAddThenNextThenRemove_ThenHasPreviousIsFalse() throws Throwable {
      // Verify hasPrevious is false after add, next, and remove
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      iterator.add(list);
      iterator.next(); // Position at the added element
      iterator.remove(); // Remove the element
      assertFalse(iterator.hasPrevious());
  }

  @Test(timeout = 4000)
  public void testNext_WithEmptyList_ThrowsNoSuchElementException() throws Throwable {
      // Verify next throws exception for empty list
      LinkedList<Integer> list = new LinkedList<>();
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      try {
          iterator.next();
          fail("Expected NoSuchElementException");
      } catch (NoSuchElementException e) {
          assertEquals("There are no elements for this iterator to loop on", e.getMessage());
      }
  }

  @Test(timeout = 4000)
  public void testNext_WithNullElement_ReturnsNull() throws Throwable {
      // Verify next returns null when list contains null
      LinkedList<Integer> list = new LinkedList<>();
      list.add(null);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      assertNull(iterator.next());
  }

  @Test(timeout = 4000)
  public void testHasPrevious_WithEmptyList_ReturnsFalse() throws Throwable {
      // Verify hasPrevious returns false for empty list
      LinkedList<Integer> list = new LinkedList<>();
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      assertFalse(iterator.hasPrevious());
  }

  @Test(timeout = 4000)
  public void testHasPrevious_WithOneElement_ReturnsTrue() throws Throwable {
      // Verify hasPrevious returns true for single-element list
      LinkedList<Integer> list = new LinkedList<>();
      list.add(null);
      LoopingListIterator<Integer> iterator = new LoopingListIterator<>(list);
      assertTrue(iterator.hasPrevious());
  }

  @Test(timeout = 4000)
  public void testHasNext_WithEmptyList_ReturnsFalse() throws Throwable {
      // Verify hasNext returns false for empty list
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      assertFalse(iterator.hasNext());
  }

  @Test(timeout = 4000)
  public void testAdd_ThenHasNextReturnsTrue() throws Throwable {
      // Verify hasNext returns true after adding an element
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      iterator.add(list);
      assertTrue(iterator.hasNext());
  }

  @Test(timeout = 4000)
  public void testReset_WithEmptyList_ThenHasNextIsFalse() throws Throwable {
      // Verify reset doesn't change hasNext (false) for empty list
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      iterator.reset();
      assertFalse(iterator.hasNext());
  }

  @Test(timeout = 4000)
  public void testSet_WithoutNextOrPrevious_ThrowsIllegalStateException() throws Throwable {
      // Verify set throws exception without prior traversal
      LinkedList<Integer> list = new LinkedList<>();
      LinkedList<LinkedList<Integer>> outerList = new LinkedList<>();
      LoopingListIterator<LinkedList<Integer>> iterator = new LoopingListIterator<>(outerList);
      try {
          iterator.set(list);
          fail("Expected IllegalStateException");
      } catch (IllegalStateException e) {
          // Expected behavior
      }
  }

  @Test(timeout = 4000)
  public void testSize_WithEmptyList_ReturnsZero() throws Throwable {
      // Verify size returns 0 for empty list
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      assertEquals(0, iterator.size());
  }

  @Test(timeout = 4000)
  public void testRemove_WithoutNextOrPrevious_ThrowsIllegalStateException() throws Throwable {
      // Verify remove throws exception without prior traversal
      LinkedList<Object> list = new LinkedList<>();
      LoopingListIterator<Object> iterator = new LoopingListIterator<>(list);
      try {
          iterator.remove();
          fail("Expected IllegalStateException");
      } catch (IllegalStateException e) {
          // Expected behavior
      }
  }
}