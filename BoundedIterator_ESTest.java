/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:23:43 GMT 2025
 */

package org.apache.commons.collections4.iterators;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import org.apache.commons.collections4.Closure;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.functors.NOPClosure;
import org.apache.commons.collections4.iterators.BoundedIterator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class BoundedIterator_ESTest extends BoundedIterator_ESTest_scaffolding {

    // ================= Constructor Tests =================

    @Test(timeout = 4000)
    public void testConstructor_ThrowsNPE_WhenIteratorIsNull() {
        try {
            new BoundedIterator<Boolean>(null, 0L, 0L);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            verifyException("java.util.Objects", e);
        }
    }

    @Test(timeout = 4000)
    public void testConstructor_ThrowsIAE_WhenOffsetIsNegative() {
        Iterator<Boolean> mockIterator = mock(Iterator.class);
        try {
            new BoundedIterator<Boolean>(mockIterator, -1007L, -1007L);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Offset parameter must not be negative.", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testConstructor_ThrowsIAE_WhenMaxIsNegative() {
        Iterator<Boolean> mockIterator = mock(Iterator.class);
        try {
            new BoundedIterator<Boolean>(mockIterator, 0L, -1022L);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Max parameter must not be negative.", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testConstructor_ThrowsCME_WhenUnderlyingIteratorModifiedDuringInitialization() {
        LinkedList<Object> list = new LinkedList<>();
        Iterator<Object> iterator = list.iterator();
        list.add(new Object()); // Modifies the list after iterator creation
        
        try {
            new BoundedIterator<>(iterator, 1973L, 287L);
            fail("Expecting exception: ConcurrentModificationException");
        } catch (ConcurrentModificationException e) {
            // Expected: List modified after iterator creation
        }
    }

    // ================= hasNext() Tests =================

    @Test(timeout = 4000)
    public void testHasNext_ReturnsTrue_WhenElementsAvailableAfterOffset() {
        LinkedList<Integer> list = new LinkedList<>();
        list.add(1);
        Iterator<Integer> baseIterator = list.descendingIterator();
        BoundedIterator<Integer> boundedIterator = new BoundedIterator<>(baseIterator, 0L, 508L);
        assertTrue(boundedIterator.hasNext());
    }

    @Test(timeout = 4000)
    public void testHasNext_ReturnsFalse_WhenNoElementsWithinBounds() {
        LinkedList<Object> list = new LinkedList<>();
        Iterator<Object> baseIterator = list.iterator();
        BoundedIterator<Object> boundedIterator = new BoundedIterator<>(baseIterator, 0L, 0L);
        assertFalse(boundedIterator.hasNext());
    }

    // ================= next() Tests =================

    @Test(timeout = 4000)
    public void testNext_ThrowsNoSuchElement_WhenNoElementsAvailable() {
        LinkedList<Object> list = new LinkedList<>();
        Iterator<Object> baseIterator = list.iterator();
        BoundedIterator<Object> boundedIterator = new BoundedIterator<>(baseIterator, 0L, 0L);
        
        try {
            boundedIterator.next();
            fail("Expecting exception: NoSuchElementException");
        } catch (NoSuchElementException e) {
            // Expected: No elements to return
        }
    }

    @Test(timeout = 4000)
    public void testNext_ThrowsCME_WhenUnderlyingCollectionModified() {
        LinkedList<Object> list = new LinkedList<>();
        Iterator<Object> baseIterator = list.descendingIterator();
        BoundedIterator<Object> boundedIterator = new BoundedIterator<>(baseIterator, 5L, 5L);
        list.add(new Object()); // Modifies list after iterator creation
        
        try {
            boundedIterator.next();
            fail("Expecting exception: ConcurrentModificationException");
        } catch (ConcurrentModificationException e) {
            // Expected: Concurrent modification during iteration
        }
    }

    // ================= remove() Tests =================

    @Test(timeout = 4000)
    public void testRemove_ThrowsIllegalStateException_WhenCalledBeforeNext() {
        Iterator<Predicate<Object>> mockIterator = mock(Iterator.class, new ViolatedAssumptionAnswer());
        when(mockIterator.hasNext()).thenReturn(true, true, false, false);
        when(mockIterator.next()).thenReturn(null, null, null);
        
        BoundedIterator<Predicate<Object>> boundedIterator = new BoundedIterator<>(mockIterator, 1031L, 1031L);
        boundedIterator.next(); // Advance past first element
        BoundedIterator<Predicate<Object>> chainedIterator = new BoundedIterator<>(boundedIterator, 1031L, 0L);
        
        try {
            chainedIterator.remove();
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            assertEquals("remove() cannot be called before calling next()", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testRemove_ThrowsIllegalStateException_WhenCalledBeforeNextAfterInitialization() {
        Iterator<Predicate<Object>> mockIterator = mock(Iterator.class, new ViolatedAssumptionAnswer());
        when(mockIterator.hasNext()).thenReturn(true, true, false);
        when(mockIterator.next()).thenReturn(null, null);
        
        BoundedIterator<Predicate<Object>> boundedIterator = new BoundedIterator<>(mockIterator, 1031L, 1031L);
        try {
            boundedIterator.remove();
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            assertEquals("remove() cannot be called before calling next()", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testRemove_Succeeds_WhenCalledAfterNext() {
        Iterator<Closure<Integer>> mockIterator = mock(Iterator.class, new ViolatedAssumptionAnswer());
        Closure<Integer> mockClosure = NOPClosure.nopClosure();
        when(mockIterator.next()).thenReturn(mockClosure);
        
        BoundedIterator<Closure<Integer>> boundedIterator = new BoundedIterator<>(mockIterator, 0L, 909L);
        boundedIterator.next(); // Required before remove
        boundedIterator.remove(); // Should succeed without exception
    }

    // ================= Edge Case Tests =================

    @Test(timeout = 4000)
    public void testChainedBoundedIterators_ConstructSuccessfully() {
        Iterator<Closure<Integer>> mockIterator = mock(Iterator.class, new ViolatedAssumptionAnswer());
        when(mockIterator.hasNext()).thenReturn(true, false);
        when(mockIterator.next()).thenReturn(null);
        
        BoundedIterator<Closure<Integer>> firstIterator = new BoundedIterator<>(mockIterator, 1L, 5275L);
        BoundedIterator<Closure<Integer>> secondIterator = new BoundedIterator<>(firstIterator, 5275L, 0L);
        assertNotEquals(firstIterator, secondIterator);
    }
}