package com.google.gson.internal;

import org.junit.Test;

// Imports are cleaned up for clarity. The original test was generated by EvoSuite
// and contained numerous unused imports.

public class LinkedTreeMap_ESTestTest25 extends LinkedTreeMap_ESTest_scaffolding {

    /**
     * Tests that the internal `find` method, when used for insertion, throws an
     * {@code AssertionError} if it operates on a tree with a corrupt parent-child
     * link and triggers a complex rebalancing rotation.
     *
     * <p>This is a white-box test that intentionally creates a structurally inconsistent
     * tree by manually setting its root. The root node is given a parent that does not,
     * in turn, list the root as one of its children. This broken link is designed to
     * cause an assertion to fail deep within the tree's rotation logic (`replaceInParent`),
     * which is triggered by the sequence of insertions.
     */
    @Test(expected = AssertionError.class, timeout = 4000)
    public void findForInsertionOnCorruptTreeThrowsAssertionErrorDuringRebalance() {
        // ARRANGE: Create a LinkedTreeMap and manually set it to a corrupt state.
        LinkedTreeMap<Integer, Integer> map = new LinkedTreeMap<>();

        // A standalone node that will be improperly assigned as the root's parent.
        // This node does not have any children.
        LinkedTreeMap.Node<Integer, Integer> rogueParent = new LinkedTreeMap.Node<>(true);

        // A node that will be manually installed as the tree's root.
        // We link it to the rogueParent, creating the inconsistency.
        Integer rootKey = 1995;
        LinkedTreeMap.Node<Integer, Integer> rootNode = new LinkedTreeMap.Node<>(
                true, rogueParent, rootKey, rogueParent, rogueParent);

        // Manually set the root, establishing the corrupt state.
        // Now, rootNode.parent points to rogueParent, but rogueParent's children are null.
        map.root = rootNode;

        // ACT: Perform insertions designed to trigger a rebalancing rotation that
        // exposes the corrupt parent-child link.
        
        // The first insertion adds a new node and updates tree heights but does not rotate.
        map.put(-1170, -1170);

        // The second insertion, via the internal find(key, create=true) method,
        // makes the tree unbalanced at the root. This triggers a rotation that calls
        // `replaceInParent(rootNode, ...)`. The logic in `replaceInParent` fails
        // an assertion because it cannot find `rootNode` as a child of `rogueParent`.
        Integer keyToTriggerRotation = -985;
        map.find(keyToTriggerRotation, true); // This is expected to throw.
    }
}