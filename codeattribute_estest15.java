package org.apache.commons.compress.harmony.unpack200.bytecode;

import org.junit.Test;

import java.util.Collections;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import org.apache.commons.compress.harmony.unpack200.Segment;

/**
 * This test class has been refactored for improved understandability.
 * The original test was auto-generated by EvoSuite.
 */
public class CodeAttribute_ESTestTest15 extends CodeAttribute_ESTest_scaffolding {

    /**
     * Tests that the CodeAttribute constructor throws an IndexOutOfBoundsException
     * when processing a bytecode with a branch target that points outside the
     * valid range of bytecode offsets.
     */
    @Test
    public void constructorWithInvalidBranchTargetThrowsIndexOutOfBounds() {
        // Arrange

        // The GOTO_W bytecode (opcode 0xA3) requires a branch target operand.
        // We will provide a target that is intentionally out of bounds.
        final byte GOTO_W_OPCODE = (byte) 0xA3; // -93 in decimal
        final byte NOP_OPCODE = 0x00;
        final byte[] packedCode = {GOTO_W_OPCODE, NOP_OPCODE};

        // The OperandManager provides the operands for bytecodes. We set it up
        // to return an invalid branch target when requested.
        final int invalidBranchTarget = 106;
        int[] branchOperands = {invalidBranchTarget};

        // The OperandManager constructor is complex. For this test, only the first
        // array (for branch targets) is relevant. The others can be empty.
        int[] emptyIntArray = new int[0];
        OperandManager operandManager = new OperandManager(
                branchOperands, emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray,
                emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray,
                emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray,
                emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray, emptyIntArray,
                emptyIntArray
        );

        // Other parameters required by the CodeAttribute constructor.
        final int arbitraryMaxStack = 1717;
        final int arbitraryMaxLocals = 1717;
        final List<ExceptionTableEntry> emptyExceptionTable = Collections.emptyList();
        final Segment segment = null; // Not used for this part of the constructor's logic.

        // Act & Assert
        try {
            new CodeAttribute(arbitraryMaxStack, arbitraryMaxLocals, packedCode, segment, operandManager, emptyExceptionTable);
            fail("Expected an IndexOutOfBoundsException because the branch target is invalid.");
        } catch (IndexOutOfBoundsException e) {
            // The constructor builds a list of bytecode offsets. For our `packedCode`, this list
            // will have a small size (e.g., 2). The GOTO_W instruction's attempt to resolve
            // its target index (106) on this small list causes the exception.
            String expectedMessageFragment = "Index: 106";
            assertTrue(
                "Exception message should indicate the invalid index. Got: " + e.getMessage(),
                e.getMessage().contains(expectedMessageFragment)
            );

            // The original test verified the exception came from ArrayList, which is a good check
            // to ensure the failure is happening where expected (i.e., accessing the offsets list).
            assertEquals("java.util.ArrayList", e.getStackTrace()[0].getClassName());
        } catch (Throwable e) {
            fail("Caught an unexpected exception type: " + e.getClass().getName());
        }
    }
}