package org.apache.commons.collections4.sequence;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;

/**
 * This test suite provides a comprehensive, data-driven check for the
 * {@link SequencesComparator} class.
 *
 * <p>It is based on the "Shadok" language from a French animation series, which has a
 * simple four-word alphabet. The test generates a large set of "sentences" (sequences of words)
 * of varying lengths. It then exhaustively compares every sentence with every other sentence,
 * ensuring that the edit script generated by {@link SequencesComparator} can correctly
* transform the source sentence into the target sentence.</p>
 */
public class SequencesComparatorShadokTest {

    /** The four words in the fictional Shadok alphabet. */
    private static final String[] SHADOK_ALPHABET = {"GA", "BU", "ZO", "MEU"};

    /** The maximum length of sentences to generate for the test. */
    private static final int MAX_SENTENCE_LENGTH = 5;

    /**
     * A test-specific implementation of {@link CommandVisitor} that applies an
     * {@link EditScript} to a sequence, effectively transforming it.
     *
     * @param <T> the type of elements in the sequence.
     */
    private static final class ScriptExecutor<T> implements CommandVisitor<T> {

        private List<T> sequence;
        private int currentIndex;

        /**
         * Sets the initial sequence to be transformed.
         *
         * @param sequence the list to be modified by the script.
         */
        public void setSequence(final List<T> sequence) {
            this.sequence = sequence;
            this.currentIndex = 0;
        }

        /**
         * Returns the sequence after all commands have been visited.
         *
         * @return the transformed list.
         */
        public List<T> getTransformedSequence() {
            return sequence;
        }

        @Override
        public void visitDeleteCommand(final T object) {
            sequence.remove(currentIndex);
        }

        @Override
        public void visitInsertCommand(final T object) {
            sequence.add(currentIndex++, object);
        }

        @Override
        public void visitKeepCommand(final T object) {
            currentIndex++;
        }
    }

    /**
     * Generates all possible sentences up to a given maximum length using the Shadok alphabet.
     *
     * @param maxLength the maximum length of the sentences to generate.
     * @return a list containing all generated sentences, including the empty one.
     */
    private List<List<String>> generateShadokSentences(final int maxLength) {
        final List<List<String>> allSentences = new ArrayList<>();
        List<List<String>> sentencesOfCurrentLength = new ArrayList<>();

        // Start with an empty sentence (length 0)
        sentencesOfCurrentLength.add(new ArrayList<>());
        allSentences.addAll(sentencesOfCurrentLength);

        // Generate sentences for lengths 1 up to maxLength - 1
        for (int i = 1; i < maxLength; i++) {
            final List<List<String>> sentencesOfNextLength = new ArrayList<>();
            for (final List<String> sentence : sentencesOfCurrentLength) {
                for (final String word : SHADOK_ALPHABET) {
                    final List<String> newSentence = new ArrayList<>(sentence);
                    newSentence.add(word);
                    sentencesOfNextLength.add(newSentence);
                }
            }
            allSentences.addAll(sentencesOfNextLength);
            sentencesOfCurrentLength = sentencesOfNextLength;
        }
        return allSentences;
    }

    @Test
    void testScriptApplicationOnGeneratedShadokSentences() {
        // This test generates a large number of sentences (sequences of words)
        // and verifies that for any pair of sentences (source, target),
        // applying the computed edit script to the source sentence correctly
        // transforms it into the target sentence.
        final List<List<String>> allSentences = generateShadokSentences(MAX_SENTENCE_LENGTH);

        final ScriptExecutor<String> executor = new ScriptExecutor<>();

        for (final List<String> sourceSentence : allSentences) {
            for (final List<String> targetSentence : allSentences) {
                // Set up the executor with a mutable copy of the source sentence
                executor.setSequence(new ArrayList<>(sourceSentence));

                // Compute the script and apply it to the source sentence
                final SequencesComparator<String> comparator =
                        new SequencesComparator<>(sourceSentence, targetSentence);
                comparator.getScript().visit(executor);

                // Verify that the transformed source is now identical to the target
                assertEquals(targetSentence, executor.getTransformedSequence(),
                             () -> "Failed to transform " + sourceSentence + " to " + targetSentence);
            }
        }
    }
}