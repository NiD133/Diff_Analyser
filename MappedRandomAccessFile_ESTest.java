/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability and maintainability
 */
package com.itextpdf.text.pdf;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.itextpdf.text.pdf.MappedRandomAccessFile;
import java.io.FileNotFoundException;
import java.io.IOException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
) 
public class MappedRandomAccessFile_ESTest extends MappedRandomAccessFile_ESTest_scaffolding {

    // Test constants for magic numbers
    private static final long NEGATIVE_FILE_POSITION = -1934028355L;
    private static final long LARGE_FILE_POSITION = 1073741824L;
    private static final int TEST_BUFFER_SIZE = 9;
    private static final int TEST_OFFSET = -1458;
    private static final int TEST_LENGTH = 642;

    //---------------- Constructor Tests ----------------//
    @Test(timeout = 4000)
    public void testConstructorWithNullFilenameThrowsNullPointerException() throws Throwable {
        // Test that constructor throws NPE when filename is null
        try {
            MappedRandomAccessFile file = new MappedRandomAccessFile(null, "rw");
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithUnsupportedModeThrowsIOException() throws Throwable {
        // Setup file with content
        EvoSuiteFile testFile = new EvoSuiteFile("testFile");
        FileSystemHandling.appendStringToFile(testFile, "test content");
        
        // Test that constructor throws IOException for unsupported mode
        try {
            MappedRandomAccessFile file = new MappedRandomAccessFile("testFile", "unsupportedMode");
            fail("Expected IOException");
        } catch (IOException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithInvalidModeThrowsFileNotFoundException() throws Throwable {
        // Test that constructor throws FileNotFoundException for invalid mode
        try {
            MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "invalidMode");
            fail("Expected FileNotFoundException");
        } catch (FileNotFoundException e) {
            // Expected exception
        }
    }

    //---------------- clean() Method Tests ----------------//
    @Test(timeout = 4000)
    public void testCleanWithHeapByteBufferReturnsFalse() {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(2089);
        assertFalse(MappedRandomAccessFile.clean(buffer));
    }

    @Test(timeout = 4000)
    public void testCleanWithNullBufferReturnsFalse() {
        assertFalse(MappedRandomAccessFile.clean(null));
    }

    @Test(timeout = 4000)
    public void testCleanWithDirectByteBufferReturnsTrue() {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocateDirect(0);
        assertTrue(MappedRandomAccessFile.clean(buffer));
    }

    //---------------- getFilePointer() Tests ----------------//
    @Test(timeout = 4000)
    public void testGetFilePointerInitiallyZero() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        assertEquals("Initial file pointer should be 0", 0L, file.getFilePointer());
    }

    @Test(timeout = 4000)
    public void testGetFilePointerAfterPositiveSeek() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(686L);
        assertEquals(686L, file.getFilePointer());
    }

    @Test(timeout = 4000)
    public void testGetFilePointerAfterNegativeSeek() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(-2756L);
        assertEquals(-2756L, file.getFilePointer());
    }

    //---------------- read() Method Tests ----------------//
    @Test(timeout = 4000)
    public void testReadByteAtBeginningReturnsMinusOneForEmptyFile() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        assertEquals("Should return -1 for empty file", -1, file.read());
    }

    @Test(timeout = 4000)
    public void testReadByteAtLargePositionReturnsMinusOne() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(LARGE_FILE_POSITION);
        assertEquals("Should return -1 beyond file end", -1, file.read());
    }

    @Test(timeout = 4000)
    public void testReadByteAtNegativePositionThrowsException() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(NEGATIVE_FILE_POSITION);
        
        try {
            file.read();
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected exception
        }
    }

    //---------------- read(byte[], int, int) Tests ----------------//
    @Test(timeout = 4000)
    public void testReadBufferWithLengthBeyondFileSizeReturnsMinusOne() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        byte[] buffer = new byte[TEST_BUFFER_SIZE];
        int read = file.read(buffer, 0, 105);
        assertEquals("Should return -1 for empty file", -1, read);
    }

    @Test(timeout = 4000)
    public void testReadBufferWithZeroLengthReturnsMinusOne() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        byte[] buffer = new byte[TEST_BUFFER_SIZE];
        int read = file.read(buffer, -56, 0);
        assertEquals("Should return -1 for zero-length read", -1, read);
    }

    @Test(timeout = 4000)
    public void testReadWithNullBufferAtNegativePositionReturnsMinusOne() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(NEGATIVE_FILE_POSITION);
        int read = file.read(null, (int) NEGATIVE_FILE_POSITION, -1458);
        assertEquals("Should return -1", -1, read);
    }

    @Test(timeout = 4000)
    public void testReadAtPositionBeyondFileSizeReturnsMinusOne() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(LARGE_FILE_POSITION);
        byte[] buffer = new byte[TEST_BUFFER_SIZE];
        int read = file.read(buffer, TEST_OFFSET, TEST_LENGTH);
        assertEquals("Should return -1 beyond file end", -1, read);
    }

    @Test(timeout = 4000)
    public void testReadWithNegativeOffsetThrowsArrayIndexOutOfBounds() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.seek(NEGATIVE_FILE_POSITION);
        byte[] buffer = new byte[0];
        
        try {
            file.read(buffer, (int) NEGATIVE_FILE_POSITION, 841);
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected exception
        }
    }

    //---------------- getChannel() Tests ----------------//
    @Test(timeout = 4000)
    public void testGetChannelOnOpenFile() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        assertNotNull("Channel should be available", file.getChannel());
    }

    @Test(timeout = 4000)
    public void testGetChannelAfterClose() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.close();
        assertNotNull("Channel should still be accessible after close", file.getChannel());
    }

    //---------------- close() Method Tests ----------------//
    @Test(timeout = 4000)
    public void testCloseThrowsIOExceptionWhenSimulated() throws Throwable {
        // Simulate IO exceptions for file operations
        FileSystemHandling.shouldAllThrowIOExceptions();
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        
        try {
            file.close();
            fail("Expected IOException");
        } catch (IOException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testCloseTwiceDoesNotThrowException() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.close();
        file.close();  // Should not throw any exception
    }

    //---------------- finalize() Method Tests ----------------//
    @Test(timeout = 4000)
    public void testFinalizeThrowsIOExceptionWhenSimulated() throws Throwable {
        // Simulate IO exceptions for file operations
        FileSystemHandling.shouldAllThrowIOExceptions();
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        
        try {
            file.finalize();
            fail("Expected IOException");
        } catch (IOException e) {
            // Expected exception
        }
    }

    @Test(timeout = 4000)
    public void testFinalizeSucceedsUnderNormalConditions() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.finalize();  // Should not throw any exception
    }

    //---------------- Other Functionality Tests ----------------//
    @Test(timeout = 4000)
    public void testFileLength() throws Throwable {
        MappedRandomAccessFile file = new MappedRandomAccessFile("rw", "rw");
        file.length();  // Basic smoke test
    }
}