/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:59:13 GMT 2025
 */

package org.apache.commons.compress.harmony.unpack200;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import org.apache.commons.compress.harmony.unpack200.CpBands;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPool;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class SegmentConstantPool_ESTest extends SegmentConstantPool_ESTest_scaffolding {

    private static final SegmentConstantPool POOL_WITH_NULL_BANDS = new SegmentConstantPool(null);

    // Tests for index conversion utilities: toIntExact and toIndex
    @Test(timeout = 4000)
    public void testToIntExact_WithZero_ReturnsZero() {
        assertEquals(0, SegmentConstantPool.toIntExact(0L));
    }

    @Test(timeout = 4000)
    public void testToIntExact_WithNegative_ReturnsNegative() {
        assertEquals(-119, SegmentConstantPool.toIntExact(-119L));
    }

    @Test(timeout = 4000)
    public void testToIntExact_WithPositive_ReturnsPositive() {
        assertEquals(1, SegmentConstantPool.toIntExact(1L));
    }

    @Test(timeout = 4000)
    public void testToIntExact_WithLargeValue_ThrowsIOException() throws IOException {
        try {
            SegmentConstantPool.toIntExact(4294967294L);
            fail("Expected IOException for overflow");
        } catch (IOException e) {
            assertEquals("index", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testToIndex_WithZero_ReturnsZero() {
        assertEquals(0, SegmentConstantPool.toIndex(0L));
    }

    @Test(timeout = 4000)
    public void testToIndex_WithPositive_ReturnsPositive() {
        assertEquals(1, SegmentConstantPool.toIndex(1L));
    }

    @Test(timeout = 4000)
    public void testToIndex_WithNegative_ThrowsIOException() {
        try {
            SegmentConstantPool.toIndex(-1975L);
            fail("Expected IOException for negative index");
        } catch (IOException e) {
            assertEquals("Cannot have a negative index.", e.getMessage());
        }
    }

    // Tests for regex matching utility
    @Test(timeout = 4000)
    public void testRegexMatches_WithAllPattern_MatchesAnyString() {
        assertTrue(SegmentConstantPool.regexMatches(".*", "any string"));
    }

    @Test(timeout = 4000)
    public void testRegexMatches_WithInitPattern_MatchesInitStrings() {
        assertTrue(SegmentConstantPool.regexMatches("^<init>.*", "<init>abc"));
    }

    @Test(timeout = 4000)
    public void testRegexMatches_WithInitPattern_DoesNotMatchNonInitStrings() {
        assertFalse(SegmentConstantPool.regexMatches("^<init>.*", "non-init"));
        assertFalse(SegmentConstantPool.regexMatches("^<init>.*", ""));
    }

    @Test(timeout = 4000)
    public void testRegexMatches_WithNullString_ThrowsNullPointerException() {
        try {
            SegmentConstantPool.regexMatches("^<init>.*", null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testRegexMatches_WithUnsupportedPattern_ThrowsError() {
        try {
            SegmentConstantPool.regexMatches("unsupported", "test");
            fail("Expected Error for unsupported pattern");
        } catch (Error e) {
            assertEquals("regex trying to match a pattern I don't know: unsupported", e.getMessage());
        }
    }

    // Tests for constant pool entry matching
    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithNullArray_ThrowsNullPointerException() {
        try {
            POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(null, null, 5);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithEmptyArray_ReturnsNotFound() {
        String[] array = new String[0];
        assertEquals(-1, POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(array, "test", 0));
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithMatchingElement_ReturnsIndex() {
        String[] array = new String[]{"a", "b", "c"};
        assertEquals(1, POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(array, "b", 0));
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithDuplicateElements_ReturnsCorrectIndex() {
        String[] array = new String[]{"a", "b", "b", "c"};
        assertEquals(2, POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(array, "b", 1));
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithNoMatch_ReturnsNotFound() {
        String[] array = new String[4];
        assertEquals(-1, POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(array, "missing", 0));
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithInitPatternInArray_MatchesCorrectly() {
        String[] array = new String[8];
        array[1] = "^<init>.*";
        assertEquals(1, POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(array, "^<init>.*", 0));
    }

    @Test(timeout = 4000)
    public void testMatchSpecificPoolEntryIndex_WithMultipleCriteria_ReturnsMatchingIndex() {
        String[] primary = new String[]{"classA", "classB", "classA"};
        String[] secondary = new String[]{"methodX", "methodY", "methodZ"};
        int index = POOL_WITH_NULL_BANDS.matchSpecificPoolEntryIndex(
            primary, secondary, "classA", "methodZ", 1
        );
        assertEquals(2, index);
    }

    // Tests for getValue method
    @Test(timeout = 4000)
    public void testGetValue_WithUnsupportedType_ThrowsError() {
        try {
            POOL_WITH_NULL_BANDS.getValue(-282, 4294967296L);
            fail("Expected Error for unsupported type");
        } catch (Error e) {
            assertEquals("Tried to get a value I don't know about: -282", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetValue_WithNegativeRange_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getValue(7, -460L);
            fail("Expected IOException for negative range");
        } catch (IOException e) {
            assertEquals("Cannot have a negative range", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetValue_WithNullBands_ThrowsNullPointerException() {
        int[] unsupportedTypes = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        for (int type : unsupportedTypes) {
            try {
                POOL_WITH_NULL_BANDS.getValue(type, 1);
                fail("Expected NullPointerException for type: " + type);
            } catch (NullPointerException e) {
                // Expected for all types when bands are null
            }
        }
    }

    @Test(timeout = 4000)
    public void testGetValue_WithType12_ReturnsNull() {
        assertNull(POOL_WITH_NULL_BANDS.getValue(12, -1L));
    }

    // Tests for constant pool entry retrieval
    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithUnsupportedType_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getConstantPoolEntry(-13, 1152L);
            fail("Expected IOException for unsupported type");
        } catch (IOException e) {
            assertEquals("Type is not supported yet: -13", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithNegativeIndex_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getConstantPoolEntry(0, -1988L);
            fail("Expected IOException for negative index");
        } catch (IOException e) {
            assertEquals("Cannot have a negative index.", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithNullBands_ThrowsNullPointerException() {
        int[] typesCausingNPE = {1, 2, 3, 4, 5, 6, 7, 10, 11, 12};
        for (int type : typesCausingNPE) {
            try {
                POOL_WITH_NULL_BANDS.getConstantPoolEntry(type, 1L);
                fail("Expected NullPointerException for type: " + type);
            } catch (NullPointerException e) {
                // Expected
            }
        }
    }

    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithType9_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getConstantPoolEntry(9, 4);
            fail("Expected IOException for unsupported type 9");
        } catch (IOException e) {
            assertEquals("Type CP_DESCR is not supported yet: 9", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithType8_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getConstantPoolEntry(8, 8);
            fail("Expected IOException for unsupported type 8");
        } catch (IOException e) {
            assertEquals("Type SIGNATURE is not supported yet: 8", e.getMessage());
        }
    }

    // Tests for initialization method handling
    @Test(timeout = 4000)
    public void testGetInitMethodPoolEntry_WithNonMethodType_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getInitMethodPoolEntry(3120, 3120, "Tried to get a value I don't know about: ");
            fail("Expected IOException for non-method type");
        } catch (IOException e) {
            assertEquals("Nothing but CP_METHOD can be an <init>", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetInitMethodPoolEntry_WithMethodTypeAndNullBands_ThrowsNullPointerException() {
        try {
            POOL_WITH_NULL_BANDS.getInitMethodPoolEntry(11, 11, "o");
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    // Tests for class-specific entry retrieval
    @Test(timeout = 4000)
    public void testGetClassSpecificPoolEntry_WithUnsupportedType_ThrowsIOException() {
        try {
            POOL_WITH_NULL_BANDS.getClassSpecificPoolEntry(-1734632697, -1734632697, "^<init>.*");
            fail("Expected IOException for unsupported type");
        } catch (IOException e) {
            assertEquals("Type is not supported yet: -1734632697", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetClassSpecificPoolEntry_WithNullBands_ThrowsNullPointerException() {
        int[] typesCausingNPE = {10, 11, 12};
        for (int type : typesCausingNPE) {
            try {
                POOL_WITH_NULL_BANDS.getClassSpecificPoolEntry(type, 1, "test");
                fail("Expected NullPointerException for type: " + type);
            } catch (NullPointerException e) {
                // Expected
            }
        }
    }

    // Additional edge case tests
    @Test(timeout = 4000)
    public void testGetClassPoolEntry_WithNullBands_ThrowsNullPointerException() {
        try {
            POOL_WITH_NULL_BANDS.getClassPoolEntry("f(`.fI");
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testGetConstantPoolEntry_WithNegativeType_ReturnsNull() {
        assertNull(POOL_WITH_NULL_BANDS.getConstantPoolEntry(-1, -1));
    }
}