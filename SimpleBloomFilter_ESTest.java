/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:26:20 GMT 2025
 */

package org.apache.commons.collections4.bloomfilter;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.function.IntPredicate;
import java.util.function.LongPredicate;
import org.apache.commons.collections4.bloomfilter.BitMapExtractor;
import org.apache.commons.collections4.bloomfilter.BloomFilter;
import org.apache.commons.collections4.bloomfilter.CellExtractor;
import org.apache.commons.collections4.bloomfilter.CountingLongPredicate;
import org.apache.commons.collections4.bloomfilter.EnhancedDoubleHasher;
import org.apache.commons.collections4.bloomfilter.Hasher;
import org.apache.commons.collections4.bloomfilter.IndexExtractor;
import org.apache.commons.collections4.bloomfilter.IndexFilter;
import org.apache.commons.collections4.bloomfilter.LayerManager;
import org.apache.commons.collections4.bloomfilter.LayeredBloomFilter;
import org.apache.commons.collections4.bloomfilter.LongBiPredicate;
import org.apache.commons.collections4.bloomfilter.Shape;
import org.apache.commons.collections4.bloomfilter.SimpleBloomFilter;
import org.apache.commons.collections4.bloomfilter.SparseBloomFilter;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class SimpleBloomFilter_ESTest extends SimpleBloomFilter_ESTest_scaffolding {

    private static final int MAX_VALUE = Integer.MAX_VALUE;

    @Test(timeout = 4000)
    public void testMergeIndexExtractorWithIndexOutOfRangeThrowsException() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(1, 1540);
        int[] indices = {5023, 0, 0, 0, 0, 0, 0, 0};
        IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(indices);
        
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
            () -> filter.merge(indexExtractor));
        assertEquals("IndexExtractor should only send values in the range[0,1540)", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeHasherThenMergeSparseBloomFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(19, 19);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        SparseBloomFilter sparseFilter = new SparseBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(19, 2654L);

        // Act
        boolean mergedHasher = filter.merge(hasher);
        boolean mergedSparse = filter.merge(sparseFilter);

        // Assert
        assertTrue(mergedHasher);
        assertTrue(mergedSparse);
    }

    @Test(timeout = 4000)
    public void testMergeHasherThenMergeSelfAsBitMapExtractor() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(78, 78, 2);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(1L, Long.MIN_VALUE);

        // Act
        boolean mergedHasher = filter.merge(hasher);
        boolean mergedSelf = filter.merge((BitMapExtractor) filter);

        // Assert
        assertTrue(mergedHasher);
        assertTrue(mergedSelf);
    }

    @Test(timeout = 4000)
    public void testMergeHasherOnEmptyFilterThenCheckNotEmpty() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(64, 64);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(Integer.MAX_VALUE, 0L);

        // Act
        boolean mergeResult = filter.merge(hasher);
        boolean isEmpty = filter.isEmpty();

        // Assert
        assertTrue(mergeResult);
        assertFalse(isEmpty);
    }

    @Test(timeout = 4000)
    public void testMergeHasherThenCheckCardinalityAndFullness() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(115, 115, 2);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(1L, Long.MIN_VALUE);

        // Act
        filter.merge(hasher);
        boolean isFull = filter.isFull();
        int cardinality = filter.cardinality();

        // Assert
        assertFalse(isFull);
        assertEquals(2, cardinality);
    }

    @Test(timeout = 4000)
    public void testProcessIndicesWithArrayTracker() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(78, 78, 2);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        IndexFilter.ArrayTracker tracker = new IndexFilter.ArrayTracker(shape);

        // Act
        boolean result = filter.processIndices(tracker);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testProcessBitMapsWithNegatedCountingLongPredicate() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(3419, 3419, 1);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        long[] bitMapArray = new long[3];
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(false).when(biPredicate).test(anyLong(), anyLong());
        CountingLongPredicate countingPredicate = new CountingLongPredicate(bitMapArray, biPredicate);
        LongPredicate negatedPredicate = countingPredicate.negate();

        // Act
        boolean result = filter.processBitMaps(negatedPredicate);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testProcessBitMapsWithEmptyFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(10, 10);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        long[] bitMapArray = new long[1];
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(false).when(biPredicate).test(anyLong(), anyLong());
        CountingLongPredicate countingPredicate = new CountingLongPredicate(bitMapArray, biPredicate);

        // Act
        boolean result = filter.processBitMaps(countingPredicate);

        // Assert
        assertFalse(result);
    }

    @Test(timeout = 4000)
    public void testProcessBitMapPairsWithLayeredFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(51, 51);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(true, false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(true).when(biPredicate).test(anyLong(), anyLong());

        // Act
        boolean result = filter.processBitMapPairs(layeredFilter, biPredicate);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testMergeSelfAsIndexExtractor() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(22, 22);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        boolean result = filter.merge((IndexExtractor) filter);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testGetShapeFromLayeredFilter() throws Throwable {
        // Arrange
        Shape expectedShape = Shape.fromNM(294, 294);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(expectedShape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act
        Shape actualShape = filter.getShape();

        // Assert
        assertEquals(expectedShape.estimateMaxN(), actualShape.estimateMaxN(), 0.01);
    }

    @Test(timeout = 4000)
    public void testContainsWithEmptyLayeredFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(64, 64, 1);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        boolean contains = filter.contains((IndexExtractor) layeredFilter);

        // Assert
        assertFalse(contains);
    }

    @Test(timeout = 4000)
    public void testCharacteristics() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(4, 4);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        int characteristics = filter.characteristics();

        // Assert
        assertEquals(0, characteristics);
    }

    @Test(timeout = 4000)
    public void testMergeHasherThenCheckCardinalityAndEmptiness() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(38, 38);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(38, 38);

        // Act
        boolean mergeResult = filter.merge(hasher);
        int cardinality = filter.cardinality();
        boolean isEmpty = filter.isEmpty();

        // Assert
        assertTrue(mergeResult);
        assertEquals(1, cardinality);
        assertFalse(isEmpty);
    }

    @Test(timeout = 4000)
    public void testProcessIndicesThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        IndexFilter.ArrayTracker tracker = new IndexFilter.ArrayTracker(largeShape);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> filter.processIndices(tracker));
    }

    @Test(timeout = 4000)
    public void testProcessIndicesThrowsOnNullConsumer() {
        // Arrange
        Shape shape = Shape.fromNM(38, 38);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.processIndices(null));
        assertEquals("consumer", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testProcessBitMapsThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        long[] bitMapArray = new long[0];
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(false).when(biPredicate).test(anyLong(), anyLong());
        CountingLongPredicate countingPredicate = new CountingLongPredicate(bitMapArray, biPredicate);
        LongPredicate negatedPredicate = countingPredicate.negate();

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> filter.processBitMaps(negatedPredicate));
    }

    @Test(timeout = 4000)
    public void testProcessBitMapsThrowsOnNullConsumer() {
        // Arrange
        Shape shape = Shape.fromKM(1, 1);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.processBitMaps(null));
        assertEquals("consumer", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testProcessBitMapPairsThrowsOnNullPredicate() {
        // Arrange
        Shape shape = Shape.fromNMK(15, 15, 15);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        assertThrows(NullPointerException.class, 
            () -> filter.processBitMapPairs(filter, null));
    }

    @Test(timeout = 4000)
    public void testMergeSelfAsIndexExtractorThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, 
            () -> filter.merge((IndexExtractor) filter));
    }

    @Test(timeout = 4000)
    public void testMergeIndexExtractorThrowsOnNull() {
        // Arrange
        Shape shape = Shape.fromKM(668, 668);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.merge((IndexExtractor) null));
        assertEquals("indexExtractor", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeHasherThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromKM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(MAX_VALUE, MAX_VALUE);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> filter.merge(hasher));
    }

    @Test(timeout = 4000)
    public void testMergeHasherThrowsOnNull() {
        // Arrange
        Shape shape = Shape.fromKM(56, 56);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.merge((Hasher) null));
        assertEquals("hasher", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeBloomFilterThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, 
            () -> filter.merge((BloomFilter<?>) filter));
    }

    @Test(timeout = 4000)
    public void testMergeBloomFilterThrowsOnNull() {
        // Arrange
        Shape shape = Shape.fromNM(38, 38);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.merge((BloomFilter<?>) null));
        assertEquals("other", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeBloomFilterWithIncompatibleShape() {
        // Arrange
        Shape shape1 = Shape.fromKM(49, 5906);
        Shape shape2 = Shape.fromKM(49, 49);
        SimpleBloomFilter filter1 = new SimpleBloomFilter(shape1);
        SimpleBloomFilter filter2 = new SimpleBloomFilter(shape2);

        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
            () -> filter2.merge(filter1));
        assertEquals("BitMapExtractor should send at most 1 maps", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeBitMapExtractorThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        SparseBloomFilter sparseFilter = new SparseBloomFilter(largeShape);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, 
            () -> filter.merge((BitMapExtractor) sparseFilter));
    }

    @Test(timeout = 4000)
    public void testMergeBitMapExtractorThrowsOnNull() {
        // Arrange
        Shape shape = Shape.fromKM(1, 1);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> filter.merge((BitMapExtractor) null));
        assertEquals("bitMapExtractor", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeBitMapExtractorWithInvalidMapCount() {
        // Arrange
        Shape shape = Shape.fromKM(20, 20);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(filter, 283);

        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
            () -> filter.merge(bitMapExtractor));
        assertEquals("BitMapExtractor should send at most 1 maps", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testIsEmptyThrowsAfterMergeOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(-154L, MAX_VALUE);
        filter.merge(hasher);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, filter::isEmpty);
    }

    @Test(timeout = 4000)
    public void testCopy() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter original = new SimpleBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(MAX_VALUE, 1047039L);

        // Act
        SimpleBloomFilter copy = original.copy();

        // Assert
        assertNotSame(original, copy);
    }

    @Test(timeout = 4000)
    public void testContainsThrowsOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        CellExtractor cellExtractor = CellExtractor.from(filter);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, 
            () -> filter.contains((IndexExtractor) cellExtractor));
    }

    @Test(timeout = 4000)
    public void testContainsThrowsOnNull() {
        // Arrange
        Shape shape = Shape.fromKM(668, 668);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        assertThrows(NullPointerException.class, 
            () -> filter.contains((IndexExtractor) null));
    }

    @Test(timeout = 4000)
    public void testContainsThrowsOnInvalidIndex() {
        // Arrange
        Shape shape = Shape.fromNM(10, 10);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        int[] indices = {977, 0, 0, 0, 0, 0, 0, 0};
        IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(indices);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, 
            () -> filter.contains(indexExtractor));
    }

    @Test(timeout = 4000)
    public void testCardinalityThrowsAfterMergeOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(MAX_VALUE, MAX_VALUE);
        filter.merge(hasher);

        // Act & Assert
        assertThrows(ArrayIndexOutOfBoundsException.class, filter::cardinality);
    }

    @Test(timeout = 4000)
    public void testConstructorThrowsOnNullShape() {
        // Act & Assert
        NullPointerException exception = assertThrows(NullPointerException.class, 
            () -> new SimpleBloomFilter(null));
        assertEquals("shape", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeSelfAsBitMapExtractor() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(64, 64);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act
        boolean result = filter.merge((BitMapExtractor) filter);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testProcessBitMapPairsWithNegatedPredicate() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(28, 28);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(filter, -1);
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(false).when(biPredicate).test(anyLong(), anyLong());

        // Act
        boolean result = filter.processBitMapPairs(bitMapExtractor, biPredicate);

        // Assert
        assertFalse(result);
    }

    @Test(timeout = 4000)
    public void testProcessBitMapPairsWithEmptyFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(294, 294);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();
        LongBiPredicate biPredicate = mock(LongBiPredicate.class);
        doReturn(false).when(biPredicate).test(anyLong(), anyLong());

        // Act
        boolean result = filter.processBitMapPairs(filter, biPredicate);

        // Assert
        assertFalse(result);
    }

    @Test(timeout = 4000)
    public void testMergeHasherWithIndexOutOfRangeThrowsException() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(655, 1);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(655, 655);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
            () -> filter.merge(hasher));
        assertEquals("IndexExtractor should only send values in the range[0,1)", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeIndexExtractorWithNegativeIndexThrowsException() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(10, 10);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        int[] indices = {0, 0, -89, 0, 0};
        IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(indices);

        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, 
            () -> filter.merge(indexExtractor));
        assertEquals("IndexExtractor should only send values in the range[0,10)", exception.getMessage());
    }

    @Test(timeout = 4000)
    public void testMergeSparseBloomFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(2, 2);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        SparseBloomFilter sparseFilter = new SparseBloomFilter(shape);

        // Act
        boolean result = filter.merge(sparseFilter);

        // Assert
        assertTrue(result);
    }

    @Test(timeout = 4000)
    public void testMergeEmptyBloomFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(19, 19, 19);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        boolean result = filter.merge(filter);
        boolean isEmpty = filter.isEmpty();
        int characteristics = filter.characteristics();

        // Assert
        assertTrue(result);
        assertTrue(isEmpty);
        assertEquals(0, characteristics);
    }

    @Test(timeout = 4000)
    public void testIsEmptyOnEmptyFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(294, 294);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act
        boolean isEmpty = filter.isEmpty();

        // Assert
        assertTrue(isEmpty);
    }

    @Test(timeout = 4000)
    public void testMergeSelfThenCheckCardinality() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(15, 15, 15);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        boolean result = filter.merge(filter);
        int cardinality = filter.cardinality();
        int characteristics = filter.characteristics();

        // Assert
        assertTrue(result);
        assertEquals(0, cardinality);
        assertEquals(0, characteristics);
    }

    @Test(timeout = 4000)
    public void testAsBitMapArrayOnLargeShape() {
        // Arrange
        Shape largeShape = Shape.fromNM(MAX_VALUE, MAX_VALUE);
        SimpleBloomFilter filter = new SimpleBloomFilter(largeShape);

        // Act
        long[] bitMapArray = filter.asBitMapArray();

        // Assert
        assertEquals(33554432, bitMapArray.length);
    }

    @Test(timeout = 4000)
    public void testIsFullOnEmptyFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(294, 294);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act
        boolean isFull = filter.isFull();

        // Assert
        assertFalse(isFull);
    }

    @Test(timeout = 4000)
    public void testClear() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(23, 23);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);

        // Act
        filter.clear();

        // Assert
        assertEquals(0, filter.characteristics());
    }

    @Test(timeout = 4000)
    public void testProcessIndicesAfterMerge() throws Throwable {
        // Arrange
        Shape shape = Shape.fromKM(19, 19);
        SimpleBloomFilter filter = new SimpleBloomFilter(shape);
        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(1956L, -2388L);
        filter.merge(hasher);
        IndexFilter.ArrayTracker tracker = new IndexFilter.ArrayTracker(shape);
        IntPredicate negatedPredicate = tracker.negate();

        // Act
        boolean result = filter.processIndices(negatedPredicate);

        // Assert
        assertFalse(result);
    }

    @Test(timeout = 4000)
    public void testContainsSelfOnEmptyFilter() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNM(294, 294);
        LayerManager<SparseBloomFilter> layerManager = mock(LayerManager.class);
        doReturn(false).when(layerManager).processBloomFilters(any());
        LayeredBloomFilter<SparseBloomFilter> layeredFilter = new LayeredBloomFilter<>(shape, layerManager);
        SimpleBloomFilter filter = layeredFilter.flatten();

        // Act
        boolean contains = filter.contains((IndexExtractor) filter);

        // Assert
        assertTrue(contains);
    }

    @Test(timeout = 4000)
    public void testCopyCreatesNewInstance() throws Throwable {
        // Arrange
        Shape shape = Shape.fromNMK(78, 78, 2);
        SimpleBloomFilter original = new SimpleBloomFilter(shape);

        // Act
        SimpleBloomFilter copy = original.copy();

        // Assert
        assertNotSame(original, copy);
    }
}