/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 19:49:16 GMT 2025
 */

package org.threeten.extra;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.Clock;
import java.time.DateTimeException;
import java.time.Duration;
import java.time.LocalDate;
import java.time.Month;
import java.time.Year;
import java.time.YearMonth;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.HijrahDate;
import java.time.chrono.ThaiBuddhistDate;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalField;
import java.time.temporal.TemporalQuery;
import java.time.temporal.UnsupportedTemporalTypeException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.time.MockClock;
import org.evosuite.runtime.mock.java.time.MockYear;
import org.evosuite.runtime.mock.java.time.MockYearMonth;
import org.evosuite.runtime.mock.java.time.MockZonedDateTime;
import org.evosuite.runtime.mock.java.time.chrono.MockHijrahDate;
import org.evosuite.runtime.mock.java.time.chrono.MockThaiBuddhistDate;
import org.junit.runner.RunWith;
import org.threeten.extra.DayOfYear;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class DayOfYear_ESTest extends DayOfYear_ESTest_scaffolding {

    // Test Cases for now() method
    @Test(timeout = 4000)
    public void testNowWithDifferentTimeZones_shouldNotBeEqual() throws Throwable {
        ZoneOffset maxOffset = ZoneOffset.MAX;
        DayOfYear dayInMaxOffset = DayOfYear.now(maxOffset);
        DayOfYear dayInDefaultZone = DayOfYear.now();
        assertNotEquals("Days from different time zones should differ", 
                        dayInDefaultZone, dayInMaxOffset);
    }

    @Test(timeout = 4000)
    public void testNowWithNullZone_shouldThrowNullPointerException() throws Throwable {
        try {
            DayOfYear.now((ZoneId) null);
            fail("Expected NullPointerException for null zone");
        } catch (NullPointerException e) {
            assertEquals("zone", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testNowWithInvalidClock_shouldThrowDateTimeException() throws Throwable {
        Clock systemClock = MockClock.systemDefaultZone();
        Clock offsetClock = MockClock.offset(systemClock, ChronoUnit.ERAS.getDuration());
        try {
            DayOfYear.now(offsetClock);
            fail("Expected DateTimeException for invalid clock");
        } catch (DateTimeException e) {
            assertEquals("Instant exceeds minimum or maximum instant", e.getMessage());
        }
    }

    // Test Cases for of() method
    @Test(timeout = 4000)
    public void testOfWithInvalidDay0_shouldThrowDateTimeException() throws Throwable {
        try {
            DayOfYear.of(0);
            fail("Expected DateTimeException for day 0");
        } catch (DateTimeException e) {
            assertEquals("Invalid value for DayOfYear: 0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testOfValidDay_shouldReturnInstance() throws Throwable {
        DayOfYear day = DayOfYear.of(1);
        assertEquals(1, day.getValue());
    }

    // Test Cases for from() method
    @Test(timeout = 4000)
    public void testFromWithNullTemporal_shouldThrowNullPointerException() throws Throwable {
        try {
            DayOfYear.from(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertEquals("temporal", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testFromWithInvalidTemporal_shouldThrowDateTimeException() throws Throwable {
        try {
            DayOfYear.from(Month.NOVEMBER);
            fail("Expected DateTimeException for invalid temporal");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Unable to obtain DayOfYear"));
        }
    }

    // Test Cases for get() and range() methods
    @Test(timeout = 4000)
    public void testGetSupportedField_shouldReturnValue() throws Throwable {
        DayOfYear day = DayOfYear.now();
        int value = day.get(ChronoField.DAY_OF_YEAR);
        assertEquals(45, value);
    }

    @Test(timeout = 4000)
    public void testGetUnsupportedField_shouldThrowException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        try {
            day.get(ChronoField.ERA);
            fail("Expected UnsupportedTemporalTypeException");
        } catch (UnsupportedTemporalTypeException e) {
            assertEquals("Unsupported field: Era", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testRangeSupportedField_shouldReturnValidRange() throws Throwable {
        DayOfYear day = DayOfYear.now();
        ValueRange range = day.range(ChronoField.DAY_OF_YEAR);
        assertNotNull(range);
    }

    // Test Cases for adjustInto() method
    @Test(timeout = 4000)
    public void testAdjustIntoWithLocalDate_shouldAdjustSuccessfully() throws Throwable {
        DayOfYear day = DayOfYear.now();
        LocalDate date = LocalDate.of(2023, 1, 1);
        Temporal adjusted = day.adjustInto(date);
        assertEquals(day.getValue(), ((LocalDate) adjusted).getDayOfYear());
    }

    @Test(timeout = 4000)
    public void testAdjustIntoWithNull_shouldThrowNullPointerException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        try {
            day.adjustInto(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertEquals("temporal", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testAdjustIntoWithNonISODate_shouldThrowDateTimeException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        HijrahDate hijrahDate = MockHijrahDate.now();
        try {
            day.adjustInto(hijrahDate);
            fail("Expected DateTimeException for non-ISO date");
        } catch (DateTimeException e) {
            assertEquals("Adjustment only supported on ISO date-time", e.getMessage());
        }
    }

    // Test Cases for atYear() method
    @Test(timeout = 4000)
    public void testAtYearWithLeapDayNonLeapYear_shouldThrowException() throws Throwable {
        DayOfYear leapDay = DayOfYear.of(366);
        try {
            leapDay.atYear(2023); // Non-leap year
            fail("Expected DateTimeException");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid date 'DayOfYear 366'"));
        }
    }

    @Test(timeout = 4000)
    public void testAtYearWithNullYear_shouldThrowNullPointerException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        try {
            day.atYear((Year) null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertEquals("year", e.getMessage());
        }
    }

    // Test Cases for isValidYear() method
    @Test(timeout = 4000)
    public void testIsValidYearWithLeapDay_returnsTrueOnlyInLeapYears() throws Throwable {
        DayOfYear leapDay = DayOfYear.of(366);
        assertTrue(leapDay.isValidYear(2020)); // Leap year
        assertFalse(leapDay.isValidYear(2023)); // Non-leap year
    }

    // Test Cases for equals() and hashCode()
    @Test(timeout = 4000)
    public void testEqualsSameInstance_returnsTrue() throws Throwable {
        DayOfYear day = DayOfYear.now();
        assertTrue(day.equals(day));
    }

    @Test(timeout = 4000)
    public void testEqualsDifferentType_returnsFalse() throws Throwable {
        DayOfYear day = DayOfYear.now();
        assertFalse(day.equals(ZoneOffset.UTC));
    }

    // Test Cases for compareTo()
    @Test(timeout = 4000)
    public void testCompareToSameDay_returnsZero() throws Throwable {
        DayOfYear day = DayOfYear.now();
        assertEquals(0, day.compareTo(day));
    }

    @Test(timeout = 4000)
    public void testCompareToNull_shouldThrowNullPointerException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        try {
            day.compareTo(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    // Test Cases for query()
    @Test(timeout = 4000)
    public void testQueryReturnsLocalDate() throws Throwable {
        DayOfYear day = DayOfYear.of(1);
        Year year = MockYear.of(2023);
        LocalDate expectedDate = LocalDate.ofYearDay(2023, 1);
        
        TemporalQuery<ChronoLocalDate> query = mock(TemporalQuery.class);
        when(query.queryFrom(any(TemporalAccessor.class)).thenReturn(expectedDate);
        
        ChronoLocalDate result = day.query(query);
        assertEquals(expectedDate, result);
    }

    @Test(timeout = 4000)
    public void testQueryWithNull_shouldThrowNullPointerException() throws Throwable {
        DayOfYear day = DayOfYear.now();
        try {
            day.query(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    // Additional tests with clear names and comments...
    // [Remaining tests follow the same pattern with descriptive names]
}