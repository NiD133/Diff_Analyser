/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability
 */
package com.google.common.io;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.io.ByteSource;
import com.google.common.io.MultiInputStream;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
) 
public class MultiInputStream_ESTest extends MultiInputStream_ESTest_scaffolding {

    // ========================================================================
    // Constructor Validation Tests
    // ========================================================================

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void constructor_throwsNullPointerExceptionWhenIteratorIsNull() {
        new MultiInputStream((Iterator<? extends ByteSource>) null);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void constructor_throwsNullPointerExceptionWhenElementIsNull() {
        ArrayList<ByteSource> list = new ArrayList<>();
        list.add(null);
        new MultiInputStream(list.iterator());
    }

    @Test(timeout = 4000, expected = ConcurrentModificationException.class)
    public void constructor_throwsConcurrentModificationExceptionWhenModifiedDuringCreation() {
        ByteSource source = ByteSource.empty();
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        Iterator<ByteSource> iterator = deque.iterator();
        deque.add(source); // Modify after iterator creation
        new MultiInputStream(iterator);
    }

    // ========================================================================
    // Basic Read Operation Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void read_returnsMinusOneForEmptyIterator() {
        MultiInputStream stream = new MultiInputStream(new ArrayDeque<ByteSource>().iterator());
        assertEquals(-1, stream.read());
    }

    @Test(timeout = 4000)
    public void read_returnsFirstByteFromSingleSource() {
        byte[] data = new byte[]{(byte) -98};
        ByteSource source = ByteSource.wrap(data);
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        MultiInputStream stream = new MultiInputStream(deque.iterator());
        assertEquals(158, stream.read()); // -98 becomes unsigned 158
    }

    @Test(timeout = 4000)
    public void read_returnsMinusOneAfterExhaustingSources() {
        LinkedList<ByteSource> list = new LinkedList<>();
        MultiInputStream stream = new MultiInputStream(list.descendingIterator());
        byte[] buffer = new byte[7];
        assertEquals(-1, stream.read(buffer, 0, 387));
    }

    @Test(timeout = 4000)
    public void read_returnsZeroByteFromNonEmptySource() {
        LinkedList<ByteSource> list = new LinkedList<>();
        byte[] data = new byte[8];
        list.add(ByteSource.wrap(data));
        MultiInputStream stream = new MultiInputStream(list.descendingIterator());
        assertEquals(0, stream.read());
    }

    // ========================================================================
    // Skip Operation Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void skip_returnsZeroForZeroRequest() {
        ByteSource source = ByteSource.empty();
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        MultiInputStream stream = new MultiInputStream(deque.iterator());
        assertEquals(0L, stream.skip(0));
    }

    @Test(timeout = 4000)
    public void skip_returnsZeroForNegativeRequest() {
        LinkedList<ByteSource> list = new LinkedList<>();
        byte[] data = new byte[8];
        list.add(ByteSource.wrap(data));
        MultiInputStream stream = new MultiInputStream(list.descendingIterator());
        assertEquals(0L, stream.skip(-896L));
    }

    @Test(timeout = 4000)
    public void skip_handlesMultipleSourcesCorrectly() {
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        ByteSource[] sources = new ByteSource[3];
        sources[0] = ByteSource.empty();
        sources[1] = ByteSource.wrap(new byte[6]);
        sources[2] = ByteSource.empty();
        deque.add(ByteSource.concat(sources));
        MultiInputStream stream = new MultiInputStream(deque.iterator());
        assertEquals(6L, stream.skip(60)); // Skips all 6 bytes
    }

    @Test(timeout = 4000)
    public void skip_returnsZeroWhenSkippingBeyondEmptySource() {
        ByteSource source = ByteSource.empty();
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        MultiInputStream stream = new MultiInputStream(deque.iterator());
        assertEquals(0L, stream.skip(2173L));
    }

    // ========================================================================
    // Edge Case and Exception Tests
    // ========================================================================

    @Test(timeout = 4000, expected = ConcurrentModificationException.class)
    public void skip_throwsConcurrentModificationWhenModifiedDuringOperation() {
        ByteSource source = ByteSource.empty();
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        deque.add(source);
        Iterator<ByteSource> iterator = deque.iterator();
        MultiInputStream stream = new MultiInputStream(iterator);
        deque.add(source); // Modify during operation
        stream.skip(4134L);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void read_throwsNullPointerExceptionForNullBuffer() {
        MultiInputStream stream = new MultiInputStream(new ArrayDeque<ByteSource>().iterator());
        stream.read(null, -332, -332);
    }

    @Test(timeout = 4000, expected = IndexOutOfBoundsException.class)
    public void read_throwsIndexOutOfBoundsForInvalidBufferParameters() {
        ByteSource source = ByteSource.empty();
        LinkedList<ByteSource> list = new LinkedList<>();
        list.add(source);
        MultiInputStream stream = new MultiInputStream(list.descendingIterator());
        byte[] buffer = new byte[0];
        stream.read(buffer, 408, 408); // Invalid parameters
    }

    @Test(timeout = 4000, expected = ConcurrentModificationException.class)
    public void read_throwsConcurrentModificationWhenModifiedDuringIteration() {
        ArrayList<ByteSource> list = new ArrayList<>();
        ByteSource source = ByteSource.empty();
        list.add(source);
        ListIterator<ByteSource> iterator = list.listIterator();
        MultiInputStream stream = new MultiInputStream(iterator);
        LinkedHashSet<ByteSource> set = new LinkedHashSet<>();
        set.add(source);
        list.addAll(set); // Modify during iteration
        stream.read();
    }

    // ========================================================================
    // Special Behavior Tests
    // ========================================================================

    @Test(timeout = 4000)
    public void close_succeedsWithoutException() {
        ByteSource source = ByteSource.empty();
        ArrayDeque<ByteSource> deque = new ArrayDeque<>();
        deque.add(source);
        MultiInputStream stream = new MultiInputStream(deque.iterator());
        stream.close();
        assertFalse(stream.markSupported());
    }

    @Test(timeout = 4000)
    public void markSupported_alwaysReturnsFalse() {
        MultiInputStream stream = new MultiInputStream(new LinkedList<ByteSource>().descendingIterator());
        assertFalse(stream.markSupported());
    }

    @Test(timeout = 4000)
    public void available_returnsZeroForEmptyIterator() {
        MultiInputStream stream = new MultiInputStream(new ArrayDeque<ByteSource>().iterator());
        assertEquals(0, stream.available());
    }

    @Test(timeout = 4000)
    public void available_returnsBytesFromCurrentSource() {
        LinkedList<ByteSource> list = new LinkedList<>();
        list.add(ByteSource.wrap(new byte[8]));
        MultiInputStream stream = new MultiInputStream(list.descendingIterator());
        assertEquals(8, stream.available());
    }
}