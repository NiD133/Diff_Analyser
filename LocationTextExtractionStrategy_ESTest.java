/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 16:27:54 GMT 2025
 */

package com.itextpdf.text.pdf.parser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.itextpdf.text.pdf.CMapAwareDocumentFont;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfOCProperties;
import com.itextpdf.text.pdf.PdfSigLockDictionary;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.parser.GraphicsState;
import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.InlineImageInfo;
import com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy;
import com.itextpdf.text.pdf.parser.MarkedContentInfo;
import com.itextpdf.text.pdf.parser.Matrix;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.text.pdf.parser.Vector;
import java.nio.charset.IllegalCharsetNameException;
import java.util.Collection;
import java.util.LinkedList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class LocationTextExtractionStrategy_ESTest extends LocationTextExtractionStrategy_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, (-2030.0F), 0.0F);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 0.0F);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk1 = new LocationTextExtractionStrategy.TextChunk("Lm", vector0, vector0, 2);
      float float0 = locationTextExtractionStrategy_TextChunk0.distanceFromEndOf(locationTextExtractionStrategy_TextChunk1);
      assertEquals(0.0F, float0, 0.01F);
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunk1.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Vector vector0 = new Vector((-555.0505F), (-555.0505F), (-555.0505F));
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-3318.408F));
      Vector vector1 = new Vector(0, (-3318.408F), 1);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector1, 0.0F);
      int int0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.compareTo((LocationTextExtractionStrategy.TextChunkLocation) locationTextExtractionStrategy_TextChunkLocationDefaultImp1);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.getCharSpaceWidth(), 0.01F);
      assertEquals((-1372), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.orientationMagnitude());
      assertEquals(3192.0986F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelEnd(), 0.01F);
      assertEquals(641, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distPerpendicular());
      assertEquals(319.22217F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
      assertEquals(1, int0);
      assertEquals(555, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      byte[] byteArray0 = new byte[3];
      PdfSigLockDictionary.LockAction pdfSigLockDictionary_LockAction0 = PdfSigLockDictionary.LockAction.EXCLUDE;
      String[] stringArray0 = new String[0];
      PdfSigLockDictionary pdfSigLockDictionary0 = new PdfSigLockDictionary(pdfSigLockDictionary_LockAction0, stringArray0);
      InlineImageInfo inlineImageInfo0 = new InlineImageInfo(byteArray0, pdfSigLockDictionary0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForEmbeddedImage(graphicsState0, inlineImageInfo0, pdfSigLockDictionary0, linkedList0);
      Vector vector0 = imageRenderInfo0.getStartPoint();
      Vector vector1 = vector0.multiply(1163.3555F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector1, 7);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 4);
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp1.isAtWordBoundary(locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      assertEquals(1163.3555F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertFalse(boolean0);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distPerpendicular());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.orientationMagnitude());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      byte[] byteArray0 = new byte[3];
      PdfSigLockDictionary.LockAction pdfSigLockDictionary_LockAction0 = PdfSigLockDictionary.LockAction.EXCLUDE;
      String[] stringArray0 = new String[0];
      PdfSigLockDictionary pdfSigLockDictionary0 = new PdfSigLockDictionary(pdfSigLockDictionary_LockAction0, stringArray0);
      InlineImageInfo inlineImageInfo0 = new InlineImageInfo(byteArray0, pdfSigLockDictionary0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForEmbeddedImage(graphicsState0, inlineImageInfo0, pdfSigLockDictionary0, linkedList0);
      Vector vector0 = imageRenderInfo0.getStartPoint();
      Vector vector1 = vector0.multiply(180.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 4);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector0, 5);
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.isAtWordBoundary(locationTextExtractionStrategy_TextChunkLocationDefaultImp1);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertFalse(boolean0);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals((-180.0F), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Vector vector0 = new Vector((-53.7697F), 1000.0F, 1000.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 0);
      Vector vector1 = new Vector(1.089F, (-53.7697F), 1.089F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector1, 0);
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.sameLine(locationTextExtractionStrategy_TextChunkLocationDefaultImp1);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.orientationMagnitude());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.getCharSpaceWidth(), 0.01F);
      assertEquals(53, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distPerpendicular());
      assertFalse(boolean0);
      assertEquals(1.089F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
      assertEquals(1.089F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelEnd(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Vector vector0 = new Vector(905.5172F, 905.5172F, 905.5172F);
      Vector vector1 = new Vector(0.0F, (-1162.3555F), 1.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector1, (-2442.038F));
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector0, (-1906.0F));
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.sameLine(locationTextExtractionStrategy_TextChunkLocationDefaultImp1);
      assertEquals(1162, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(432, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distPerpendicular());
      assertEquals(1158, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.orientationMagnitude());
      assertEquals(1443.9287F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelEnd(), 0.01F);
      assertEquals((-1906.0F), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.getCharSpaceWidth(), 0.01F);
      assertFalse(boolean0);
      assertEquals((-987.98627F), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Vector vector0 = new Vector(551.0283F, Float.NaN, 0);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("CIDSystemInfo", vector0, vector0, 2);
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, (-2030.0F), 0.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 0);
      int int0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude();
      assertEquals(2030, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0, int0);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Vector vector0 = new Vector(1518.243F, 1518.243F, (-2451.2717F));
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-1477.5446F));
      locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getStartLocation();
      assertEquals(1518.243F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(1518.243F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals((-1477.5446F), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals((-1518), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, 226.68376F, 0.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-703.80695F));
      locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getEndLocation();
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals((-226), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals((-703.80695F), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Vector vector0 = new Vector(1.0E-4F, 480.96F, 2.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 16.0301F);
      float float0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth();
      assertEquals(1.0E-4F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(16.0301F, float0, 0.01F);
      assertEquals((-480), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(1.0E-4F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, 0.0F, 0.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 0.0F);
      float float0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distanceFromEndOf(locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0.0F, float0, 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Vector vector0 = new Vector(3501.2126F, 3501.2126F, 3501.2126F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-408.0F));
      float float0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart();
      assertEquals(3501.2126F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(3501.2126F, float0, 0.01F);
      assertEquals((-3501), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals((-408.0F), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Vector vector0 = new Vector(92.34146F, 92.34146F, 92.34146F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 2);
      float float0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd();
      assertEquals(92.34146F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals((-92), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals(92.34146F, float0, 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Vector vector0 = new Vector(1128.28F, 1128.28F, 1128.28F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 1);
      int int0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.compareTo((LocationTextExtractionStrategy.TextChunkLocation) locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      assertEquals(1128.28F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(1.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals(1128.28F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(0, int0);
      assertEquals((-1128), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, 0.0F, 0.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-2505.027F));
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      boolean boolean0 = locationTextExtractionStrategy0.isChunkAtWordBoundary(locationTextExtractionStrategy_TextChunk0, locationTextExtractionStrategy_TextChunk0);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      graphicsState0.font = cMapAwareDocumentFont0;
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      PdfString pdfString0 = new PdfString("],", ".notdef");
      Matrix matrix0 = new Matrix(9, 1374.654F, 644.4266F, 23, 2, 3.1684228E7F);
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfString0, graphicsState0, matrix0, linkedList0);
      // Undeclared exception!
      try { 
        locationTextExtractionStrategy0.renderText(textRenderInfo0);
        fail("Expecting exception: IllegalCharsetNameException");
      
      } catch(IllegalCharsetNameException e) {
         //
         // .notdef
         //
         verifyException("java.nio.charset.Charset", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      // Undeclared exception!
      try { 
        locationTextExtractionStrategy0.renderText((TextRenderInfo) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      // Undeclared exception!
      try { 
        locationTextExtractionStrategy0.isChunkAtWordBoundary((LocationTextExtractionStrategy.TextChunk) null, (LocationTextExtractionStrategy.TextChunk) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = graphicsState0.getCtm();
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      doReturn((LocationTextExtractionStrategy.TextChunkLocation) null, (LocationTextExtractionStrategy.TextChunkLocation) null).when(locationTextExtractionStrategy_TextChunkLocationStrategy0).createLocation(any(com.itextpdf.text.pdf.parser.TextRenderInfo.class) , any(com.itextpdf.text.pdf.parser.LineSegment.class));
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      // Undeclared exception!
      try { 
        locationTextExtractionStrategy0.getResultantText((LocationTextExtractionStrategy.TextChunkFilter) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy$TextChunk", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      graphicsState0.font = cMapAwareDocumentFont0;
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      doReturn((LocationTextExtractionStrategy.TextChunkLocation) null, (LocationTextExtractionStrategy.TextChunkLocation) null).when(locationTextExtractionStrategy_TextChunkLocationStrategy0).createLocation(any(com.itextpdf.text.pdf.parser.TextRenderInfo.class) , any(com.itextpdf.text.pdf.parser.LineSegment.class));
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      // Undeclared exception!
      try { 
        locationTextExtractionStrategy0.getResultantText();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy$TextChunk", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      graphicsState0.font = cMapAwareDocumentFont0;
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      Vector vector0 = new Vector(1, 17, 19);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-2928.7646F));
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      doReturn(locationTextExtractionStrategy_TextChunkLocationDefaultImp0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0).when(locationTextExtractionStrategy_TextChunkLocationStrategy0).createLocation(any(com.itextpdf.text.pdf.parser.TextRenderInfo.class) , any(com.itextpdf.text.pdf.parser.LineSegment.class));
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      String string0 = locationTextExtractionStrategy0.getResultantText((LocationTextExtractionStrategy.TextChunkFilter) null);
      assertEquals(" ", string0);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals((-17), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(1.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      LocationTextExtractionStrategy.DUMP_STATE = true;
      LocationTextExtractionStrategy.TextChunkFilter locationTextExtractionStrategy_TextChunkFilter0 = mock(LocationTextExtractionStrategy.TextChunkFilter.class, new ViolatedAssumptionAnswer());
      String string0 = locationTextExtractionStrategy0.getResultantText(locationTextExtractionStrategy_TextChunkFilter0);
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Vector vector0 = new Vector((-2327.809F), (-1220.9F), 0.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 2);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy$TextChunk", locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      LocationTextExtractionStrategy.TextChunkLocation locationTextExtractionStrategy_TextChunkLocation0 = locationTextExtractionStrategy_TextChunk0.getLocation();
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocation0.orientationMagnitude());
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunkLocation0.getCharSpaceWidth(), 0.01F);
      assertEquals(1220, locationTextExtractionStrategy_TextChunkLocation0.distPerpendicular());
      assertEquals((-2327.809F), locationTextExtractionStrategy_TextChunkLocation0.distParallelStart(), 0.01F);
      assertEquals((-2327.809F), locationTextExtractionStrategy_TextChunkLocation0.distParallelEnd(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, (-2030.0F), 0.0F);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 0.0F);
      Vector vector1 = new Vector(0.0F, 0.0F, (-2030.0F));
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk1 = new LocationTextExtractionStrategy.TextChunk("Lm", vector1, vector1, 2);
      int int0 = locationTextExtractionStrategy_TextChunk0.compareTo(locationTextExtractionStrategy_TextChunk1);
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunk1.getCharSpaceWidth(), 0.01F);
      assertEquals(1, int0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Vector vector0 = new Vector(0.6494578F, 0.6494578F, 0.6494578F);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 0);
      Vector vector1 = new Vector(0.6494578F, 0, 0);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk1 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector1, 2);
      int int0 = locationTextExtractionStrategy_TextChunk1.compareTo(locationTextExtractionStrategy_TextChunk0);
      assertEquals((-1), int0);
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunk1.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      Vector vector0 = new Vector(1.0E-4F, 480.96F, 2.0F);
      Vector vector1 = vector0.multiply(16.0301F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector0, (-435.7F));
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      boolean boolean0 = locationTextExtractionStrategy0.isChunkAtWordBoundary(locationTextExtractionStrategy_TextChunk0, locationTextExtractionStrategy_TextChunk0);
      assertEquals((-1570), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertFalse(boolean0);
      assertEquals((-480.96417F), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals((-435.7F), locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Vector vector0 = new Vector(2.0F, 2.0F, 175.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, (-5.186149E-6F));
      Vector vector1 = new Vector(175.0F, 2.0F, 175.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector1, 0);
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp0.isAtWordBoundary(locationTextExtractionStrategy_TextChunkLocationDefaultImp1);
      assertTrue(boolean0);
      assertEquals(175.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelEnd(), 0.01F);
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(2.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
      assertEquals((-2), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Vector vector0 = new Vector(905.5172F, 905.5172F, 905.5172F);
      Vector vector1 = new Vector(0.0F, (-1162.3555F), 1.0F);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector1, (-2442.038F));
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp1 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector1, vector0, (-1906.0F));
      boolean boolean0 = locationTextExtractionStrategy_TextChunkLocationDefaultImp1.sameLine(locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      assertEquals(432, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distPerpendicular());
      assertEquals(1158, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.orientationMagnitude());
      assertEquals((-987.98627F), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelStart(), 0.01F);
      assertEquals(1443.9287F, locationTextExtractionStrategy_TextChunkLocationDefaultImp1.distParallelEnd(), 0.01F);
      assertEquals(1162, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertFalse(boolean0);
      assertEquals((-1906.0F), locationTextExtractionStrategy_TextChunkLocationDefaultImp1.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Vector vector0 = new Vector(898.6386F, 898.6386F, 898.6386F);
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      graphicsState0.rise = (float) 3;
      Matrix matrix0 = graphicsState0.getCtm();
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      graphicsState0.font = cMapAwareDocumentFont0;
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 12);
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      doReturn(locationTextExtractionStrategy_TextChunkLocationDefaultImp0).when(locationTextExtractionStrategy_TextChunkLocationStrategy0).createLocation(any(com.itextpdf.text.pdf.parser.TextRenderInfo.class) , any(com.itextpdf.text.pdf.parser.LineSegment.class));
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      assertEquals(12.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.getCharSpaceWidth(), 0.01F);
      assertEquals((-898), locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(898.6386F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(898.6386F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      String string0 = locationTextExtractionStrategy0.getResultantText();
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = graphicsState0.getCtm();
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      Matrix matrix1 = new Matrix(341.6828F, (-9.18953F), 5, 23, 6, 3);
      TextRenderInfo textRenderInfo1 = new TextRenderInfo(pdfDate0, graphicsState0, matrix1, linkedList0);
      locationTextExtractionStrategy0.renderText(textRenderInfo1);
      String string0 = locationTextExtractionStrategy0.getResultantText();
      assertEquals("\n", string0);
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      LocationTextExtractionStrategy.TextChunkFilter locationTextExtractionStrategy_TextChunkFilter0 = mock(LocationTextExtractionStrategy.TextChunkFilter.class, new ViolatedAssumptionAnswer());
      doReturn(true).when(locationTextExtractionStrategy_TextChunkFilter0).accept(any(com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.class));
      String string0 = locationTextExtractionStrategy0.getResultantText(locationTextExtractionStrategy_TextChunkFilter0);
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      LocationTextExtractionStrategy.TextChunkFilter locationTextExtractionStrategy_TextChunkFilter0 = mock(LocationTextExtractionStrategy.TextChunkFilter.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(locationTextExtractionStrategy_TextChunkFilter0).accept(any(com.itextpdf.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.class));
      String string0 = locationTextExtractionStrategy0.getResultantText(locationTextExtractionStrategy_TextChunkFilter0);
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      PdfDictionary pdfDictionary0 = new PdfDictionary();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForXObject(graphicsState0, (PdfIndirectReference) null, pdfDictionary0);
      Vector vector0 = imageRenderInfo0.getStartPoint();
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 1114.7446F);
      locationTextExtractionStrategy_TextChunk0.getEndLocation();
      assertEquals(1114.7446F, locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      byte[] byteArray0 = new byte[3];
      PdfSigLockDictionary.LockAction pdfSigLockDictionary_LockAction0 = PdfSigLockDictionary.LockAction.EXCLUDE;
      String[] stringArray0 = new String[0];
      PdfSigLockDictionary pdfSigLockDictionary0 = new PdfSigLockDictionary(pdfSigLockDictionary_LockAction0, stringArray0);
      InlineImageInfo inlineImageInfo0 = new InlineImageInfo(byteArray0, pdfSigLockDictionary0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForEmbeddedImage(graphicsState0, inlineImageInfo0, pdfSigLockDictionary0, linkedList0);
      Vector vector0 = imageRenderInfo0.getStartPoint();
      LocationTextExtractionStrategy.TextChunkLocationDefaultImp locationTextExtractionStrategy_TextChunkLocationDefaultImp0 = new LocationTextExtractionStrategy.TextChunkLocationDefaultImp(vector0, vector0, 7);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("distParallel: ", locationTextExtractionStrategy_TextChunkLocationDefaultImp0);
      locationTextExtractionStrategy_TextChunk0.getText();
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distPerpendicular());
      assertEquals(0, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.orientationMagnitude());
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelStart(), 0.01F);
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunkLocationDefaultImp0.distParallelEnd(), 0.01F);
      assertEquals(7.0F, locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      GraphicsState graphicsState0 = new GraphicsState();
      PdfDictionary pdfDictionary0 = new PdfDictionary();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForXObject(graphicsState0, (PdfIndirectReference) null, pdfDictionary0);
      Vector vector0 = imageRenderInfo0.getStartPoint();
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 1114.7446F);
      float float0 = locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth();
      assertEquals(1114.7446F, float0, 0.01F);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Vector vector0 = new Vector(0.0F, (-2030.0F), 0.0F);
      LocationTextExtractionStrategy.TextChunk locationTextExtractionStrategy_TextChunk0 = new LocationTextExtractionStrategy.TextChunk("", vector0, vector0, 0.0F);
      locationTextExtractionStrategy_TextChunk0.getStartLocation();
      assertEquals(0.0F, locationTextExtractionStrategy_TextChunk0.getCharSpaceWidth(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.endTextBlock();
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      LocationTextExtractionStrategy.TextChunkLocationStrategy locationTextExtractionStrategy_TextChunkLocationStrategy0 = mock(LocationTextExtractionStrategy.TextChunkLocationStrategy.class, new ViolatedAssumptionAnswer());
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy(locationTextExtractionStrategy_TextChunkLocationStrategy0);
      locationTextExtractionStrategy0.beginTextBlock();
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      GraphicsState graphicsState0 = new GraphicsState();
      PdfSigLockDictionary.LockPermissions pdfSigLockDictionary_LockPermissions0 = PdfSigLockDictionary.LockPermissions.FORM_FILLING;
      PdfSigLockDictionary pdfSigLockDictionary0 = new PdfSigLockDictionary(pdfSigLockDictionary_LockPermissions0);
      java.util.Vector<MarkedContentInfo> vector0 = new java.util.Vector<MarkedContentInfo>();
      ImageRenderInfo imageRenderInfo0 = ImageRenderInfo.createForXObject(graphicsState0, (PdfIndirectReference) null, (PdfDictionary) pdfSigLockDictionary0, (Collection<MarkedContentInfo>) vector0);
      locationTextExtractionStrategy0.renderImage(imageRenderInfo0);
      assertEquals(1.0F, imageRenderInfo0.getArea(), 0.01F);
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      PdfDate pdfDate0 = new PdfDate();
      GraphicsState graphicsState0 = new GraphicsState();
      Matrix matrix0 = new Matrix(8, 2);
      PdfOCProperties pdfOCProperties0 = new PdfOCProperties();
      CMapAwareDocumentFont cMapAwareDocumentFont0 = new CMapAwareDocumentFont(pdfOCProperties0);
      LinkedList<MarkedContentInfo> linkedList0 = new LinkedList<MarkedContentInfo>();
      graphicsState0.font = cMapAwareDocumentFont0;
      TextRenderInfo textRenderInfo0 = new TextRenderInfo(pdfDate0, graphicsState0, matrix0, linkedList0);
      LocationTextExtractionStrategy locationTextExtractionStrategy0 = new LocationTextExtractionStrategy();
      locationTextExtractionStrategy0.renderText(textRenderInfo0);
      LocationTextExtractionStrategy.DUMP_STATE = true;
      String string0 = locationTextExtractionStrategy0.getResultantText();
      assertEquals("", string0);
  }
}
