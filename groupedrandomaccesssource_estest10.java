package com.itextpdf.text.io;

import org.junit.Test;

import java.io.IOException;
import java.nio.ByteBuffer;

import static org.evosuite.runtime.EvoAssertions.verifyException;
import static org.junit.Assert.fail;

/**
 * This class contains tests for {@link GroupedRandomAccessSource}, focusing on understandability.
 * The original test was generated by EvoSuite and has been refactored for clarity.
 */
public class GroupedRandomAccessSource_ESTestTest10 extends GroupedRandomAccessSource_ESTest_scaffolding {

    /**
     * Tests that a call to get() on a GroupedRandomAccessSource correctly delegates
     * to the underlying source that contains the target position.
     *
     * <p>This specific test verifies a scenario where the underlying source is a
     * {@link ByteBufferRandomAccessSource}, and its internal call to {@code ByteBuffer.position(int)}
     * fails with a {@link NoSuchMethodError}. This type of error can occur in environments with
     * classpath conflicts or when using mocking frameworks that don't fully mock the ByteBuffer API.
     * The test ensures that the exception from the underlying source propagates correctly through
     * the {@link GroupedRandomAccessSource}.</p>
     */
    @Test(timeout = 4000)
    public void getWithOffsetIntoByteBufferSourceShouldPropagateUnderlyingError() throws Throwable {
        // ARRANGE
        // Create a GroupedRandomAccessSource where the read operation will target
        // a ByteBufferRandomAccessSource that is not the first source in the group.

        // A small source to act as a prefix, ensuring the target source has a non-zero offset.
        RandomAccessSource prefixSource = new ArrayRandomAccessSource(new byte[8]); // length = 8

        // The source we want the 'get' operation to target.
        int byteBufferSourceLength = 1300;
        ByteBuffer byteBuffer = ByteBuffer.allocate(byteBufferSourceLength);
        RandomAccessSource byteBufferSource = new ByteBufferRandomAccessSource(byteBuffer); // length = 1300

        // Combine them. The byteBufferSource will cover the byte range [8, 1307].
        RandomAccessSource[] sources = {prefixSource, byteBufferSource};
        GroupedRandomAccessSource groupedSource = new GroupedRandomAccessSource(sources);

        // Parameters for the get() call, preserved from the original generated test.
        long readPosition = 1297L; // This position is inside byteBufferSource (1297 >= 8).
        byte[] destinationBuffer = new byte[2];
        int invalidBufferOffset = -1228; // This invalid offset would normally cause an exception,
                                         // but the NoSuchMethodError is expected to occur first.
        int readLength = 1297;

        // ACT & ASSERT
        try {
            groupedSource.get(readPosition, destinationBuffer, invalidBufferOffset, readLength);
            fail("Expected a NoSuchMethodError to be thrown due to a missing ByteBuffer.position(int) method.");
        } catch (NoSuchMethodError e) {
            // Assert that the expected NoSuchMethodError is thrown and that it originates
            // from the ByteBufferRandomAccessSource, confirming the call was delegated correctly.
            // The error message indicates a missing method: 'java.nio.ByteBuffer.position(I)Ljava/nio/ByteBuffer;'
            verifyException("com.itextpdf.text.io.ByteBufferRandomAccessSource", e);
        }
    }
}