package com.itextpdf.text.pdf;

import static org.junit.Assert.assertEquals;

import com.itextpdf.text.io.RandomAccessSourceFactory;
import java.io.IOException;
import org.junit.Test;

/**
 * Tests for the {@link RandomAccessFileOrArray} class, focusing on basic read operations.
 */
public class RandomAccessFileOrArrayTest {

    private static final int TEST_DATA_SIZE = 10000;

    /**
     * Verifies that the read() method correctly reads all bytes sequentially from a
     * byte array-backed source.
     */
    @Test
    public void read_fromByteArraySource_readsAllBytesSequentially() throws IOException {
        // Arrange: Create a source byte array and wrap it with the class under test.
        byte[] sourceData = generateSequentialTestData(TEST_DATA_SIZE);
        RandomAccessFileOrArray fileOrArray = new RandomAccessFileOrArray(
            new RandomAccessSourceFactory().createSource(sourceData)
        );

        // Act & Assert: Read bytes one by one and verify they match the source data.
        for (int i = 0; i < sourceData.length; i++) {
            int readByte = fileOrArray.read();
            assertEquals(
                "Byte at index " + i + " should match the source data.",
                sourceData[i],
                (byte) readByte
            );
        }

        // Assert: Verify that reading past the end of the data returns -1 (EOF).
        assertEquals(
            "Reading beyond the end of the data should return -1.",
            -1,
            fileOrArray.read()
        );
    }

    /**
     * Generates a byte array with predictable, sequential data for testing.
     * The value at each index {@code i} is {@code (byte) i}.
     *
     * @param size The desired size of the byte array.
     * @return The generated byte array.
     */
    private byte[] generateSequentialTestData(int size) {
        byte[] data = new byte[size];
        for (int i = 0; i < size; i++) {
            // The original code used os.write(i), which only writes the low-order byte.
            // This is equivalent and more direct.
            data[i] = (byte) i;
        }
        return data;
    }
}