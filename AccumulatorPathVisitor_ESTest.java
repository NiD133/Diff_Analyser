/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 00:50:56 GMT 2025
 */

package org.apache.commons.io.file;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Pattern;
import org.apache.commons.io.file.AccumulatorPathVisitor;
import org.apache.commons.io.file.Counters;
import org.apache.commons.io.file.CountingPathVisitor;
import org.apache.commons.io.file.PathFilter;
import org.apache.commons.io.filefilter.CanExecuteFileFilter;
import org.apache.commons.io.filefilter.CanReadFileFilter;
import org.apache.commons.io.filefilter.CanWriteFileFilter;
import org.apache.commons.io.filefilter.HiddenFileFilter;
import org.apache.commons.io.filefilter.PrefixFileFilter;
import org.apache.commons.io.filefilter.RegexFileFilter;
import org.apache.commons.io.function.IOBiFunction;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockIOException;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AccumulatorPathVisitor_ESTest extends AccumulatorPathVisitor_ESTest_scaffolding {

    // =========================================================
    // = Constructor & Factory Method Tests (Grouped Together) =
    // =========================================================

    @Test(timeout = 4000)
    public void testFactoryWithBigIntegerCountersAndFilters() {
        // Test factory method with specific path filters
        CanReadFileFilter readFilter = CanReadFileFilter.CAN_READ;
        PrefixFileFilter prefixFilter = new PrefixFileFilter(new String[7]);
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withBigIntegerCounters(readFilter, prefixFilter);
        assertNotNull("Visitor should be created with filters", visitor);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testConstructorWithNullFileFilterThrowsNPE() {
        // Verify constructor throws NPE when fileFilter is null
        Counters.PathCounters counters = CountingPathVisitor.defaultPathCounters();
        new AccumulatorPathVisitor(counters, null, null);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testConstructorWithNullVisitFileFailedFunctionThrowsNPE() {
        // Verify constructor throws NPE when visitFileFailedFunction is null
        Counters.PathCounters counters = CountingPathVisitor.defaultPathCounters();
        CanWriteFileFilter filter = CanWriteFileFilter.CAN_WRITE;
        new AccumulatorPathVisitor(counters, filter, filter, null);
    }

    @Test(timeout = 4000)
    public void testConstructorWithFilters() {
        // Test successful creation with valid filters
        Counters.PathCounters counters = CountingPathVisitor.defaultPathCounters();
        CanExecuteFileFilter filter = CanExecuteFileFilter.CAN_EXECUTE;
        new AccumulatorPathVisitor(counters, filter, filter);
    }

    @Test(timeout = 4000)
    public void testBuilderConstructor() {
        // Test builder creation
        new AccumulatorPathVisitor.Builder();
    }

    // =============================================
    // = relativizeFiles Method Tests (Grouped)     =
    // =============================================

    @Test(timeout = 4000)
    public void testRelativizeFilesWithoutSorting() {
        // Verify relativizeFiles returns empty list when no files visited
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        MockFile mockFile = new MockFile("base", "file.txt");
        Path filePath = mockFile.toPath();
        
        Comparator<Object> comparator = mock(Comparator.class);
        List<Path> result = visitor.relativizeFiles(filePath, false, comparator);
        
        assertFalse("Should not contain base path", result.contains(filePath));
        assertTrue("Result should be empty", result.isEmpty());
    }

    @Test(timeout = 4000)
    public void testRelativizeFilesWithSortingAfterUpdate() throws IOException {
        // Verify relativizeFiles works after updating file counters
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        MockFile mockFile = new MockFile("", "test.txt");
        Path filePath = mockFile.toPath();
        
        BasicFileAttributes attrs = mock(BasicFileAttributes.class);
        when(attrs.size()).thenReturn(0L);
        visitor.updateFileCounters(filePath, attrs);
        
        Comparator<Object> comparator = mock(Comparator.class);
        List<Path> result = visitor.relativizeFiles(filePath, true, comparator);
        
        assertFalse("Should not contain original path", result.contains(filePath));
        assertEquals("Should have one relativized path", 1, result.size());
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void testRelativizeFilesWithDifferentPathThrowsException() throws IOException {
        // Verify relativizeFiles throws when using wrong base path
        HiddenFileFilter filter = HiddenFileFilter.HIDDEN;
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withBigIntegerCounters(filter, filter);
        
        // Create and visit a file
        MockFile visitedFile = new MockFile("dir", "file.txt");
        BasicFileAttributes attrs = mock(BasicFileAttributes.class);
        when(attrs.size()).thenReturn(0L);
        visitor.updateFileCounters(visitedFile.toPath(), attrs);
        
        // Try to relativize with different base path
        MockFile otherDir = new MockFile("other");
        visitor.relativizeFiles(otherDir.toPath(), true, mock(Comparator.class));
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testRelativizeFilesWithNullParentThrowsNPE() {
        // Verify NPE when parent path is null
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters();
        visitor.relativizeFiles(null, true, null);
    }

    // =================================================
    // = relativizeDirectories Method Tests (Grouped)   =
    // =================================================

    @Test(timeout = 4000)
    public void testRelativizeDirectoriesWithoutSorting() {
        // Verify relativizeDirectories returns empty list when no directories visited
        Pattern pattern = Pattern.compile(">");
        RegexFileFilter regexFilter = new RegexFileFilter(pattern);
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(null, regexFilter);
        
        MockFile mockFile = new MockFile("org/example");
        Path dirPath = mockFile.toPath();
        
        Comparator<Object> comparator = mock(Comparator.class);
        List<Path> result = visitor.relativizeDirectories(dirPath, false, comparator);
        
        assertTrue("Result should be empty", result.isEmpty());
    }

    @Test(timeout = 4000)
    public void testRelativizeDirectoriesAfterException() {
        // Verify directory is added to list even after visit exception
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        MockFile mockFile = new MockFile("dir");
        Path dirPath = mockFile.toPath();
        
        visitor.updateDirCounter(dirPath, new MockIOException());
        
        Comparator<Object> comparator = mock(Comparator.class);
        List<Path> result = visitor.relativizeDirectories(dirPath, false, comparator);
        
        assertEquals("Should contain one directory", 1, result.size());
    }

    @Test(timeout = 4000, expected = IllegalArgumentException.class)
    public void testRelativizeDirectoriesWithDifferentPathThrowsException() {
        // Verify exception when using wrong base path
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters();
        MockFile visitedDir = new MockFile("visited");
        visitor.updateDirCounter(visitedDir.toPath(), new MockIOException());
        
        MockFile otherDir = new MockFile("other");
        visitor.relativizeDirectories(otherDir.toPath(), true, null);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testRelativizeDirectoriesWithNullParentThrowsNPE() {
        // Verify NPE when parent path is null
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        visitor.relativizeDirectories(null, true, null);
    }

    // ======================================
    // = getFileList Method Tests (Grouped)  =
    // ======================================

    @Test(timeout = 4000)
    public void testGetFileListInitiallyEmpty() {
        // Verify new visitor has empty file list
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        assertTrue("File list should be empty", visitor.getFileList().isEmpty());
    }

    @Test(timeout = 4000)
    public void testGetFileListAfterVisit() throws IOException {
        // Verify file list contains visited file
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters();
        MockFile mockFile = new MockFile("test.txt");
        Path filePath = mockFile.toPath();
        
        BasicFileAttributes attrs = mock(BasicFileAttributes.class);
        when(attrs.size()).thenReturn(0L);
        visitor.updateFileCounters(filePath, attrs);
        
        List<Path> files = visitor.getFileList();
        assertFalse("File list should not be empty", files.isEmpty());
        assertEquals("Should contain one file", 1, files.size());
    }

    // =====================================
    // = getDirList Method Tests (Grouped)  =
    // =====================================

    @Test(timeout = 4000)
    public void testGetDirListInitiallyEmpty() {
        // Verify new visitor has empty directory list
        Counters.PathCounters counters = CountingPathVisitor.defaultPathCounters();
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor(counters);
        assertTrue("Directory list should be empty", visitor.getDirList().isEmpty());
    }

    @Test(timeout = 4000)
    public void testGetDirListAfterException() {
        // Verify directory is added to list after visit exception
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        MockFile mockFile = new MockFile("", "");
        Path dirPath = mockFile.toPath();
        
        visitor.updateDirCounter(dirPath, new MockIOException());
        
        List<Path> dirs = visitor.getDirList();
        assertEquals("Should contain one directory", 1, dirs.size());
    }

    // =================================
    // = equals Method Tests (Grouped)  =
    // =================================

    @Test(timeout = 4000)
    public void testEqualsWithSameInstance() {
        // Verify equals returns true for same instance
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withBigIntegerCounters();
        assertTrue("Should equal itself", visitor.equals(visitor));
    }

    @Test(timeout = 4000)
    public void testEqualsWithDifferentCounterTypes() {
        // Verify visitors with different counter types are equal
        AccumulatorPathVisitor longCounterVisitor = AccumulatorPathVisitor.withLongCounters();
        AccumulatorPathVisitor bigIntCounterVisitor = AccumulatorPathVisitor.withBigIntegerCounters();
        assertTrue("Visitors should be equal regardless of counter type", 
            longCounterVisitor.equals(bigIntCounterVisitor));
    }

    @Test(timeout = 4000)
    public void testEqualsAfterVisitFile() throws IOException {
        // Verify visitors differ after file visit
        AccumulatorPathVisitor visitor1 = new AccumulatorPathVisitor();
        AccumulatorPathVisitor visitor2 = new AccumulatorPathVisitor();
        
        MockFile mockFile = new MockFile("", "file.txt");
        BasicFileAttributes attrs = mock(BasicFileAttributes.class);
        when(attrs.size()).thenReturn(0L);
        visitor1.visitFile(mockFile.toPath(), attrs);
        
        assertFalse("Visitors should differ after file visit", visitor1.equals(visitor2));
    }

    @Test(timeout = 4000)
    public void testEqualsAfterPostVisitDirectoryException() {
        // Verify visitors differ after directory exception
        AccumulatorPathVisitor visitor1 = new AccumulatorPathVisitor();
        AccumulatorPathVisitor visitor2 = new AccumulatorPathVisitor();
        
        MockFile mockFile = new MockFile("dir");
        visitor1.postVisitDirectory(mockFile.toPath(), new MockIOException());
        
        assertFalse("Visitors should differ after directory exception", visitor1.equals(visitor2));
    }

    @Test(timeout = 4000)
    public void testEqualsWithDifferentType() {
        // Verify visitor doesn't equal different type
        AccumulatorPathVisitor visitor = new AccumulatorPathVisitor();
        CountingPathVisitor countingVisitor = CountingPathVisitor.withBigIntegerCounters();
        assertFalse("Should not equal different type", visitor.equals(countingVisitor));
    }

    @Test(timeout = 4000)
    public void testEqualsWithBuilder() {
        // Verify visitor doesn't equal builder
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.builder().get();
        assertFalse("Should not equal builder", visitor.equals(AccumulatorPathVisitor.builder()));
    }

    // ===================================
    // = hashCode Method Tests (Grouped)  =
    // ===================================

    @Test(timeout = 4000)
    public void testHashCodeDoesNotThrow() {
        // Verify hashCode doesn't throw exceptions
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withBigIntegerCounters();
        visitor.hashCode();  // Should not throw
    }

    // ===============================================
    // = updateCounters Method Tests (Grouped)        =
    // ===============================================

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testUpdateFileCountersWithNullAttributesThrowsNPE() {
        // Verify NPE when attributes are null
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters();
        MockFile mockFile = new MockFile("test.txt");
        visitor.updateFileCounters(mockFile.toPath(), null);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void testUpdateDirCounterWithNullPathThrowsNPE() {
        // Verify NPE when path is null
        AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withBigIntegerCounters();
        visitor.updateDirCounter(null, new MockIOException());
    }
}