/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 19:48:55 GMT 2025
 */

package org.threeten.extra.chrono;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.Clock;
import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.chrono.ChronoLocalDateTime;
import java.time.chrono.ChronoZonedDateTime;
import java.time.chrono.Era;
import java.time.chrono.HijrahEra;
import java.time.chrono.IsoEra;
import java.time.chrono.JapaneseEra;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalUnit;
import java.time.temporal.UnsupportedTemporalTypeException;
import java.time.temporal.ValueRange;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.time.MockClock;
import org.evosuite.runtime.mock.java.time.MockInstant;
import org.evosuite.runtime.mock.java.time.MockLocalDateTime;
import org.evosuite.runtime.mock.java.time.MockOffsetDateTime;
import org.junit.runner.RunWith;
import org.threeten.extra.chrono.EthiopicDate;
import org.threeten.extra.chrono.PaxDate;
import org.threeten.extra.chrono.Symmetry454Chronology;
import org.threeten.extra.chrono.Symmetry454Date;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class Symmetry454Chronology_ESTest extends Symmetry454Chronology_ESTest_scaffolding {

    private final Symmetry454Chronology chronology = new Symmetry454Chronology();

    @Test(timeout = 4000)
    public void testDateWithInvalidMonthThrowsException() throws Throwable {
        // Test that creating a date with an invalid month throws DateTimeException
        IsoEra era = IsoEra.BCE;
        try {
            chronology.date(era, 3322, -2136356788, 8);
            fail("Expected DateTimeException for invalid month");
        } catch (DateTimeException e) {
            assertEquals(
                "Invalid value for MonthOfYear (valid values 1 - 12): -2136356788",
                e.getMessage()
            );
        }
    }

    @Test(timeout = 4000)
    public void testZonedDateTimeFromInstant() throws Throwable {
        // Test creating a zoned date-time from an Instant
        ZoneOffset zone = ZoneOffset.UTC;
        Instant instant = MockInstant.ofEpochSecond(3L, 0L);
        ChronoZonedDateTime<Symmetry454Date> zdt = chronology.zonedDateTime(instant, zone);
        assertNotNull("ZonedDateTime should not be null", zdt);
    }

    @Test(timeout = 4000)
    public void testProlepticYearForBceEra() throws Throwable {
        // Test proleptic year calculation for BCE era
        int year = chronology.prolepticYear(IsoEra.BCE, 1996);
        assertEquals("Proleptic year should match BCE input", 1996, year);
    }

    @Test(timeout = 4000)
    public void testProlepticYearForCeEra() throws Throwable {
        // Test proleptic year calculation for CE era
        int year = chronology.prolepticYear(IsoEra.CE, -1390);
        assertEquals("Proleptic year should match CE input", -1390, year);
    }

    @Test(timeout = 4000)
    public void testLocalDateTimeFromLocalDateTime() throws Throwable {
        // Test conversion from LocalDateTime to ChronoLocalDateTime
        LocalDateTime ldt = MockLocalDateTime.now();
        ChronoLocalDateTime<Symmetry454Date> chronoLdt = chronology.localDateTime(ldt);
        assertNotNull("ChronoLocalDateTime should not be null", chronoLdt);
    }

    @Test(timeout = 4000)
    public void testIsLeapYearForYear3() throws Throwable {
        // Test that year 3 is identified as a leap year
        assertTrue("Year 3 should be a leap year", chronology.isLeapYear(3L));
    }

    @Test(timeout = 4000)
    public void testGetLeapYearsBefore719162() throws Throwable {
        // Test leap years calculation for a specific epoch day
        long leapYears = Symmetry454Chronology.getLeapYearsBefore(719162L);
        assertEquals(127633L, leapYears);
    }

    @Test(timeout = 4000)
    public void testGetLeapYearsBeforeNegative() throws Throwable {
        // Test leap years calculation for a negative value
        long leapYears = Symmetry454Chronology.getLeapYearsBefore(-60L);
        assertEquals(-11L, leapYears);
    }

    @Test(timeout = 4000)
    public void testEraOfValue0() throws Throwable {
        // Test getting BCE era from value 0
        Era era = chronology.eraOf(0);
        assertEquals(IsoEra.BCE, era);
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithCeEra() throws Throwable {
        // Test creating date from CE era, year, and day of year
        Clock clock = MockClock.systemDefaultZone();
        Symmetry454Date date = Symmetry454Date.now(clock);
        Era era = date.getEra();
        Symmetry454Date result = chronology.dateYearDay(era, 29, 11);
        assertEquals(IsoEra.CE, result.getEra());
    }

    @Test(timeout = 4000)
    public void testDateYearDay() throws Throwable {
        // Test creating date from year and day of year
        Symmetry454Date date = chronology.dateYearDay(19, 19);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateNowWithZoneOffset() throws Throwable {
        // Test getting current date with specific time zone
        ZoneOffset zone = ZoneOffset.MIN;
        Symmetry454Date date = chronology.dateNow(zone);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateEpochDay() throws Throwable {
        // Test creating date from epoch day
        Symmetry454Date date = chronology.dateEpochDay(132L);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateFromTemporalAccessor() throws Throwable {
        // Test creating date from TemporalAccessor
        ZoneId zone = ZoneId.systemDefault();
        Symmetry454Date inputDate = Symmetry454Date.now(zone);
        Symmetry454Date date = chronology.date(inputDate);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateWithCeEra() throws Throwable {
        // Test creating date from CE era, year, month, and day
        Symmetry454Date date = chronology.date(IsoEra.CE, 4, 4, 4);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDate() throws Throwable {
        // Test creating date from year, month, and day
        Symmetry454Date date = chronology.date(3, 2, 3);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testZonedDateTimeFromInvalidTemporalThrowsException() throws Throwable {
        // Test that zonedDateTime fails with unsupported TemporalAccessor
        try {
            chronology.zonedDateTime(JapaneseEra.TAISHO);
            fail("Expected DateTimeException for unsupported TemporalAccessor");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Unable to obtain ChronoZonedDateTime"));
        }
    }

    @Test(timeout = 4000)
    public void testZonedDateTimeFromNullThrowsException() throws Throwable {
        // Test that zonedDateTime fails with null input
        try {
            chronology.zonedDateTime((TemporalAccessor) null);
            fail("Expected NullPointerException for null input");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testRangeWithNullFieldThrowsException() throws Throwable {
        // Test that range fails with null ChronoField
        try {
            chronology.range(null);
            fail("Expected NullPointerException for null field");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testProlepticYearWithInvalidYearThrowsException() throws Throwable {
        // Test that proleptic year fails with invalid year
        try {
            chronology.prolepticYear(IsoEra.BCE, -2133538947);
            fail("Expected DateTimeException for invalid year");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for YearOfEra"));
        }
    }

    @Test(timeout = 4000)
    public void testLocalDateTimeFromInvalidTemporalThrowsException() throws Throwable {
        // Test that localDateTime fails with unsupported TemporalAccessor
        EthiopicDate ethiopicDate = EthiopicDate.ofEpochDay(719162L);
        try {
            chronology.localDateTime(ethiopicDate);
            fail("Expected DateTimeException for unsupported TemporalAccessor");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Unable to obtain ChronoLocalDateTime"));
        }
    }

    @Test(timeout = 4000)
    public void testEraOfInvalidValueThrowsException() throws Throwable {
        // Test that eraOf fails with invalid era value
        try {
            chronology.eraOf(-334);
            fail("Expected DateTimeException for invalid era");
        } catch (DateTimeException e) {
            assertEquals("Invalid era: -334", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithInvalidDayThrowsException() throws Throwable {
        // Test that dateYearDay fails with invalid day of year
        try {
            chronology.dateYearDay(IsoEra.BCE, -313, -313);
            fail("Expected DateTimeException for invalid day of year");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for DayOfYear"));
        }
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithUnsupportedEraThrowsException() throws Throwable {
        // Test that dateYearDay fails with unsupported era
        try {
            chronology.dateYearDay(JapaneseEra.SHOWA, -2315, -2315);
            fail("Expected ClassCastException for unsupported era");
        } catch (ClassCastException e) {
            assertEquals("Invalid era: Showa", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithInvalidLeapYearDayThrowsException() throws Throwable {
        // Test that dateYearDay fails with invalid day in non-leap year
        try {
            chronology.dateYearDay(371, 371);
            fail("Expected DateTimeException for invalid leap year day");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("is not a leap year"));
        }
    }

    @Test(timeout = 4000)
    public void testDateNowWithNullClockThrowsException() throws Throwable {
        // Test that dateNow fails with null clock
        try {
            chronology.dateNow((Clock) null);
            fail("Expected NullPointerException for null clock");
        } catch (NullPointerException e) {
            assertEquals("clock", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testDateFromUnsupportedTemporalThrowsException() throws Throwable {
        // Test that date fails with unsupported TemporalAccessor
        try {
            chronology.date((TemporalAccessor) IsoEra.CE);
            fail("Expected UnsupportedTemporalTypeException");
        } catch (UnsupportedTemporalTypeException e) {
            assertTrue(e.getMessage().contains("Unsupported field: EpochDay"));
        }
    }

    @Test(timeout = 4000)
    public void testDateFromInvalidTemporalThrowsException() throws Throwable {
        // Test that date fails with TemporalAccessor having invalid epoch day
        PaxDate paxDate = PaxDate.ofEpochDay(719162L);
        PaxDate adjustedDate = paxDate.minus(719162L, ChronoUnit.CENTURIES);
        try {
            chronology.date(adjustedDate);
            fail("Expected DateTimeException for invalid epoch day");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for EpochDay"));
        }
    }

    @Test(timeout = 4000)
    public void testDateWithInvalidMonthThrowsException() throws Throwable {
        // Test that date fails with invalid month
        try {
            chronology.date(1363, 1363, 1363);
            fail("Expected DateTimeException for invalid month");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for MonthOfYear"));
        }
    }

    @Test(timeout = 4000)
    public void testProlepticYearWithUnsupportedEraThrowsException() throws Throwable {
        // Test that prolepticYear fails with unsupported era
        try {
            chronology.prolepticYear(JapaneseEra.SHOWA, 29);
            fail("Expected ClassCastException for unsupported era");
        } catch (ClassCastException e) {
            assertEquals("Invalid era: Showa", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testIsLeapYearForYear32() throws Throwable {
        // Test that year 32 is not a leap year
        assertFalse("Year 32 should not be a leap year", chronology.isLeapYear(32L));
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithInvalidDayThrowsException() throws Throwable {
        // Test that dateYearDay fails with invalid day of year
        try {
            chronology.dateYearDay(-2501, -2501);
            fail("Expected DateTimeException for invalid day of year");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for DayOfYear"));
        }
    }

    @Test(timeout = 4000)
    public void testZonedDateTimeWithNullZoneThrowsException() throws Throwable {
        // Test that zonedDateTime fails with null zone
        Instant instant = MockInstant.ofEpochSecond(719162L);
        try {
            chronology.zonedDateTime(instant, null);
            fail("Expected NullPointerException for null zone");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testGetLeapYearsBeforeZero() throws Throwable {
        // Test leap years calculation for year 0
        long leapYears = Symmetry454Chronology.getLeapYearsBefore(0L);
        assertEquals(0L, leapYears);
    }

    @Test(timeout = 4000)
    public void testLocalDateTimeWithNullThrowsException() throws Throwable {
        // Test that localDateTime fails with null input
        try {
            chronology.localDateTime((TemporalAccessor) null);
            fail("Expected NullPointerException for null input");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testDateWithNullThrowsException() throws Throwable {
        // Test that date fails with null input
        try {
            chronology.date((TemporalAccessor) null);
            fail("Expected NullPointerException for null input");
        } catch (NullPointerException e) {
            // Expected
        }
    }

    @Test(timeout = 4000)
    public void testDateWithUnsupportedEraThrowsException() throws Throwable {
        // Test that date fails with unsupported era
        try {
            chronology.date(HijrahEra.AH, -2164, -2164, -2164);
            fail("Expected ClassCastException for unsupported era");
        } catch (ClassCastException e) {
            assertEquals("Invalid era: AH", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testRangeForSecondField() throws Throwable {
        // Test value range for SECOND_OF_MINUTE field
        ValueRange range = chronology.range(ChronoField.SECOND_OF_MINUTE);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForYearField() throws Throwable {
        // Test value range for YEAR field
        ValueRange range = chronology.range(ChronoField.YEAR);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForYearOfEraField() throws Throwable {
        // Test value range for YEAR_OF_ERA field
        ValueRange range = chronology.range(ChronoField.YEAR_OF_ERA);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForProlepticMonthField() throws Throwable {
        // Test value range for PROLEPTIC_MONTH field
        ValueRange range = chronology.range(ChronoField.PROLEPTIC_MONTH);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForEraField() throws Throwable {
        // Test value range for ERA field
        ValueRange range = chronology.range(ChronoField.ERA);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForEpochDayField() throws Throwable {
        // Test value range for EPOCH_DAY field
        ValueRange range = chronology.range(ChronoField.EPOCH_DAY);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForDayOfYearField() throws Throwable {
        // Test value range for DAY_OF_YEAR field
        ValueRange range = chronology.range(ChronoField.DAY_OF_YEAR);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForDayOfMonthField() throws Throwable {
        // Test value range for DAY_OF_MONTH field
        ValueRange range = chronology.range(ChronoField.DAY_OF_MONTH);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForAlignedWeekOfYearField() throws Throwable {
        // Test value range for ALIGNED_WEEK_OF_YEAR field
        ValueRange range = chronology.range(ChronoField.ALIGNED_WEEK_OF_YEAR);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForAlignedWeekOfMonthField() throws Throwable {
        // Test value range for ALIGNED_WEEK_OF_MONTH field
        ValueRange range = chronology.range(ChronoField.ALIGNED_WEEK_OF_MONTH);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForDayOfWeekField() throws Throwable {
        // Test value range for DAY_OF_WEEK field
        ValueRange range = chronology.range(ChronoField.DAY_OF_WEEK);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForAlignedDayOfWeekInMonthField() throws Throwable {
        // Test value range for ALIGNED_DAY_OF_WEEK_IN_MONTH field
        ValueRange range = chronology.range(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForMonthOfYearField() throws Throwable {
        // Test value range for MONTH_OF_YEAR field
        ValueRange range = chronology.range(ChronoField.MONTH_OF_YEAR);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testRangeForAlignedDayOfWeekInYearField() throws Throwable {
        // Test value range for ALIGNED_DAY_OF_WEEK_IN_YEAR field
        ValueRange range = chronology.range(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR);
        assertNotNull(range);
    }

    @Test(timeout = 4000)
    public void testZonedDateTimeFromOffsetDateTime() throws Throwable {
        // Test creating zoned date-time from OffsetDateTime
        System.setCurrentTimeMillis(-1343L);
        OffsetDateTime odt = MockOffsetDateTime.now();
        ChronoZonedDateTime<Symmetry454Date> zdt = chronology.zonedDateTime(odt);
        assertNotNull(zdt);
    }

    @Test(timeout = 4000)
    public void testProlepticYearForBceEraYear0() throws Throwable {
        // Test proleptic year for BCE era with year 0
        Era era = chronology.eraOf(0);
        int year = chronology.prolepticYear(era, 0);
        assertEquals(0, year);
    }

    @Test(timeout = 4000)
    public void testGetId() throws Throwable {
        // Test chronology ID
        assertEquals("Sym454", chronology.getId());
    }

    @Test(timeout = 4000)
    public void testDateNowWithClock() throws Throwable {
        // Test getting current date with clock
        Clock clock = MockClock.systemDefaultZone();
        Symmetry454Date date = chronology.dateNow(clock);
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateYearDayWithInvalidLeapDayThrowsException() throws Throwable {
        // Test that dateYearDay fails with leap day in non-leap year
        try {
            chronology.dateYearDay(IsoEra.BCE, 1145, 371);
            fail("Expected DateTimeException for leap day in non-leap year");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("is not a leap year"));
        }
    }

    @Test(timeout = 4000)
    public void testEras() throws Throwable {
        // Test getting list of eras
        List<Era> eras = chronology.eras();
        assertFalse(eras.isEmpty());
    }

    @Test(timeout = 4000)
    public void testDateNow() throws Throwable {
        // Test getting current date
        Symmetry454Date date = chronology.dateNow();
        assertEquals(IsoEra.CE, date.getEra());
    }

    @Test(timeout = 4000)
    public void testDateEpochDayWithLargeValueThrowsException() throws Throwable {
        // Test that dateEpochDay fails with large epoch day
        try {
            chronology.dateEpochDay(365242134L);
            fail("Expected DateTimeException for invalid epoch day");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid value for EpochDay"));
        }
    }

    @Test(timeout = 4000)
    public void testGetCalendarType() throws Throwable {
        // Test getting calendar type (should be null)
        assertNull(chronology.getCalendarType());
    }

    @Test(timeout = 4000)
    public void testDateWithInvalidDayThrowsException() throws Throwable {
        // Test that date fails with invalid day of month
        try {
            chronology.date(1, 1, 35);
            fail("Expected DateTimeException for invalid day of month");
        } catch (DateTimeException e) {
            assertTrue(e.getMessage().contains("Invalid date"));
        }
    }

    @Test(timeout = 4000)
    public void testDateNowWithNullZoneThrowsException() throws Throwable {
        // Test that dateNow fails with null zone
        try {
            chronology.dateNow((ZoneId) null);
            fail("Expected NullPointerException for null zone");
        } catch (NullPointerException e) {
            assertEquals("zone", e.getMessage());
        }
    }
}