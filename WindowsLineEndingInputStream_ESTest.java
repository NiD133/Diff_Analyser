/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 00:55:27 GMT 2025
 */

package org.apache.commons.io.input;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import org.apache.commons.io.input.WindowsLineEndingInputStream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class WindowsLineEndingInputStream_ESTest extends WindowsLineEndingInputStream_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testReadWithPushbackInputStreamAndDataInputStream() throws Throwable {
      // Test reading through decorated input streams
      byte[] inputData = new byte[6];
      inputData[5] = (byte) 24;  // Non-LF/CR byte
      ByteArrayInputStream byteArrayStream = new ByteArrayInputStream(inputData);
      PushbackInputStream pushbackStream = new PushbackInputStream(byteArrayStream);
      DataInputStream dataStream = new DataInputStream(pushbackStream);
      
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(dataStream, true);
      
      int bytesRead = windowsStream.read(inputData);
      assertEquals(0, byteArrayStream.available());
      assertEquals(6, bytesRead);
  }

  @Test(timeout = 4000)
  public void testReadSingleByte() throws Throwable {
      // Test reading single byte from stream
      byte[] inputData = new byte[6];  // All zeros
      ByteArrayInputStream byteArrayStream = new ByteArrayInputStream(inputData);
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(byteArrayStream, false);
      
      int result = windowsStream.read();
      assertEquals(5, byteArrayStream.available());
      assertEquals(0, result);
  }

  @Test(timeout = 4000)
  public void testReadWithNullStreamThrowsNullPointerException() throws Throwable {
      // Test reading from null stream throws exception
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream((InputStream) null, true);
      
      try {
          windowsStream.read();
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          // Expected exception
          verifyException("org.apache.commons.io.input.WindowsLineEndingInputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void testReadWithInvalidOffsetThrowsArrayIndexOutOfBoundsException() throws Throwable {
      // Test invalid stream configuration with negative offset
      byte[] inputData = new byte[2];
      // Invalid parameters: negative offset, positive length
      ByteArrayInputStream byteArrayStream = 
          new ByteArrayInputStream(inputData, -1782, (byte) 13);
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(byteArrayStream, false);
      
      try {
          windowsStream.read();
          fail("Expected ArrayIndexOutOfBoundsException");
      } catch (ArrayIndexOutOfBoundsException e) {
          // Expected exception
      }
  }

  @Test(timeout = 4000)
  public void testReadWithClosedFileDescriptorThrowsIOException() throws Throwable {
      // Test reading from invalid file descriptor
      FileDescriptor fileDescriptor = new FileDescriptor();
      MockFileInputStream mockFileStream = new MockFileInputStream(fileDescriptor);
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(mockFileStream, false);
      
      try {
          windowsStream.read();
          fail("Expected IOException");
      } catch (IOException e) {
          // Expected exception
          verifyException("org.evosuite.runtime.mock.java.io.NativeMockedIO", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloseWithNullStreamThrowsNullPointerException() throws Throwable {
      // Test closing null stream throws exception
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream((InputStream) null, false);
      
      try {
          windowsStream.close();
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          // Expected exception
          verifyException("org.apache.commons.io.input.WindowsLineEndingInputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void testLfTransformedToCrLfSequence() throws Throwable {
      // Test LF bytes are transformed to CRLF sequences
      byte[] inputData = new byte[6];
      inputData[0] = (byte) 10;  // LF character
      ByteArrayInputStream byteArrayStream = new ByteArrayInputStream(inputData);
      PushbackInputStream pushbackStream = new PushbackInputStream(byteArrayStream);
      DataInputStream dataStream = new DataInputStream(pushbackStream);
      
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(dataStream, true);
      
      int bytesRead = windowsStream.read(inputData);
      // Expected transformation: LF becomes CR+LF, other bytes may also transform
      assertArrayEquals(new byte[] {(byte) 13, (byte) 10, (byte) 13, (byte) 10, (byte) 13, (byte) 10}, inputData);
      assertEquals(6, bytesRead);
  }

  @Test(timeout = 4000)
  public void testReadFromEmptyStreamWithNegativeOffsetReturnsEof() throws Throwable {
      // Test reading from empty stream returns EOF
      byte[] emptyArray = new byte[0];
      // Invalid parameters but should handle empty read
      ByteArrayInputStream byteArrayStream = 
          new ByteArrayInputStream(emptyArray, -3187, -3187);
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(byteArrayStream, false);
      
      int result = windowsStream.read();
      assertEquals(-1, result);  // EOF
  }

  @Test(timeout = 4000)
  public void testReadFromEmptyStreamAppendsCrLfAtEos() throws Throwable {
      // Test empty stream appends CR+LF when configured
      byte[] emptyArray = new byte[0];
      ByteArrayInputStream byteArrayStream = 
          new ByteArrayInputStream(emptyArray, 2384, 0);  // Empty stream
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(byteArrayStream, true);
      
      // Should append CR then LF at end of stream
      assertEquals(13, windowsStream.read());  // CR
      assertEquals(10, windowsStream.read());  // LF
      assertEquals(-1, windowsStream.read());  // EOF
  }

  @Test(timeout = 4000)
  public void testMarkThrowsUnsupportedOperationException() throws Throwable {
      // Test mark operation is not supported
      byte[] inputData = new byte[6];
      ByteArrayInputStream byteArrayStream = new ByteArrayInputStream(inputData);
      PushbackInputStream pushbackStream = new PushbackInputStream(byteArrayStream);
      DataInputStream dataStream = new DataInputStream(pushbackStream);
      
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(dataStream, true);
      
      try {
          windowsStream.mark(0);
          fail("Expected UnsupportedOperationException");
      } catch (UnsupportedOperationException e) {
          // Expected exception
          verifyException("org.apache.commons.io.input.UnsupportedOperationExceptions", e);
      }
  }

  @Test(timeout = 4000)
  public void testCloseSucceeds() throws Throwable {
      // Test close operation completes normally
      byte[] emptyArray = new byte[0];
      ByteArrayInputStream byteArrayStream = 
          new ByteArrayInputStream(emptyArray, 2384, 0);
      WindowsLineEndingInputStream windowsStream = 
          new WindowsLineEndingInputStream(byteArrayStream, true);
      
      windowsStream.close();  // Should not throw
  }
}