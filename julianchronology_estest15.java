package org.threeten.extra.chrono;

import org.junit.Test;

import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDate;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZoneOffset;

import static org.junit.Assert.assertThrows;

/**
 * This test has been improved for understandability.
 * The original test was generated by EvoSuite and was named JulianChronology_ESTestTest15.
 */
public class JulianChronologyTest {

    /**
     * Tests that creating a ZonedDateTime from an Instant that is too far in the past,
     * i.e., before the minimum supported year, throws a DateTimeException.
     */
    @Test
    public void zonedDateTime_whenInstantIsBeforeSupportedRange_throwsDateTimeException() {
        // Arrange
        JulianChronology julianChronology = JulianChronology.INSTANCE;
        ZoneId utc = ZoneOffset.UTC;

        // The JulianChronology supports years from -999,998 to 999,999.
        // We create an Instant corresponding to a year well before this minimum boundary.
        // The Instant itself is calendar-neutral and is created here using the ISO calendar for simplicity.
        Instant instantBeforeMinSupportedYear = LocalDate.of(-1_000_000, Month.JANUARY, 1)
                .atStartOfDay(utc)
                .toInstant();

        // Act & Assert
        // The conversion to a Julian ZonedDateTime should fail because the year is out of range.
        assertThrows(DateTimeException.class, () -> {
            julianChronology.zonedDateTime(instantBeforeMinSupportedYear, utc);
        });
    }
}