/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability.
 */
package org.apache.commons.collections4.iterators;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.Array;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import org.apache.commons.collections4.functors.InstanceofPredicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class ZippingIterator_ESTest extends ZippingIterator_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void testConstructorWithArrayContainingZippingIterator() throws Throwable {
        // Setup: Create an empty list and its descending iterator
        LinkedList<Integer> emptyList = new LinkedList<>();
        Iterator<Integer> descendingIterator = emptyList.descendingIterator();
        
        // Create a zipping iterator with two empty iterators
        ZippingIterator<Integer> originalZipper = new ZippingIterator<>(descendingIterator, descendingIterator);
        
        // Create an array containing the original zipping iterator
        @SuppressWarnings("unchecked")
        Iterator<Integer>[] iteratorArray = (Iterator<Integer>[]) Array.newInstance(Iterator.class, 1);
        iteratorArray[0] = originalZipper;
        
        // Execute: Create a new zipping iterator from the array
        ZippingIterator<Integer> newZipper = new ZippingIterator<>(iteratorArray);
        
        // Verify: The new zipper is a different instance
        assertNotSame(newZipper, originalZipper);
    }

    @Test(timeout = 4000)
    public void testNextWithNullElement() throws Throwable {
        // Setup: Create a list containing a null element
        LinkedList<Integer> list = new LinkedList<>();
        list.add(null);
        Iterator<Integer> iterator = list.descendingIterator();
        
        // Execute: Create zipping iterator and retrieve next element
        ZippingIterator<Object> zipper = new ZippingIterator<>(iterator, iterator);
        Object result = zipper.next();
        
        // Verify: The retrieved element is null
        assertNull(result);
    }

    @Test(timeout = 4000)
    public void testNextWithNonNullElement() throws Throwable {
        // Setup: Create a list with a test object
        LinkedList<Object> list = new LinkedList<>();
        Object testObject = new Object();
        list.push(testObject);
        Iterator<Object> iterator = list.descendingIterator();
        
        // Execute: Create zipping iterator and retrieve next element
        ZippingIterator<Object> zipper = new ZippingIterator<>(iterator, iterator);
        Object result = zipper.next();
        
        // Verify: The retrieved element is the same as the test object
        assertSame(testObject, result);
    }

    @Test(timeout = 4000)
    public void testRemoveAfterConcurrentModificationThrowsException() throws Throwable {
        // Setup: Create a list with an element
        LinkedList<Integer> list = new LinkedList<>();
        Integer testValue = Integer.valueOf(-550);
        list.add(testValue);
        Iterator<Integer> iterator = list.iterator();
        
        // Create a zipping iterator with three references to the same iterator
        ZippingIterator<Object> zipper = new ZippingIterator<>(iterator, iterator, iterator);
        Object retrievedValue = zipper.next();
        
        // Modify the underlying list externally
        list.removeLastOccurrence(retrievedValue);
        
        // Verify: Remove operation throws ConcurrentModificationException
        try { 
            zipper.remove();
            fail("Expected ConcurrentModificationException");
        } catch (ConcurrentModificationException e) {
            // Expected: External modification invalidates the iterator
        }
    }

    @Test(timeout = 4000)
    public void testNextAfterConcurrentModificationThrowsException() throws Throwable {
        // Setup: Create an empty list and its list iterator
        LinkedList<InstanceofPredicate> list = new LinkedList<>();
        ListIterator<InstanceofPredicate> listIterator = list.listIterator();
        
        // Modify the list after creating the iterator
        list.add(null);
        
        // Create a zipping iterator with three references to the same list iterator
        ZippingIterator<InstanceofPredicate> zipper = new ZippingIterator<>(listIterator, listIterator, listIterator);
        
        // Verify: Next operation throws ConcurrentModificationException
        try { 
            zipper.next();
            fail("Expected ConcurrentModificationException");
        } catch (ConcurrentModificationException e) {
            // Expected: External modification invalidates the iterator
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithNullArrayElementThrowsNullPointerException() throws Throwable {
        // Setup: Create an array of iterators containing a null element
        @SuppressWarnings("unchecked")
        Iterator<Integer>[] iteratorArray = (Iterator<Integer>[]) Array.newInstance(Iterator.class, 1);
        iteratorArray[0] = null; // Invalid null element
        
        // Verify: Constructor throws NullPointerException
        try {
            new ZippingIterator<>(iteratorArray);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected: Null elements are not allowed
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithThreeNullIteratorsThrowsNullPointerException() throws Throwable {
        // Verify: Constructor throws NullPointerException when any iterator is null
        try {
            new ZippingIterator<>(null, null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected: Null iterators are not allowed
        }
    }

    @Test(timeout = 4000)
    public void testConstructorWithTwoNullIteratorsThrowsNullPointerException() throws Throwable {
        // Verify: Constructor throws NullPointerException when any iterator is null
        try {
            new ZippingIterator<>(null, null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected: Null iterators are not allowed
        }
    }

    @Test(timeout = 4000)
    public void testHasNextReturnsTrueWhenUnderlyingIteratorHasElements() throws Throwable {
        // Setup: Create a list and add an element
        LinkedList<InstanceofPredicate> list = new LinkedList<>();
        ListIterator<InstanceofPredicate> listIterator = list.listIterator();
        list.add(new InstanceofPredicate(Integer.class));
        
        // Execute: Create zipping iterator and check hasNext
        ZippingIterator<InstanceofPredicate> zipper = new ZippingIterator<>(listIterator, listIterator);
        zipper.hasNext(); // First check
        boolean hasNextResult = zipper.hasNext(); // Second check
        
        // Verify: hasNext returns true
        assertTrue(hasNextResult);
    }

    @Test(timeout = 4000)
    public void testHasNextWithAllEmptyIteratorsReturnsFalse() throws Throwable {
        // Setup: Create an empty list and its descending iterator
        LinkedList<Integer> emptyList = new LinkedList<>();
        Iterator<Integer> iterator = emptyList.descendingIterator();
        
        // Execute: Create zipping iterator and check hasNext
        ZippingIterator<Integer> zipper = new ZippingIterator<>(iterator, iterator, iterator);
        boolean hasNextResult = zipper.hasNext();
        
        // Verify: hasNext returns false
        assertFalse(hasNextResult);
    }

    @Test(timeout = 4000)
    public void testRemoveWithoutNextThrowsIllegalStateException() throws Throwable {
        // Setup: Create an empty list and its iterator
        LinkedList<Integer> emptyList = new LinkedList<>();
        Iterator<Integer> iterator = emptyList.iterator();
        
        // Create nested zipping iterators
        ZippingIterator<Integer> innerZipper = new ZippingIterator<>(iterator, iterator, iterator);
        ZippingIterator<Object> outerZipper = new ZippingIterator<>(innerZipper, iterator, iterator);
        
        // Verify: Remove without next throws IllegalStateException
        try { 
            outerZipper.remove();
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            // Expected: No element to remove
        }
    }

    @Test(timeout = 4000)
    public void testRemoveAfterNextSucceeds() throws Throwable {
        // Setup: Create a list with an element
        LinkedList<Integer> list = new LinkedList<>();
        Integer testValue = Integer.valueOf(-550);
        list.add(testValue);
        Iterator<Integer> iterator = list.iterator();
        
        // Execute: Create zipping iterator, retrieve element, and remove it
        ZippingIterator<Object> zipper = new ZippingIterator<>(iterator, iterator, iterator);
        zipper.next();
        zipper.remove(); // Should succeed
    }

    @Test(timeout = 4000)
    public void testNextWithAllEmptyIteratorsThrowsNoSuchElementException() throws Throwable {
        // Setup: Create an empty list and its iterator
        LinkedList<Integer> emptyList = new LinkedList<>();
        Iterator<Integer> iterator = emptyList.iterator();
        
        // Execute: Create zipping iterator
        ZippingIterator<Object> zipper = new ZippingIterator<>(iterator, iterator, iterator);
        
        // Verify: Next throws NoSuchElementException
        try { 
            zipper.next();
            fail("Expected NoSuchElementException");
        } catch (NoSuchElementException e) {
            // Expected: No elements available
        }
    }
}