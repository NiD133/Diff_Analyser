package com.google.common.collect;

import static com.google.common.truth.Truth.assertThat;
import static java.util.Arrays.asList;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.testing.SetTestSuiteBuilder;
import com.google.common.collect.testing.TestStringSetGenerator;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.collect.testing.features.Feature;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * Tests for {@link CompactLinkedHashSet}.
 *
 * <p>This class bundles comprehensive contract tests from guava-testlib with custom,
 * implementation-specific tests.
 */
@GwtIncompatible
@AndroidIncompatible // The suite includes guava-testlib, which is Android-incompatible.
public class CompactLinkedHashSetTest extends TestCase {

  /**
   * Creates a test suite containing all tests for {@link CompactLinkedHashSet}.
   *
   * <p>This method is the entry point for JUnit 3 test runners.
   */
  public static Test suite() {
    TestSuite suite = new TestSuite("CompactLinkedHashSet");

    // Add the comprehensive contract tests from guava-testlib.
    suite.addTest(createGuavaTestSuites());

    // Add all "test*" methods from this class as individual test cases.
    suite.addTestSuite(CompactLinkedHashSetTest.class);

    return suite;
  }

  /** Creates a {@link TestSuite} containing tests generated by guava-testlib. */
  private static Test createGuavaTestSuites() {
    TestSuite guavaSuites = new TestSuite("guava-testlib suites");

    guavaSuites.addTest(
        SetTestSuiteBuilder.using(compactLinkedHashSetGenerator())
            .named("CompactLinkedHashSet")
            .withFeatures(allSupportedFeatures())
            .createTestSuite());

    guavaSuites.addTest(
        SetTestSuiteBuilder.using(floodingResistantCompactLinkedHashSetGenerator())
            .named("CompactLinkedHashSet with flooding protection")
            .withFeatures(allSupportedFeatures())
            .createTestSuite());

    return guavaSuites;
  }

  /** Returns a generator for standard {@link CompactLinkedHashSet} instances. */
  private static TestStringSetGenerator compactLinkedHashSetGenerator() {
    return new TestStringSetGenerator() {
      @Override
      protected Set<String> create(String[] elements) {
        return CompactLinkedHashSet.create(asList(elements));
      }
    };
  }

  /** Returns a generator for flood-resistant {@link CompactLinkedHashSet} instances. */
  private static TestStringSetGenerator floodingResistantCompactLinkedHashSetGenerator() {
    return new TestStringSetGenerator() {
      @Override
      protected Set<String> create(String[] elements) {
        CompactLinkedHashSet<String> set = CompactLinkedHashSet.create();
        set.convertToHashFloodingResistantImplementation();
        Collections.addAll(set, elements);
        return set;
      }
    };
  }

  /** Returns the list of features supported by {@link CompactLinkedHashSet}. */
  private static List<Feature<?>> allSupportedFeatures() {
    return Arrays.asList(
        CollectionSize.ANY,
        CollectionFeature.ALLOWS_NULL_VALUES,
        CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION,
        CollectionFeature.GENERAL_PURPOSE,
        CollectionFeature.REMOVE_OPERATIONS,
        CollectionFeature.SERIALIZABLE,
        CollectionFeature.KNOWN_ORDER,
        CollectionFeature.SUPPORTS_ADD,
        CollectionFeature.SUPPORTS_REMOVE);
  }

  /**
   * Verifies that the backing arrays are not allocated upon creation but only after the first
   * element is added. This is a behavior inherited from {@link CompactHashSet}.
   */
  public void testCreate_arraysAreLazilyAllocatedOnFirstAdd() {
    // Arrange
    CompactLinkedHashSet<Integer> set = CompactLinkedHashSet.create();

    // Assert: Before any elements are added, the internal arrays are not yet allocated.
    assertThat(set.needsAllocArrays()).isTrue();
    // The `elements` field is an implementation detail, but checking it
    // is the most direct way to verify the lazy allocation mechanism.
    assertThat(set.elements).isNull();

    // Act: Add an element to trigger array allocation.
    set.add(1);

    // Assert: After adding an element, the arrays are allocated with the default size.
    assertThat(set.needsAllocArrays()).isFalse();
    assertThat(set.elements).hasLength(CompactHashing.DEFAULT_SIZE);
  }
}