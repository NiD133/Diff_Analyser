/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 19:36:06 GMT 2025
 */

package org.locationtech.spatial4j.shape.impl;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashMap;
import java.util.LinkedList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.locationtech.spatial4j.context.SpatialContext;
import org.locationtech.spatial4j.context.SpatialContextFactory;
import org.locationtech.spatial4j.distance.GeodesicSphereDistCalc;
import org.locationtech.spatial4j.shape.Point;
import org.locationtech.spatial4j.shape.Rectangle;
import org.locationtech.spatial4j.shape.Shape;
import org.locationtech.spatial4j.shape.ShapeCollection;
import org.locationtech.spatial4j.shape.SpatialRelation;
import org.locationtech.spatial4j.shape.impl.BufferedLine;
import org.locationtech.spatial4j.shape.impl.BufferedLineString;
import org.locationtech.spatial4j.shape.impl.PointImpl;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BufferedLineString_ESTest extends BufferedLineString_ESTest_scaffolding {

    // Helper method to create spatial context
    private SpatialContext createSpatialContext() {
        return SpatialContext.GEO;
    }

    // Helper method to create a point
    private Point createPoint(SpatialContext ctx, double x, double y) {
        return new PointImpl(x, y, ctx);
    }

    // Helper method to create empty BufferedLineString
    private BufferedLineString createEmptyLineString(SpatialContext ctx, double buf) {
        return new BufferedLineString(new LinkedList<>(), buf, ctx);
    }

    // Helper method to create single-point BufferedLineString
    private BufferedLineString createSinglePointLineString(SpatialContext ctx, double x, double y, double buf) {
        LinkedList<Point> points = new LinkedList<>();
        points.add(createPoint(ctx, x, y));
        return new BufferedLineString(points, buf, ctx);
    }

    /* ========================= Constructor Tests ========================= */
    @Test(timeout = 4000)
    public void constructor_WithValidParameters_SetsBufferValueCorrectly() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, 1580.13460088);
        assertEquals("Buffer value should be set correctly", 
                     1580.13460088, line.getBuf(), 0.01);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void constructor_WithNullContext_ThrowsNullPointerException() throws Throwable {
        new BufferedLineString(new LinkedList<>(), -116.02777, null);
    }

    @Test(timeout = 4000, expected = RuntimeException.class)
    public void constructor_WithInvalidCoordinates_ThrowsRuntimeException() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points = new LinkedList<>();
        points.add(createPoint(ctx, -1498.3962, -1498.3962));
        new BufferedLineString(points, -1498.3962, ctx);
    }

    /* ========================= hashCode() Tests ========================= */
    @Test(timeout = 4000)
    public void hashCode_WithDifferentBufferValues_ReturnsDifferentHashCodes() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line1 = createEmptyLineString(ctx, 0.0);
        BufferedLineString line2 = createEmptyLineString(ctx, 1114.712856653245);
        assertNotEquals("Hash codes should differ for different buffer values", 
                        line1.hashCode(), line2.hashCode());
    }

    @Test(timeout = 4000)
    public void hashCode_WithSameParameters_ReturnsSameHashCode() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points = new LinkedList<>();
        BufferedLineString line1 = new BufferedLineString(points, -1827.67990034, ctx);
        BufferedLineString line2 = new BufferedLineString(points, -1827.67990034, ctx);
        assertEquals("Hash codes should be equal for identical parameters", 
                     line1.hashCode(), line2.hashCode());
    }

    /* ========================= equals() Tests ========================= */
    @Test(timeout = 4000)
    public void equals_WithSameInstance_ReturnsTrue() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, 953.644844306585);
        assertTrue("Instance should equal itself", line.equals(line));
    }

    @Test(timeout = 4000)
    public void equals_WithDifferentBufferValues_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points = new LinkedList<>();
        BufferedLineString line1 = new BufferedLineString(points, 0.0, ctx);
        BufferedLineString line2 = new BufferedLineString(points, 1114.712856653245, ctx);
        assertFalse("Instances with different buffer values should not be equal", 
                    line1.equals(line2));
    }

    @Test(timeout = 4000)
    public void equals_WithDifferentPointLists_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points1 = new LinkedList<>();
        LinkedList<Point> points2 = new LinkedList<>();
        points2.add(createPoint(ctx, 0, 0));
        
        BufferedLineString line1 = new BufferedLineString(points1, -1827.67990034, ctx);
        BufferedLineString line2 = new BufferedLineString(points2, -1827.67990034, ctx);
        assertFalse("Instances with different points should not be equal", 
                    line1.equals(line2));
    }

    @Test(timeout = 4000)
    public void equals_WithNull_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = new BufferedLineString(new LinkedList<>(), -1.2265789709679984, ctx);
        assertFalse("Instance should not equal null", line.equals(null));
    }

    @Test(timeout = 4000)
    public void equals_WithDifferentType_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = new BufferedLineString(new LinkedList<>(), -2877.398196062, ctx);
        assertFalse("Instance should not equal different type", 
                    line.equals(new SpatialContextFactory()));
    }

    /* ========================= toString() Tests ========================= */
    @Test(timeout = 4000)
    public void toString_WithMultiplePoints_ReturnsExpectedFormat() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points = new LinkedList<>();
        Point center = createSinglePointLineString(ctx, 0, 0, -2877.398196062).getCenter();
        points.add(center);
        points.add(center);
        points.add(center);
        
        BufferedLineString line = new BufferedLineString(points, -2877.398196062, false, ctx);
        String result = line.toString();
        assertTrue("toString should contain buffer value", result.contains("buf=-2877.398196062"));
        assertTrue("toString should contain point coordinates", result.contains("pts=NaN NaN, NaN NaN, NaN NaN"));
    }

    /* ========================= getCenter() Tests ========================= */
    @Test(timeout = 4000)
    public void getCenter_WithSinglePoint_ReturnsExpectedPoint() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 1071.39772);
        Point center = line.getCenter();
        assertNotNull("Center should not be null", center);
        assertEquals("Center X should match", 0, center.getX(), 0.01);
        assertEquals("Center Y should match", 0, center.getY(), 0.01);
    }

    /* ========================= getBuffered() Tests ========================= */
    @Test(timeout = 4000, expected = NullPointerException.class)
    public void getBuffered_WithNullContext_ThrowsNullPointerException() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, -1.0);
        line.getBuffered(-1.0, null);
    }

    @Test(timeout = 4000, expected = UnsupportedOperationException.class)
    public void getBuffered_ResultRelate_ThrowsUnsupportedOperationException() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 16.128532143886176, 16.128532143886176, 16.128532143886176);
        Shape buffered = line.getBuffered(16.128532143886176, ctx);
        buffered.relate(line);
    }

    /* ========================= getBoundingBox() Tests ========================= */
    @Test(timeout = 4000)
    public void getBoundingBox_WithSinglePoint_ReturnsValidRectangle() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0.0, -1.0, 0.0);
        Rectangle bbox = line.getBoundingBox();
        assertFalse("Bounding box should not be empty", bbox.isEmpty());
        assertEquals("Max Y should be correct", -1.0, bbox.getMaxY(), 0.01);
    }

    @Test(timeout = 4000)
    public void getBoundingBox_WithPositiveBuffer_ReturnsNonEmptyRectangle() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0.2730010009451199, 0.2730010009451199, 3477.922086);
        Rectangle bbox = line.getBoundingBox();
        assertFalse("Bounding box should not be empty", bbox.isEmpty());
    }

    /* ========================= getArea() Tests ========================= */
    @Test(timeout = 4000)
    public void getArea_WithSinglePoint_ReturnsExpectedArea() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 16.128532143886176, 16.128532143886176, 16.128532143886176);
        double area = line.getArea(ctx);
        assertEquals("Area should match expected value", 41252.96124941927, area, 0.01);
    }

    @Test(timeout = 4000)
    public void getArea_WithMultiplePoints_ReturnsExpectedArea() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        LinkedList<Point> points = new LinkedList<>();
        points.add(createPoint(ctx, -180.0, 465.46032036));
        points.add(createPoint(ctx, 0.017453292519943295, 0.017453292519943295));
        
        BufferedLineString line = new BufferedLineString(points, 0.017453292519943295, true, ctx);
        double area = line.getArea(ctx);
        assertEquals("Area should match expected value", -65.33078137174249, area, 0.01);
    }

    /* ========================= relate() Tests ========================= */
    @Test(timeout = 4000)
    public void relate_WithSelf_ReturnsWithin() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 16.128532143886176, 16.128532143886176, 16.128532143886176);
        SpatialRelation relation = line.relate(line);
        assertEquals("Relation to self should be WITHIN", 
                     SpatialRelation.WITHIN, relation);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void relate_WithNull_ThrowsNullPointerException() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 1.7224835134970418, 1.7224835134970418, 1.7224835134970418);
        line.relate(null);
    }

    /* ========================= isEmpty() Tests ========================= */
    @Test(timeout = 4000)
    public void isEmpty_WithPoints_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 1071.39772);
        assertFalse("Line with points should not be empty", line.isEmpty());
    }

    @Test(timeout = 4000)
    public void isEmpty_WithoutPoints_ReturnsTrue() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, 0.0);
        assertTrue("Empty line should be empty", line.isEmpty());
    }

    /* ========================= hasArea() Tests ========================= */
    @Test(timeout = 4000)
    public void hasArea_WithPositiveBuffer_ReturnsTrue() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 1071.39772);
        assertTrue("Line with positive buffer should have area", line.hasArea());
    }

    @Test(timeout = 4000)
    public void hasArea_WithZeroBuffer_ReturnsFalse() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 0.0);
        assertFalse("Line with zero buffer should not have area", line.hasArea());
    }

    /* ========================= getSegments() Tests ========================= */
    @Test(timeout = 4000)
    public void getSegments_WithSinglePoint_ReturnsOneSegment() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 1569.552036879501);
        ShapeCollection<BufferedLine> segments = line.getSegments();
        assertEquals("Single point should produce one segment", 1, segments.size());
    }

    /* ========================= getBuf() Tests ========================= */
    @Test(timeout = 4000)
    public void getBuf_AfterConstruction_ReturnsCorrectValue() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, -1.2265789709679984);
        assertEquals("Buffer value should match constructor argument", 
                     -1.2265789709679984, line.getBuf(), 0.01);
    }

    /* ========================= getPoints() Tests ========================= */
    @Test(timeout = 4000)
    public void getPoints_WithoutPoints_ReturnsEmptyList() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createEmptyLineString(ctx, 0.0);
        assertTrue("Points list should be empty", line.getPoints().isEmpty());
    }

    @Test(timeout = 4000)
    public void getPoints_WithPoints_ReturnsCorrectCount() throws Throwable {
        SpatialContext ctx = createSpatialContext();
        BufferedLineString line = createSinglePointLineString(ctx, 0, 0, 1569.552036879501);
        assertEquals("Points list should have correct size", 1, line.getPoints().size());
    }
}