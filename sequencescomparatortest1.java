package org.apache.commons.collections4.sequence;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

/**
 * Tests the {@link SequencesComparator}.
 *
 * <p>This test verifies that the {@link EditScript} generated by the comparator
 * can correctly transform one sequence into another. It does so by using a custom
 * {@link CommandVisitor} implementation, {@code ExecutionVisitor}, which simulates
 * the application of the script's commands (insert, delete, keep) to an initial
 * sequence.</p>
 */
class SequencesComparatorTest {

    /**
     * A test-specific implementation of CommandVisitor that applies an EditScript
     * to a sequence. This acts as a simulator to verify that the script correctly
     * transforms the "before" state to the "after" state.
     *
     * @param <T> the type of elements in the sequence
     */
    private static final class ExecutionVisitor<T> implements CommandVisitor<T> {

        private final List<T> sequence;
        private int currentIndex;

        /**
         * Constructs a visitor with the initial sequence to be transformed.
         *
         * @param sequence the initial list of elements, which will be modified.
         *                 A new copy is created to avoid side effects.
         */
        ExecutionVisitor(final List<T> sequence) {
            this.sequence = new ArrayList<>(sequence);
            this.currentIndex = 0;
        }

        /**
         * Returns the transformed sequence as a string.
         * This is used for easy comparison in assertions.
         */
        public String getResultAsString() {
            final StringBuilder buffer = new StringBuilder();
            for (final T element : sequence) {
                buffer.append(element);
            }
            return buffer.toString();
        }

        @Override
        public void visitDeleteCommand(final T object) {
            sequence.remove(currentIndex);
        }

        @Override
        public void visitInsertCommand(final T object) {
            sequence.add(currentIndex++, object);
        }

        @Override
        public void visitKeepCommand(final T object) {
            currentIndex++;
        }
    }

    /**
     * Provides the test data for the parameterized test.
     *
     * @return a stream of arguments, each containing a "before" string, an "after" string,
     *         and a description of the test case.
     */
    static Stream<Arguments> stringChangeFixtures() {
        return Stream.of(
            Arguments.of("bottle", "noodle", "Simple substitution and keep"),
            Arguments.of("nematode knowledge", "empty bottle", "Complex change with shared words"),
            Arguments.of("", "", "Empty sequences"),
            Arguments.of("aa", "C", "Deletion and insertion"),
            Arguments.of("prefixed string", "prefix", "Deletion from end"),
            Arguments.of("ABCABBA", "CBABAC", "Classic LCS example"),
            Arguments.of("glop glop", "pas glop pas glop", "Insertion at start and middle"),
            Arguments.of("coq", "ane", "Complete change, same length"),
            Arguments.of("spider-man", "klingon", "Complete change, different length")
        );
    }

    @ParameterizedTest(name = "[{index}] {2}")
    @MethodSource("stringChangeFixtures")
    void scriptExecutionShouldTransformBeforeSequenceToAfterSequence(
            final String before, final String after, final String description) {
        // Arrange
        final List<Character> beforeSequence = toCharacterList(before);
        final List<Character> afterSequence = toCharacterList(after);

        final SequencesComparator<Character> comparator =
                new SequencesComparator<>(beforeSequence, afterSequence);
        final EditScript<Character> script = comparator.getScript();

        // The visitor simulates applying the script to the 'before' sequence.
        final ExecutionVisitor<Character> visitor = new ExecutionVisitor<>(beforeSequence);

        // Act
        script.visit(visitor);
        final String result = visitor.getResultAsString();

        // Assert
        assertEquals(after, result, "The script should transform the 'before' string to the 'after' string.");
    }

    /**
     * Helper method to convert a String into a List of Characters.
     *
     * @param str the string to convert
     * @return a new list containing the characters of the string
     */
    private static List<Character> toCharacterList(final String str) {
        final List<Character> list = new ArrayList<>();
        for (int i = 0; i < str.length(); ++i) {
            list.add(str.charAt(i));
        }
        return list;
    }
}