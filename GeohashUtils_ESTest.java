/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 19:36:16 GMT 2025
 */

package org.locationtech.spatial4j.io;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.locationtech.spatial4j.context.SpatialContext;
import org.locationtech.spatial4j.context.SpatialContextFactory;
import org.locationtech.spatial4j.io.GeohashUtils;
import org.locationtech.spatial4j.shape.Point;
import org.locationtech.spatial4j.shape.Rectangle;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class GeohashUtils_ESTest extends GeohashUtils_ESTest_scaffolding {

    //----- Decoding Tests -----//
    
    @Test(timeout = 4000)
    public void decode_ThrowsArrayIndexOutOfBounds_ForInvalidCharacter() throws Throwable {
        HashMap<String, String> hashMap0 = new HashMap<>();
        ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
        SpatialContext spatialContext0 = SpatialContextFactory.makeSpatialContext(hashMap0, classLoader0);
        
        try {
            GeohashUtils.decode("R9ENOYUZj]oNX(A", spatialContext0);
            fail("Expecting exception: ArrayIndexOutOfBoundsException");
        } catch(ArrayIndexOutOfBoundsException e) {
            // Invalid character causes index calculation error
            verifyException("org.locationtech.spatial4j.io.GeohashUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void decode_ReturnsCorrectPoint_ForLongGeohash() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        Point point = GeohashUtils.decode(
            "h0pb421bn842p8h85bj0hbp000000000000000000000000000000000000000000000000000000000000000000000000000000000", 
            spatialContext0
        );
        
        assertEquals(11.0, point.getX(), 0.01);
        assertEquals(-90.0, point.getLat(), 0.01);
    }

    //----- Boundary Decoding Tests -----//
    
    @Test(timeout = 4000)
    public void decodeBoundary_HandlesSingleCharacterHash() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        Rectangle rect = GeohashUtils.decodeBoundary("d", spatialContext0);
        assertNotNull(rect);
    }
    
    @Test(timeout = 4000)
    public void decodeBoundary_Handles12CharacterHash() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        Rectangle rect = GeohashUtils.decodeBoundary("eurbxcpfpurb", spatialContext0);
        assertNotNull(rect);
    }
    
    @Test(timeout = 4000)
    public void decodeBoundary_HandlesRepeatedPatternHash() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        Rectangle rect = GeohashUtils.decodeBoundary("kpbpbpbpbpbp", spatialContext0);
        
        assertEquals(0.0, rect.getMinX(), 0.01);
        assertEquals(3.3527612686157227E-7, rect.getMaxX(), 0.01);
        assertEquals(-1.6763806343078613E-7, rect.getMinY(), 0.01);
    }
    
    @Test(timeout = 4000)
    public void decodeBoundary_ThrowsArrayIndexOutOfBounds_ForInvalidCharacter() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        try {
            GeohashUtils.decodeBoundary("J-", spatialContext0);
            fail("Expecting exception: ArrayIndexOutOfBoundsException");
        } catch(ArrayIndexOutOfBoundsException e) {
            // Invalid character causes negative index
            verifyException("org.locationtech.spatial4j.io.GeohashUtils", e);
        }
    }

    //----- Encoding Tests -----//
    
    @Test(timeout = 4000)
    public void encodeLatLon_HandlesZeroPrecision() throws Throwable {
        String hash = GeohashUtils.encodeLatLon(13.0, 13.0, 0);
        assertNotNull(hash);
    }
    
    @Test(timeout = 4000)
    public void encodeLatLon_ReturnsExpectedValue_ForSpecificInput() throws Throwable {
        String hash = GeohashUtils.encodeLatLon(1.0, 3.4332275390625E-4, 31);
        assertEquals("s00j8n01rvxbrgrupfzgpbxzpbpbp00", hash);
    }
    
    @Test(timeout = 4000)
    public void encodeLatLon_ThrowsException_ForNegativePrecision() {
        try {
            GeohashUtils.encodeLatLon(0.017453292519943295, 0.017453292519943295, -3030);
            fail("Expecting exception: NegativeArraySizeException");
        } catch(NegativeArraySizeException e) {
            // Negative precision causes invalid array allocation
        }
    }

    //----- Hash Length Utility Tests -----//
    
    @Test(timeout = 4000)
    public void lookupDegreesSizeForHashLen_ReturnsCorrectValues_ForValidLength() throws Throwable {
        double[] sizes = GeohashUtils.lookupDegreesSizeForHashLen(16);
        assertArrayEquals(new double[] {1.6370904631912708E-10, 3.2741809263825417E-10}, sizes, 0.01);
    }
    
    @Test(timeout = 4000)
    public void lookupDegreesSizeForHashLen_ThrowsArrayIndexOutOfBounds_ForNegativeLength() {
        try {
            GeohashUtils.lookupDegreesSizeForHashLen(-482);
            fail("Expecting exception: ArrayIndexOutOfBoundsException");
        } catch(ArrayIndexOutOfBoundsException e) {
            // Negative length is invalid array index
            verifyException("org.locationtech.spatial4j.io.GeohashUtils", e);
        }
    }
    
    @Test(timeout = 4000)
    public void lookupHashLenForWidthHeight_Returns11_ForSpecificInput() throws Throwable {
        int len = GeohashUtils.lookupHashLenForWidthHeight(1.0728836059570312E-5, 1115.07072940934);
        assertEquals(11, len);
    }
    
    @Test(timeout = 4000)
    public void lookupHashLenForWidthHeight_Returns24_ForVerySmallValues() throws Throwable {
        int len = GeohashUtils.lookupHashLenForWidthHeight(1.2490009027033011E-15, 1.2490009027033011E-15);
        assertEquals(24, len);
    }

    //----- Sub-Geohash Tests -----//
    
    @Test(timeout = 4000)
    public void getSubGeohashes_Returns32Elements_ForEmptyString() throws Throwable {
        String[] subHashes = GeohashUtils.getSubGeohashes("");
        assertEquals(32, subHashes.length);
    }

    //----- Exception Handling Tests -----//
    
    @Test(timeout = 4000)
    public void decodeBoundary_ThrowsNullPointerException_WhenContextNull() {
        try {
            GeohashUtils.decodeBoundary("", null);
            fail("Expecting exception: NullPointerException");
        } catch(NullPointerException e) {
            // Null context not allowed
        }
    }
    
    @Test(timeout = 4000)
    public void decode_ThrowsNullPointerException_WhenContextNull() {
        try {
            GeohashUtils.decode("A0D", null);
            fail("Expecting exception: NullPointerException");
        } catch(NullPointerException e) {
            // Null context not allowed
        }
    }

    //----- Stress/Edge Case Tests -----//
    
    @Test(timeout = 4000)
    public void decodeBoundary_HandlesExtremelyLongHash() throws Throwable {
        SpatialContext spatialContext0 = SpatialContext.GEO;
        // 126-character hash (repeating "pb")
        String longHash = "pbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbpbp";
        Rectangle rect = GeohashUtils.decodeBoundary(longHash, spatialContext0);
        assertNotNull(rect);
    }
}