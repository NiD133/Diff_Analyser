/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.locationtech.spatial4j.io;

import org.junit.jupiter.api.Test;
import org.locationtech.spatial4j.context.SpatialContext;
import org.locationtech.spatial4j.shape.Point;
import org.locationtech.spatial4j.shape.Rectangle;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link GeohashUtils}.
 *
 * NOTE: The original version of this test was auto-generated by EvoSuite and has been
 * refactored for clarity, maintainability, and improved test coverage.
 */
class GeohashUtilsTest {

    private final SpatialContext spatialContext = SpatialContext.GEO;

    // -------------------------------------------------------------------------------------
    // Tests for encodeLatLon()
    // -------------------------------------------------------------------------------------

    @Test
    void encodeLatLon_withZeroPrecision_returnsEmptyString() {
        String geohash = GeohashUtils.encodeLatLon(13.0, 13.0, 0);
        assertTrue(geohash.isEmpty(), "Encoding with zero precision should produce an empty string.");
    }

    @Test
    void encodeLatLon_withNegativePrecision_throwsException() {
        assertThrows(NegativeArraySizeException.class, () -> {
            GeohashUtils.encodeLatLon(45.0, 45.0, -1);
        }, "Encoding with negative precision should throw an exception.");
    }

    @Test
    void encodeLatLon_withValidCoordinatesAndPrecision_returnsCorrectGeohash() {
        // This test uses a precision of 31, which is > GeohashUtils.MAX_PRECISION (24),
        // confirming the implementation allows precisions beyond the documented max.
        String geohash = GeohashUtils.encodeLatLon(1.0, 3.4332275390625E-4, 31);
        assertEquals("s00j8n01rvxbrgrupfzgpbxzpbpbp00", geohash);
    }

    @Test
    void encodeLatLon_withMaxPrecision_returnsCorrectLengthGeohash() {
        String geohash = GeohashUtils.encodeLatLon(42.6, -5.6, GeohashUtils.MAX_PRECISION);
        assertEquals(GeohashUtils.MAX_PRECISION, geohash.length());
    }

    @Test
    void encodeLatLon_withOutOfRangeCoordinates_normalizesAndEncodes() {
        // Geohash implementations should wrap longitude and clamp latitude.
        // Longitude 181 should wrap to -179. Latitude 91 should be clamped to 90.
        String geohashOutOfRange = GeohashUtils.encodeLatLon(91, 181, 12);
        String geohashInRange = GeohashUtils.encodeLatLon(90, -179, 12);
        assertEquals(geohashInRange, geohashOutOfRange);

        // Longitude -181 should wrap to 179. Latitude -91 should be clamped to -90.
        geohashOutOfRange = GeohashUtils.encodeLatLon(-91, -181, 12);
        geohashInRange = GeohashUtils.encodeLatLon(-90, 179, 12);
        assertEquals(geohashInRange, geohashOutOfRange);
    }

    // -------------------------------------------------------------------------------------
    // Tests for decode() and decodeBoundary()
    // -------------------------------------------------------------------------------------

    @Test
    void decode_withInvalidGeohash_throwsException() {
        // The geohash contains invalid characters like 'A', 'I', 'L', 'O', and ']'
        String invalidGeohash = "R9ENOYUZj]oNX(A";
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            GeohashUtils.decode(invalidGeohash, spatialContext);
        });
    }

    @Test
    void decodeBoundary_withInvalidGeohash_throwsException() {
        // The geohash contains an invalid character '-'
        String invalidGeohash = "J-";
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            GeohashUtils.decodeBoundary(invalidGeohash, spatialContext);
        });
    }

    @Test
    void decode_withNullContext_throwsException() {
        assertThrows(NullPointerException.class, () -> GeohashUtils.decode("ezs42", null));
    }

    @Test
    void decodeBoundary_withNullContext_throwsException() {
        assertThrows(NullPointerException.class, () -> GeohashUtils.decodeBoundary("ezs42", null));
    }

    @Test
    void decodeBoundary_forEmptyGeohash_returnsWorldBounds() {
        Rectangle worldBounds = spatialContext.getWorldBounds();
        Rectangle decodedBounds = GeohashUtils.decodeBoundary("", spatialContext);
        assertEquals(worldBounds, decodedBounds);
    }

    @Test
    void decodeBoundary_forSingleCharGeohash_returnsCorrectBounds() {
        // Geohash "d" corresponds to binary 01100.
        // Longitude bits: 0, 1, 0 -> [-180, 0], [-90, 0], [-90, -45]
        // Latitude bits: 1, 0 -> [0, 90], [0, 45]
        Rectangle bounds = GeohashUtils.decodeBoundary("d", spatialContext);
        assertEquals(-90.0, bounds.getMinX(), 1e-9);
        assertEquals(-45.0, bounds.getMaxX(), 1e-9);
        assertEquals(0.0, bounds.getMinY(), 1e-9);
        assertEquals(45.0, bounds.getMaxY(), 1e-9);
    }

    @Test
    void decode_roundtrip_recoversOriginalPointApproximately() {
        double originalLat = 40.7128; // New York City
        double originalLon = -74.0060;

        String geohash = GeohashUtils.encodeLatLon(originalLat, originalLon, 12);
        Point decodedPoint = GeohashUtils.decode(geohash, spatialContext);

        // The decoded point is the center of the geohash cell, so it won't be exact.
        // The error should be within half the cell's dimensions for that precision level.
        double[] errorDegrees = GeohashUtils.lookupDegreesSizeForHashLen(12); // [lat, lon]
        double maxLatError = errorDegrees[0] / 2.0;
        double maxLonError = errorDegrees[1] / 2.0;

        assertEquals(originalLat, decodedPoint.getY(), maxLatError);
        assertEquals(originalLon, decodedPoint.getX(), maxLonError);
    }

    // -------------------------------------------------------------------------------------
    // Tests for getSubGeohashes()
    // -------------------------------------------------------------------------------------

    @Test
    void getSubGeohashes_forEmptyBase_returnsAll32TopLevelHashes() {
        String[] subhashes = GeohashUtils.getSubGeohashes("");
        assertEquals(32, subhashes.length);
        assertEquals("0", subhashes[0]);
        assertEquals("z", subhashes[31]);
    }

    @Test
    void getSubGeohashes_forNonEmptyBase_returns32SubHashes() {
        String base = "d";
        String[] subhashes = GeohashUtils.getSubGeohashes(base);
        assertEquals(32, subhashes.length);
        // All subhashes should start with the base hash and be one character longer.
        for (String subhash : subhashes) {
            assertTrue(subhash.startsWith(base));
            assertEquals(base.length() + 1, subhash.length());
        }
        assertEquals("d0", subhashes[0]);
        assertEquals("dz", subhashes[31]);
    }

    // -------------------------------------------------------------------------------------
    // Tests for lookupHashLenForWidthHeight() and lookupDegreesSizeForHashLen()
    // -------------------------------------------------------------------------------------

    @Test
    void lookupHashLenForWidthHeight_forGivenError_returnsCorrectLength() {
        int hashLen = GeohashUtils.lookupHashLenForWidthHeight(1.0728836059570312E-5, 1115.07072940934);
        assertEquals(11, hashLen);
    }

    @Test
    void lookupHashLenForWidthHeight_forVerySmallError_returnsMaxPrecision() {
        // A very small error tolerance should require the maximum precision.
        double verySmallError = 1.2490009027033011E-15;
        int hashLen = GeohashUtils.lookupHashLenForWidthHeight(verySmallError, verySmallError);
        assertEquals(GeohashUtils.MAX_PRECISION, hashLen);
    }

    @Test
    void lookupDegreesSizeForHashLen_withNegativeLength_throwsException() {
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            GeohashUtils.lookupDegreesSizeForHashLen(-1);
        });
    }

    @Test
    void lookupDegreesSizeForHashLen_withValidLength_returnsCorrectDimensions() {
        // The returned array is [latitude_height, longitude_width].
        double[] dimensions = GeohashUtils.lookupDegreesSizeForHashLen(16);
        double[] expected = {1.6370904631912708E-10, 3.2741809263825417E-10};
        assertArrayEquals(expected, dimensions, 1e-12);
    }
}