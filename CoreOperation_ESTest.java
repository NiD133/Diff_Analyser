/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 18 19:58:03 GMT 2025
 */

package org.apache.commons.jxpath.ri.compiler;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.ParentContext;
import org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext;
import org.apache.commons.jxpath.ri.axes.RootContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;
import org.apache.commons.jxpath.ri.axes.UnionContext;
import org.apache.commons.jxpath.ri.compiler.CoreFunction;
import org.apache.commons.jxpath.ri.compiler.CoreOperationAdd;
import org.apache.commons.jxpath.ri.compiler.CoreOperationAnd;
import org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan;
import org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual;
import org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan;
import org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual;
import org.apache.commons.jxpath.ri.compiler.CoreOperationMod;
import org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply;
import org.apache.commons.jxpath.ri.compiler.CoreOperationNegate;
import org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract;
import org.apache.commons.jxpath.ri.compiler.CoreOperationUnion;
import org.apache.commons.jxpath.ri.compiler.Expression;
import org.apache.commons.jxpath.ri.compiler.NameAttributeTest;
import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import org.apache.commons.jxpath.ri.compiler.VariableReference;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.VariablePointer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class CoreOperation_ESTest extends CoreOperation_ESTest_scaffolding {

    // Node type constant for better readability
    private static final int COMMENT_NODE_TYPE = 8;

    @Test(timeout = 4000)
    public void testCoreOperationUnionToStringWithEmptyArray() throws Throwable {
        // Test that CoreOperationUnion with empty expression array returns empty string
        Expression[] emptyExpressions = new Expression[0];
        CoreOperationUnion union = new CoreOperationUnion(emptyExpressions);
        String result = union.toString();
        assertEquals("", result);
    }

    @Test(timeout = 4000)
    public void testCoreOperationLessThanOrEqualSymbol() throws Throwable {
        // Test that CoreOperationLessThanOrEqual returns correct operator symbol
        CoreOperationLessThanOrEqual operation = 
            new CoreOperationLessThanOrEqual(null, null);
        String symbol = operation.getSymbol();
        assertEquals("<=", symbol);
    }

    @Test(timeout = 4000)
    public void testCoreOperationUnionComputeValueWithEmptyArray() throws Throwable {
        // Test computeValue for CoreOperationUnion with empty expression array
        Expression[] emptyExpressions = new Expression[0];
        CoreOperationUnion union = new CoreOperationUnion(emptyExpressions);
        
        JXPathContextReferenceImpl contextImpl = 
            (JXPathContextReferenceImpl) JXPathContext.newContext(union);
        VariablePointer variablePointer = new VariablePointer(null);
        RootContext rootContext = new RootContext(contextImpl, variablePointer);
        
        InitialContext initialContext = (InitialContext) rootContext.getConstantContext(null);
        UnionContext result = (UnionContext) union.computeValue(initialContext);
        
        assertFalse("Child ordering should not be required", 
                   result.isChildOrderingRequired());
    }

    @Test(timeout = 4000)
    public void testCoreOperationUnionComputeInParentContext() throws Throwable {
        // Test compute for CoreOperationUnion in complex context hierarchy
        Expression[] emptyExpressions = new Expression[0];
        CoreOperationUnion union = new CoreOperationUnion(emptyExpressions);
        
        RootContext rootContext = new RootContext(null, null);
        NodeTypeTest nodeTypeTest = new NodeTypeTest(COMMENT_NODE_TYPE);
        PrecedingOrFollowingContext precedingContext = 
            new PrecedingOrFollowingContext(rootContext, nodeTypeTest, false);
        SelfContext selfContext = new SelfContext(precedingContext, nodeTypeTest);
        
        QName emptyQName = new QName("");
        NodeNameTest nameTest = new NodeNameTest(emptyQName);
        ParentContext parentContext = new ParentContext(selfContext, nameTest);
        
        UnionContext result = (UnionContext) union.compute(parentContext);
        assertFalse("Child ordering should not be required", 
                   result.isChildOrderingRequired());
    }

    @Test(timeout = 4000)
    public void testNameAttributeTestToStringWithNullExpressions() throws Throwable {
        // Test that NameAttributeTest with null expressions throws NPE in toString
        NameAttributeTest test = new NameAttributeTest(null, null);
        
        try {
            test.toString();
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected due to null expressions
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationSubtractComputeValueWithNullContext() throws Throwable {
        // Test that CoreOperationSubtract with recursive expression throws exception
        Expression[] expressions = new Expression[2];
        CoreOperationAnd recursiveOp = new CoreOperationAnd(expressions);
        expressions[0] = recursiveOp; // Create recursive dependency
        
        CoreOperationSubtract subtract = 
            new CoreOperationSubtract(recursiveOp, expressions[1]);
        
        // Should fail due to recursive expression evaluation
        try {
            subtract.computeValue(null);
            fail("Expected exception");
        } catch (Exception e) {
            // Expected during evaluation
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationAddWithIncorrectFunctionArguments() throws Throwable {
        // Test CoreOperationAdd with function having incorrect argument count
        Expression[] functionArgs = new Expression[9];
        CoreFunction function = new CoreFunction(15, functionArgs); // string-length function
        
        // Create expression: function * function
        CoreOperationMultiply multiply = 
            new CoreOperationMultiply(function, function);
        functionArgs[0] = multiply;
        
        CoreOperationAdd addOperation = new CoreOperationAdd(functionArgs);
        
        try {
            addOperation.compute(null);
            fail("Expected RuntimeException for incorrect arguments");
        } catch (RuntimeException e) {
            // Verify exception mentions incorrect argument count
            assertTrue(e.getMessage().contains("Incorrect number of arguments"));
        }
    }

    @Test(timeout = 4000)
    public void testNameAttributeTestComputeWithEmptyArgsArray() throws Throwable {
        // Test NameAttributeTest with empty arguments array
        NameAttributeTest baseTest = new NameAttributeTest(null, null);
        NameAttributeTest test = new NameAttributeTest(baseTest, baseTest);
        
        // Override arguments to empty array
        test.args = new Expression[0];
        
        try {
            test.compute(null);
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            assertEquals("0", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationModComputeThrowsArithmeticException() throws Throwable {
        // Test that CoreOperationMod throws ArithmeticException for invalid operation
        Expression[] emptyArray = new Expression[0];
        CoreOperationAnd andOp = new CoreOperationAnd(emptyArray);
        
        // Create mod operation: andOp % andOp
        CoreOperationMod modOp = new CoreOperationMod(andOp, andOp);
        
        try {
            modOp.compute(null);
            fail("Expected ArithmeticException");
        } catch (ArithmeticException e) {
            // Expected division by zero or similar
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationUnionWithFunctionHavingIncorrectArguments() throws Throwable {
        // Test CoreOperationUnion containing function with incorrect arguments
        Expression[] functionArgs = new Expression[8];
        CoreFunction function = new CoreFunction(16, functionArgs); // normalize-space
        
        // Create comparison: function <= function
        CoreOperationLessThanOrEqual comparison = 
            new CoreOperationLessThanOrEqual(function, function);
        CoreOperationNegate negate = new CoreOperationNegate(comparison);
        
        // Create union with function and negated expression
        Expression[] unionArgs = new Expression[6];
        unionArgs[0] = function;
        unionArgs[1] = negate;
        CoreOperationUnion union = new CoreOperationUnion(unionArgs);
        
        // Set one function argument to trigger error
        functionArgs[5] = negate;
        
        try {
            union.computeValue(null);
            fail("Expected RuntimeException for incorrect arguments");
        } catch (RuntimeException e) {
            // Verify exception mentions incorrect argument count
            assertTrue(e.getMessage().contains("Incorrect number of arguments"));
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationGreaterThanOrEqualToString() throws Throwable {
        // Test that CoreOperationGreaterThanOrEqual returns non-null string representation
        CoreFunction function = new CoreFunction(-716, null);
        CoreOperationGreaterThan greaterThan = 
            new CoreOperationGreaterThan(function, function);
        CoreOperationLessThan lessThan = 
            new CoreOperationLessThan(greaterThan, function);
        CoreOperationGreaterThanOrEqual geOperation = 
            new CoreOperationGreaterThanOrEqual(lessThan, lessThan);
        
        String result = geOperation.toString();
        assertNotNull("String representation should not be null", result);
    }

    @Test(timeout = 4000)
    public void testNameAttributeTestToString() throws Throwable {
        // Test that NameAttributeTest returns non-null string representation
        NameAttributeTest baseTest = new NameAttributeTest(null, null);
        NameAttributeTest test = new NameAttributeTest(baseTest, baseTest);
        
        String result = test.toString();
        assertNotNull("String representation should not be null", result);
    }

    @Test(timeout = 4000)
    public void testCoreOperationUnionWithMultiplyAndFunction() throws Throwable {
        // Test CoreOperationUnion containing complex expression tree
        Expression[] functionArgs = new Expression[8];
        CoreFunction function = new CoreFunction(16, functionArgs); // normalize-space
        
        CoreOperationLessThanOrEqual comparison = 
            new CoreOperationLessThanOrEqual(function, function);
        CoreOperationNegate negate = new CoreOperationNegate(comparison);
        
        // Create variable reference and multiplication: negate * variable
        QName qname = new QName("");
        VariableReference variable = new VariableReference(qname);
        CoreOperationMultiply multiply = new CoreOperationMultiply(negate, variable);
        functionArgs[6] = multiply;
        
        // Create union containing the function
        Expression[] unionArgs = new Expression[6];
        unionArgs[0] = function;
        CoreOperationUnion union = new CoreOperationUnion(unionArgs);
        
        try {
            union.computeValue(null);
            fail("Expected RuntimeException for incorrect arguments");
        } catch (RuntimeException e) {
            // Verify exception mentions incorrect argument count
            assertTrue(e.getMessage().contains("Incorrect number of arguments"));
        }
    }

    @Test(timeout = 4000)
    public void testCoreOperationUnionComputeWithUnionArgument() throws Throwable {
        // Test CoreOperationUnion containing another union in arguments
        Expression[] functionArgs = new Expression[8];
        CoreFunction function = new CoreFunction(16, functionArgs); // normalize-space
        
        CoreOperationLessThanOrEqual comparison = 
            new CoreOperationLessThanOrEqual(function, function);
        CoreOperationNegate negate = new CoreOperationNegate(comparison);
        
        // Create union with function and negate
        Expression[] innerUnionArgs = new Expression[6];
        innerUnionArgs[0] = function;
        innerUnionArgs[1] = negate;
        CoreOperationUnion innerUnion = new CoreOperationUnion(innerUnionArgs);
        
        // Set the function argument to the inner union
        functionArgs[1] = innerUnion;
        
        // Create outer union containing the function
        Expression[] outerUnionArgs = new Expression[6];
        outerUnionArgs[0] = function;
        CoreOperationUnion outerUnion = new CoreOperationUnion(outerUnionArgs);
        
        try {
            outerUnion.computeValue(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected during evaluation
        }
    }

    @Test(timeout = 4000)
    public void testNameAttributeTestComputeWithNullContext() throws Throwable {
        // Test that NameAttributeTest throws NPE when compute is called with null context
        NameAttributeTest test = new NameAttributeTest(null, null);
        
        try {
            test.compute(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected due to null expressions
        }
    }
}