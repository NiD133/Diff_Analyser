package org.jsoup.helper;

import org.jsoup.Jsoup;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.ByteArrayInputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;

import static org.jsoup.TextUtil.normalizeSpaces;
import static org.jsoup.nodes.Document.OutputSettings.Syntax.xml;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for W3CDom conversion in special or edge-case scenarios.
 */
@DisplayName("W3CDom Special Cases")
class W3CDomSpecialCasesTest {

    private static final String HTML_WITH_INVALID_CHARS_IN_TAGS = "<foo<bar attr<name=\"123\"><b>Text</b></foo<bar>";
    private static final String EXPECTED_XML_WITH_SANITIZED_TAGS = "<foo_bar attr_name=\"123\"><b>Text</b></foo_bar>";

    private static DocumentBuilderFactory documentBuilderFactory;

    @BeforeAll
    static void setUp() {
        documentBuilderFactory = DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setNamespaceAware(true);
    }

    /**
     * Provides both the HTML and XML parsers for parameterized tests.
     */
    private static Stream<Arguments> parserProvider() {
        return Stream.of(
            Arguments.of(Parser.htmlParser()),
            Arguments.of(Parser.xmlParser())
        );
    }

    @DisplayName("Should not expand XML entities to prevent billion laughs attack")
    @ParameterizedTest(name = "with {0}")
    @MethodSource("parserProvider")
    void doesNotExpandEntities(Parser parser) {
        // This test ensures that Jsoup's conversion to W3C DOM does not parse and expand
        // entities within a DOCTYPE, which is a vector for XML External Entity (XXE) attacks
        // like the "billion laughs" attack.
        String billionLaughsXml = """
            <?xml version="1.0"?>
            <!DOCTYPE lolz [
             <!ENTITY lol "lol">
             <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
            ]>
            <html><body><p>&lol1;</p></body></html>""";

        // Arrange
        org.jsoup.nodes.Document jsoupDoc = Jsoup.parse(billionLaughsXml, parser);

        // Act
        W3CDom w3cDom = new W3CDom();
        Document w3cDoc = w3cDom.fromJsoup(jsoupDoc);
        String w3cString = W3CDom.asString(w3cDoc, W3CDom.OutputXml());

        // Assert
        NodeList pElements = w3cDoc.getElementsByTagName("p");
        assertEquals(1, pElements.getLength(), "Should find one <p> element");
        assertEquals("&lol1;", pElements.item(0).getTextContent(), "Entity should not be expanded in text content");

        assertFalse(w3cString.contains("lololol"), "Serialized string should not contain expanded entities");
        assertTrue(w3cString.contains("&amp;lol1;"), "Serialized string should contain the unexpanded, escaped entity");
    }

    @Test
    @DisplayName("Should replace invalid characters in tag and attribute names during W3C conversion")
    void w3cConversionReplacesInvalidCharsInNames() {
        // Verifies that when converting a Jsoup document to a W3C DOM,
        // characters that are invalid in XML tag/attribute names (like '<') are replaced.
        // Arrange
        org.jsoup.nodes.Document jsoupDoc = Jsoup.parse(HTML_WITH_INVALID_CHARS_IN_TAGS);

        // Act
        Document w3cDoc = W3CDom.convert(jsoupDoc);

        // Assert
        NodeList nodes = w3cDoc.getElementsByTagName("foo_bar");
        assertEquals(1, nodes.getLength(), "Should find one element with the sanitized name 'foo_bar'");

        Node element = nodes.item(0);
        Node attr = element.getAttributes().getNamedItem("attr_name");
        assertNotNull(attr, "Should find attribute with the sanitized name 'attr_name'");
        assertEquals("123", attr.getTextContent());
    }

    @Test
    @DisplayName("Should produce valid XML from HTML with invalid characters in names")
    void xmlGeneratedFromHtmlWithInvalidCharsIsValidW3cXml() throws Exception {
        // This test confirms that the XML string generated by Jsoup (with sanitized names)
        // can be successfully parsed by a standard W3C XML parser.
        // Arrange
        org.jsoup.nodes.Document jsoupDoc = Jsoup.parse(HTML_WITH_INVALID_CHARS_IN_TAGS);
        jsoupDoc.outputSettings().syntax(xml);
        String generatedXml = jsoupDoc.body().html();
        assertEquals(EXPECTED_XML_WITH_SANITIZED_TAGS, normalizeSpaces(generatedXml));

        // Act
        Document w3cDoc = parseXml(generatedXml);

        // Assert
        NodeList nodes = w3cDoc.getElementsByTagName("foo_bar");
        assertEquals(1, nodes.getLength(), "W3C parser should find the sanitized element");

        Node element = nodes.item(0);
        Node attr = element.getAttributes().getNamedItem("attr_name");
        assertNotNull(attr, "W3C parser should find the sanitized attribute");
        assertEquals("123", attr.getTextContent());
    }

    /**
     * Helper to parse an XML string into a W3C Document using a standard parser.
     * @param xml The XML string to parse.
     * @return A W3C Document.
     */
    private Document parseXml(String xml) throws Exception {
        DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();
        // Prevent DTD validation for this test helper
        builder.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
        
        byte[] bytes = xml.getBytes(StandardCharsets.UTF_8);
        Document dom = builder.parse(new ByteArrayInputStream(bytes));
        dom.normalizeDocument();
        return dom;
    }
}