/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 19:48:55 GMT 2025
 */

package org.threeten.extra.chrono;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.time.Clock;
import java.time.DateTimeException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.chrono.ChronoLocalDateTime;
import java.time.chrono.ChronoPeriod;
import java.time.chrono.ChronoZonedDateTime;
import java.time.chrono.Era;
import java.time.chrono.IsoEra;
import java.time.chrono.JapaneseEra;
import java.time.chrono.MinguoEra;
import java.time.chrono.ThaiBuddhistEra;
import java.time.format.ResolverStyle;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalAmount;
import java.time.temporal.TemporalField;
import java.time.temporal.ValueRange;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.time.MockClock;
import org.evosuite.runtime.mock.java.time.MockInstant;
import org.evosuite.runtime.mock.java.time.MockZonedDateTime;
import org.junit.runner.RunWith;
import org.threeten.extra.chrono.BritishCutoverChronology;
import org.threeten.extra.chrono.BritishCutoverDate;
import org.threeten.extra.chrono.JulianEra;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class BritishCutoverChronology_ESTest extends BritishCutoverChronology_ESTest_scaffolding {

    // Test Constants
    private static final int INVALID_MONTH = 1000;
    private static final int CUTOVER_YEAR = 1752;
    private static final long EPOCH_DAY_VALID = 763L;
    private static final long EPOCH_DAY_INVALID = -2135812540L;
    private static final int YEAR_INVALID = 1737;
    private static final int DAY_INVALID = -5738;

    private final BritishCutoverChronology chronology = BritishCutoverChronology.INSTANCE;

    //-----------------------------------------------------------------------
    // Tests for date creation with invalid parameters
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000, expected = DateTimeException.class)
    public void creatingDateWithInvalidMonthThrowsException() {
        JulianEra era = JulianEra.AD;
        chronology.date(era, 6, INVALID_MONTH, 1);
    }

    @Test(timeout = 4000)
    public void creatingZonedDateTimeFromInstantSucceeds() {
        Instant instant = MockInstant.ofEpochSecond(1004L, (-1721L));
        ZoneOffset zoneOffset = ZoneOffset.UTC;
        ChronoZonedDateTime<BritishCutoverDate> result = 
            chronology.zonedDateTime(instant, zoneOffset);
        assertNotNull("Should successfully create zoned date time", result);
    }

    @Test(timeout = 4000)
    public void resolvingDateWithValidEpochDaySucceeds() {
        Map<TemporalField, Long> fieldValues = new HashMap<>();
        fieldValues.put(ChronoField.EPOCH_DAY, EPOCH_DAY_VALID);
        ResolverStyle style = ResolverStyle.STRICT;
        
        BritishCutoverDate result = chronology.resolveDate(fieldValues, style);
        assertNotNull("Should resolve valid epoch day", result);
    }

    @Test(timeout = 4000)
    public void prolepticYearForADShouldReturnSameValue() {
        JulianEra era = JulianEra.AD;
        int year = 13;
        int result = chronology.prolepticYear(era, year);
        assertEquals("AD proleptic year should match input", year, result);
    }

    @Test(timeout = 4000)
    public void convertingZonedDateTimeToLocalDateTimeSucceeds() {
        ZonedDateTime zdt = MockZonedDateTime.now();
        ChronoLocalDateTime<BritishCutoverDate> result = 
            chronology.localDateTime(zdt);
        assertNotNull("Should convert ZonedDateTime to local date-time", result);
    }

    //-----------------------------------------------------------------------
    // Tests for leap year behavior
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000)
    public void nonLeapYearShouldBeDetectedCorrectly() {
        assertFalse("371 should not be a leap year", chronology.isLeapYear(371));
    }

    @Test(timeout = 4000)
    public void dateYearDayWithBcEraCreatesValidDate() {
        JulianEra era = JulianEra.BC;
        BritishCutoverDate date = chronology.dateYearDay(era, 5, 5);
        assertNotNull("Should create valid date for BC era", date);
    }

    @Test(timeout = 4000)
    public void dateYearDayWithValidParamsCreatesDate() {
        BritishCutoverDate date = chronology.dateYearDay(103, 103);
        assertNotNull("Should create valid date for year/day", date);
    }

    //-----------------------------------------------------------------------
    // Tests for current date retrieval
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000)
    public void currentDateWithSystemZoneSucceeds() {
        ZoneId zone = ZoneId.systemDefault();
        BritishCutoverDate date = chronology.dateNow(zone);
        assertNotNull("Should get current date with system zone", date);
    }

    @Test(timeout = 4000)
    public void dateFromEpochDaySucceedsForValidInput() {
        BritishCutoverDate date = chronology.dateEpochDay(-1813L);
        assertNotNull("Should create date from epoch day", date);
    }

    @Test(timeout = 4000)
    public void dateFromTemporalAccessorReturnsSameInstance() {
        BritishCutoverDate now = chronology.dateNow();
        BritishCutoverDate result = chronology.date(now);
        assertSame("Should return same instance when passing temporal", now, result);
    }

    @Test(timeout = 4000)
    public void dateWithYearMonthDayCreatesValidInstance() {
        BritishCutoverDate date = chronology.date(12, 6, 12);
        assertNotNull("Should create valid date from year/month/day", date);
    }

    //-----------------------------------------------------------------------
    // Tests for exception handling
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000, expected = DateTimeException.class)
    public void zonedDateTimeFromLocalDateThrowsException() {
        chronology.zonedDateTime(chronology.getCutover());
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void resolveDateWithNullMapThrowsException() {
        chronology.resolveDate(null, ResolverStyle.SMART);
    }

    @Test(timeout = 4000, expected = NullPointerException.class)
    public void rangeWithNullFieldThrowsException() {
        chronology.range(null);
    }

    @Test(timeout = 4000, expected = DateTimeException.class)
    public void localDateTimeFromLocalDateThrowsException() {
        chronology.localDateTime(chronology.getCutover());
    }

    @Test(timeout = 4000, expected = DateTimeException.class)
    public void eraOfWithInvalidValueThrowsException() {
        chronology.eraOf(4);
    }

    @Test(timeout = 4000, expected = DateTimeException.class)
    public void dateYearDayWithInvalidDayThrowsException() {
        JulianEra era = JulianEra.BC;
        chronology.dateYearDay(era, 1778, DAY_INVALID);
    }

    //-----------------------------------------------------------------------
    // Tests for calendar system properties
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000)
    public void rangeForYearOfEraFieldIsCorrect() {
        ValueRange range = chronology.range(ChronoField.YEAR_OF_ERA);
        assertNotNull("Should get valid range for YEAR_OF_ERA", range);
    }

    @Test(timeout = 4000)
    public void prolepticYearForBCShouldConvertCorrectly() {
        JulianEra era = JulianEra.BC;
        int result = chronology.prolepticYear(era, 1778);
        assertEquals("BC proleptic year conversion incorrect", -1777, result);
    }

    @Test(timeout = 4000)
    public void cutoverYearIsLeapYear() {
        assertTrue("1752 should be leap year", chronology.isLeapYear(CUTOVER_YEAR));
    }

    @Test(timeout = 4000)
    public void getIdReturnsCorrectIdentifier() {
        assertEquals("Calendar ID should match", "BritishCutover", chronology.getId());
    }

    @Test(timeout = 4000)
    public void calendarHasTwoEras() {
        List<Era> eras = chronology.eras();
        assertEquals("Should have two eras", 2, eras.size());
    }

    @Test(timeout = 4000)
    public void dateNowWithClockSucceeds() {
        Clock clock = MockClock.systemDefaultZone();
        BritishCutoverDate date = chronology.dateNow(clock);
        assertNotNull("Should get current date with clock", date);
    }

    @Test(timeout = 4000)
    public void eraOfBCShouldBeResolvedCorrectly() {
        Era era = chronology.eraOf(0);
        assertEquals("Era value 0 should be BC", JulianEra.BC, era);
    }

    //-----------------------------------------------------------------------
    // Tests for conversion methods
    //-----------------------------------------------------------------------
    
    @Test(timeout = 4000)
    public void zonedDateTimeFromZonedDateTimeTemporalSucceeds() {
        ZonedDateTime zdt = MockZonedDateTime.now();
        ChronoZonedDateTime<BritishCutoverDate> result = 
            chronology.zonedDateTime(zdt);
        assertNotNull("Should convert ZonedDateTime", result);
    }

    @Test(timeout = 4000)
    public void resolveDateWithEmptyMapReturnsNull() {
        Map<TemporalField, Long> fields = new HashMap<>();
        BritishCutoverDate result = 
            chronology.resolveDate(fields, ResolverStyle.STRICT);
        assertNull("Empty map should return null", result);
    }

    @Test(timeout = 4000)
    public void getCutoverReturnsCorrectDate() {
        LocalDate cutover = chronology.getCutover();
        assertNotNull("Cutover date should be available", cutover);
    }
}