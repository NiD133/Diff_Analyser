/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability
 */
package com.fasterxml.jackson.core.io;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.fasterxml.jackson.core.ErrorReportConfiguration;
import com.fasterxml.jackson.core.StreamReadConstraints;
import com.fasterxml.jackson.core.StreamWriteConstraints;
import com.fasterxml.jackson.core.io.ContentReference;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.io.MergedStream;
import com.fasterxml.jackson.core.util.BufferRecycler;
import java.io.*;
import java.util.Enumeration;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.junit.Before;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class MergedStream_ESTest extends MergedStream_ESTest_scaffolding {

    private StreamReadConstraints defaultReadConstraints;
    private StreamWriteConstraints defaultWriteConstraints;
    private ErrorReportConfiguration defaultErrorConfig;
    private BufferRecycler bufferRecycler;
    private ContentReference contentReference;

    @Before
    public void initCommonObjects() {
        defaultReadConstraints = StreamReadConstraints.defaults();
        defaultWriteConstraints = StreamWriteConstraints.defaults();
        defaultErrorConfig = ErrorReportConfiguration.defaults();
        bufferRecycler = new BufferRecycler();
        contentReference = ContentReference.unknown();
    }

    // ======================================================
    // Skip Operation Tests
    // ======================================================

    @Test(timeout = 4000)
    public void skipNegativeValue_ReturnsZero() throws Throwable {
        IOContext context = createIOContext();
        PipedInputStream input = new PipedInputStream(3);
        byte[] buffer = new byte[2];
        MergedStream stream = new MergedStream(context, input, buffer, 255, 1000);
        MergedStream nestedStream = new MergedStream(context, stream, null, -2145635554, -2755);

        long skipped = nestedStream.skip(-838L);
        assertEquals(0L, skipped);
    }

    @Test(timeout = 4000)
    public void skipLargeValue_SkipsCorrectly() throws Throwable {
        PipedInputStream input = new PipedInputStream(2914);
        byte[] buffer = new byte[8];
        MergedStream stream = new MergedStream(null, input, buffer, -1, 50000);
        MergedStream nestedStream = new MergedStream(null, stream, buffer, 255, 15);

        long skipped = nestedStream.skip(1261L);
        assertEquals(1261L, skipped);
    }

    @Test(timeout = 4000)
    public void skipZero_ReturnsZero() throws Throwable {
        PipedInputStream input = new PipedInputStream(2914);
        byte[] buffer = new byte[8];
        MergedStream stream = new MergedStream(null, input, buffer, 0, 0);

        long skipped = stream.skip(0);
        assertEquals(0L, skipped);
    }

    @Test(timeout = 4000)
    public void skipOne_ReturnsOne() throws Throwable {
        PipedInputStream input = new PipedInputStream(2914);
        byte[] buffer = new byte[8];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 2914);

        long skipped = stream.skip(1);
        assertEquals(1L, skipped);
    }

    @Test(timeout = 4000)
    public void skipWithInvalidBuffer_ReturnsNegative() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[1];
        MergedStream stream = new MergedStream(null, input, buffer, -629, -629);

        long skipped = stream.skip(-629);
        assertEquals(-629L, skipped);
    }

    @Test(timeout = 4000)
    public void skipWithUnconnectedPipe_ThrowsIOException() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[20];
        MergedStream stream = new MergedStream(null, input, buffer, 98, 98);

        try {
            stream.skip(98);
            fail("Expected IOException due to unconnected pipe");
        } catch (IOException e) {
            assertEquals("Pipe not connected", e.getMessage());
        }
    }

    // ======================================================
    // Read Operation Tests
    // ======================================================

    @Test(timeout = 4000)
    public void readByteFromBuffer_ReturnsCorrectValue() throws Throwable {
        IOContext context = createIOContext();
        PipedOutputStream out = new PipedOutputStream();
        PipedInputStream in = new PipedInputStream(out, 20000000);
        byte[] buffer = new byte[2];
        buffer[0] = (byte) -25;
        MergedStream stream = new MergedStream(context, in, buffer, 0, 2);

        int result = stream.read();
        assertEquals(231, result); // -25 signed byte = 231 unsigned
    }

    @Test(timeout = 4000)
    public void readAfterExhaustingBuffer_ReturnsMinusOne() throws Throwable {
        Enumeration<FilterInputStream> emptyEnum = mock(Enumeration.class);
        doReturn(false).when(emptyEnum).hasMoreElements();
        SequenceInputStream seqInput = new SequenceInputStream(emptyEnum);
        byte[] buffer = new byte[7];
        MergedStream stream = new MergedStream(null, seqInput, buffer, 0, 0);

        assertEquals(0, stream.read()); // Reads from empty buffer
        assertEquals(-1, stream.read()); // Then tries underlying stream
    }

    @Test(timeout = 4000)
    public void readWithNullBuffer_ReturnsMinusOne() throws Throwable {
        Enumeration<FilterInputStream> emptyEnum = mock(Enumeration.class);
        doReturn(false).when(emptyEnum).hasMoreElements();
        SequenceInputStream seqInput = new SequenceInputStream(emptyEnum);
        MergedStream stream = new MergedStream(createIOContext(), seqInput, null, 64, 256);

        int result = stream.read(null, 0, 256);
        assertEquals(-1, result);
    }

    @Test(timeout = 4000)
    public void readWithInvalidOffset_ThrowsIndexOutOfBounds() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[12];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 1);
        stream.read(buffer); // Fill the buffer first

        try {
            stream.read(buffer, -794, 0);
            fail("Expected IndexOutOfBoundsException for negative offset");
        } catch (IndexOutOfBoundsException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void readWithInvalidLength_ThrowsArrayIndexException() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[12];
        MergedStream stream = new MergedStream(null, input, buffer, -10, -10);

        try {
            stream.read(buffer, -10, -10);
            fail("Expected ArrayIndexOutOfBoundsException for negative length");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void readAfterBufferExhaustion_ThrowsIOException() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[12];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 1);
        stream.read(buffer, 1, 1); // Exhaust buffer

        try {
            stream.read(buffer, 1, 1);
            fail("Expected IOException due to unconnected pipe");
        } catch (IOException e) {
            assertEquals("Pipe not connected", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void readWithInvalidBufferOffset_ThrowsArrayIndexException() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[1];
        MergedStream stream = new MergedStream(null, input, buffer, 98, 98);

        try {
            stream.read();
            fail("Expected ArrayIndexOutOfBoundsException for invalid offset");
        } catch (ArrayIndexOutOfBoundsException e) {
            assertTrue(e.getMessage().contains("98"));
        }
    }

    @Test(timeout = 4000)
    public void readWithZeroLength_ReturnsZero() throws Throwable {
        IOContext context = createIOContext();
        PipedOutputStream out = new PipedOutputStream();
        PipedInputStream in = new PipedInputStream(out, 20000000);
        byte[] buffer = new byte[2];
        MergedStream stream = new MergedStream(context, in, buffer, 0, 2);

        int read = stream.read(buffer, 0, 0);
        assertEquals(0, read);
    }

    @Test(timeout = 4000)
    public void readAfterBufferRead_ThrowsIOException() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[12];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 1);
        stream.read(buffer, 1, 1); // Exhaust buffer

        try {
            stream.read();
            fail("Expected IOException due to unconnected pipe");
        } catch (IOException e) {
            assertEquals("Pipe not connected", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void readWithNullBufferReference_ThrowsNullPointerException() throws Throwable {
        MergedStream stream = new MergedStream(null, null, null, -1, -1);

        try {
            stream.read(null, -1, -1);
            fail("Expected NullPointerException for null buffer");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void readIntoBuffer_ReturnsBytesRead() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[1];
        MergedStream stream = new MergedStream(null, input, buffer, 0, 97);

        int read = stream.read(buffer);
        assertEquals(1, read);
    }

    // ======================================================
    // Available Operation Tests
    // ======================================================

    @Test(timeout = 4000)
    public void availableWithValidBuffer_ReturnsRemainingBytes() throws Throwable {
        PipedInputStream input = new PipedInputStream(2914);
        byte[] buffer = new byte[8];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 2914);

        int available = stream.available();
        assertEquals(2913, available); // 2914 total - 1 already read
    }

    @Test(timeout = 4000)
    public void availableWithInvalidBuffer_ReturnsNegative() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[5];
        IOContext context = new IOContext(
            defaultReadConstraints,
            null,
            defaultErrorConfig,
            bufferRecycler,
            ContentReference.UNKNOWN_CONTENT,
            false
        );
        MergedStream stream = new MergedStream(context, input, buffer, 2, -1357);

        int available = stream.available();
        assertEquals(-1359, available);
    }

    @Test(timeout = 4000)
    public void availableAfterBufferRead_ReturnsZero() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[1];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 1);

        int available = stream.available();
        assertEquals(0, available);
    }

    @Test(timeout = 4000)
    public void availableWithEmptyFile_ReturnsZero() throws Throwable {
        IOContext context = createIOContext();
        File file = MockFile.createTempFile("temp", "file");
        MockFileInputStream fileInput = new MockFileInputStream(file);
        MergedStream stream = new MergedStream(context, fileInput, null, 50000, 0);

        int available = stream.available();
        assertEquals(0, available);
    }

    // ======================================================
    // Mark/Reset Operation Tests
    // ======================================================

    @Test(timeout = 4000)
    public void markSupportedWithBufferedStream_ReturnsTrue() throws Throwable {
        IOContext context = createIOContext();
        PipedInputStream pipeInput = new PipedInputStream();
        BufferedInputStream bufferedInput = new BufferedInputStream(pipeInput);
        MergedStream stream = new MergedStream(context, bufferedInput, null, 65536, 3);

        boolean supported = stream.markSupported();
        assertTrue(supported);
    }

    @Test(timeout = 4000)
    public void markSupportedWithPipedStream_ReturnsFalse() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        MergedStream stream = new MergedStream(null, input, null, -1, -1);

        boolean supported = stream.markSupported();
        assertFalse(supported);
    }

    @Test(timeout = 4000)
    public void markSupportedWithInvalidBuffer_ReturnsFalse() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[20];
        MergedStream stream = new MergedStream(null, input, buffer, 98, 98);

        boolean supported = stream.markSupported();
        assertFalse(supported);
    }

    @Test(timeout = 4000)
    public void resetUnsupportedStream_ThrowsIOException() throws Throwable {
        IOContext context = createIOContext();
        PipedOutputStream out = new PipedOutputStream();
        PipedInputStream in = new PipedInputStream(out, 500);
        MergedStream stream = new MergedStream(context, in, null, 2541, 2);

        try {
            stream.reset();
            fail("Expected IOException for unsupported reset");
        } catch (IOException e) {
            assertEquals("mark/reset not supported", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void resetAfterMark_DoesNothing() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[12];
        MergedStream stream = new MergedStream(null, input, buffer, 1, 1);
        stream.reset(); // Should do nothing without exception
    }

    @Test(timeout = 4000)
    public void markInvalidBuffer_DoesNothing() throws Throwable {
        PipedInputStream input = new PipedInputStream();
        byte[] buffer = new byte[1];
        MergedStream stream = new MergedStream(null, input, buffer, -629, -629);
        stream.mark(-629); // Should not throw
    }

    // ======================================================
    // Close Operation Tests
    // ======================================================

    @Test(timeout = 4000)
    public void closeStream_CompletesSuccessfully() throws Throwable {
        IOContext context = createIOContext();
        Enumeration<FilterInputStream> emptyEnum = mock(Enumeration.class);
        doReturn(false).when(emptyEnum).hasMoreElements();
        SequenceInputStream seqInput = new SequenceInputStream(emptyEnum);
        MergedStream stream = new MergedStream(context, seqInput, null, 1, 999);

        stream.close(); // Should not throw
    }

    @Test(timeout = 4000)
    public void closeWithNullStream_ThrowsNullPointerException() throws Throwable {
        byte[] buffer = new byte[3];
        MergedStream stream = new MergedStream(null, null, buffer, 0, 98);

        try {
            stream.close();
            fail("Expected NullPointerException for null stream");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    // ======================================================
    // Exception Scenario Tests
    // ======================================================

    @Test(timeout = 4000)
    public void skipNegativeValue_ThrowsNullPointerException() throws Throwable {
        IOContext context = createIOContext();
        byte[] buffer = new byte[0];
        ByteArrayInputStream byteInput = new ByteArrayInputStream(buffer);
        PushbackInputStream pushbackInput = new PushbackInputStream(byteInput);
        MergedStream stream = new MergedStream(context, pushbackInput, buffer, 1000, 200);

        try {
            stream.skip(-240L);
            fail("Expected NullPointerException from IOContext");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void readNullBuffer_ThrowsNullPointerException() throws Throwable {
        IOContext context = createIOContext();
        PipedOutputStream out = new PipedOutputStream();
        PipedInputStream in = new PipedInputStream(out, 20000000);
        byte[] buffer = new byte[2];
        MergedStream stream = new MergedStream(context, in, buffer, 0, 2);

        try {
            stream.read(buffer);
            fail("Expected NullPointerException from IOContext");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void markSupportedWithNullStream_ThrowsNullPointerException() throws Throwable {
        IOContext context = createIOContext();
        MergedStream stream = new MergedStream(context, null, null, 732, -2929);

        try {
            stream.markSupported();
            fail("Expected NullPointerException for null stream");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    // ======================================================
    // Helper Methods
    // ======================================================

    private IOContext createIOContext() {
        return new IOContext(
            defaultReadConstraints,
            defaultWriteConstraints,
            defaultErrorConfig,
            bufferRecycler,
            contentReference,
            true
        );
    }
}