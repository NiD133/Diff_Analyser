/*
 * This file was automatically generated by EvoSuite
 * Mon Jul 21 14:22:57 GMT 2025
 */

package org.apache.commons.collections4.bloomfilter;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.apache.commons.collections4.bloomfilter.ArrayCountingBloomFilter;
import org.apache.commons.collections4.bloomfilter.BitMapExtractor;
import org.apache.commons.collections4.bloomfilter.EnhancedDoubleHasher;
import org.apache.commons.collections4.bloomfilter.IndexExtractor;
import org.apache.commons.collections4.bloomfilter.Shape;
import org.apache.commons.collections4.bloomfilter.SimpleBloomFilter;
import org.apache.commons.collections4.bloomfilter.SparseBloomFilter;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class IndexExtractor_ESTest extends IndexExtractor_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testEmptyBloomFilterAsIndexArrayReturnsEmpty()  throws Throwable  {
      // Test that an empty bloom filter returns an empty index array
      Shape shape = Shape.fromKM(1856, 1856);
      SimpleBloomFilter emptyFilter = new SimpleBloomFilter(shape);
      int[] indices = emptyFilter.asIndexArray();
      assertEquals(0, indices.length);
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesWithInvalidShapeThrowsException()  throws Throwable  {
      // Test that uniqueIndices() throws when shape causes invalid indices
      EnhancedDoubleHasher hasher = new EnhancedDoubleHasher((-2285L), (-2285L));
      Shape invalidShape = Shape.fromNM(6, 2147352576);
      IndexExtractor extractor = hasher.indices(invalidShape);
      
      // Expecting exception due to invalid indices from hasher with given shape
      try { 
          extractor.uniqueIndices();
          fail("Expected exception due to invalid indices");
      } catch (Exception e) {
          // Expected exception
      }
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesFromNullArrayThrowsNPE()  throws Throwable  {
      // Test that uniqueIndices() throws NPE when created from null array
      IndexExtractor nullArrayExtractor = IndexExtractor.fromIndexArray((int[]) null);
      
      try { 
          nullArrayExtractor.uniqueIndices();
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          // Expected exception
      }
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesWithNegativeIndexThrowsIOOBE()  throws Throwable  {
      // Test that uniqueIndices() throws when index is negative
      int[] negativeIndexArray = new int[]{-1};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(negativeIndexArray);
      
      try { 
          extractor.uniqueIndices();
          fail("Expected IndexOutOfBoundsException for negative index");
      } catch (IndexOutOfBoundsException e) {
          // Verify exception message
          assertTrue(e.getMessage().contains("bitIndex < 0"));
      }
  }

  @Test(timeout = 4000)
  public void testFromBitMapExtractorWithNullThrowsNPE()  throws Throwable  {
      // Test that fromBitMapExtractor() validates null input
      try { 
          IndexExtractor.fromBitMapExtractor((BitMapExtractor) null);
          fail("Expected NullPointerException for null input");
      } catch (NullPointerException e) {
          // Verify exception message
          assertTrue(e.getMessage().contains("bitMapExtractor"));
      }
  }

  @Test(timeout = 4000)
  public void testAsIndexArrayFromNullArrayThrowsNPE()  throws Throwable  {
      // Test that asIndexArray() throws NPE when created from null array
      IndexExtractor nullArrayExtractor = IndexExtractor.fromIndexArray((int[]) null);
      
      try { 
          nullArrayExtractor.asIndexArray();
          fail("Expected NullPointerException");
      } catch (NullPointerException e) {
          // Expected exception
      }
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesWithMaxIntIndexThrowsDuringConversion()  throws Throwable  {
      // Test boundary condition with maximum integer index
      int[] maxIndexArray = {Integer.MAX_VALUE, 0, 0};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(maxIndexArray);
      IndexExtractor uniqueExtractor = extractor.uniqueIndices();
      
      try { 
          uniqueExtractor.asIndexArray();
          fail("Expected IndexOutOfBoundsException due to integer overflow");
      } catch (IndexOutOfBoundsException e) {
          // Verify exception message
          assertTrue(e.getMessage().contains("fromIndex < 0"));
      }
  }

  @Test(timeout = 4000)
  public void testContainsWithUniqueIndicesReturnsFalseForEmptyFilter()  throws Throwable  {
      // Test that empty filter doesn't contain any indices
      int[] duplicateIndices = {0, 0, 0, 0};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(duplicateIndices);
      IndexExtractor uniqueExtractor = extractor.uniqueIndices();
      
      Shape shape = Shape.fromKM(1867, 31);
      SimpleBloomFilter emptyFilter = new SimpleBloomFilter(shape);
      
      assertFalse(emptyFilter.contains(uniqueExtractor));
  }

  @Test(timeout = 4000)
  public void testAsIndexArrayFromBitMapExtractorReturnsCorrectSize()  throws Throwable  {
      // Test bit map extraction with specific bit pattern
      long[] bitMap = new long[3];
      bitMap[2] = -1L; // All bits set in last long
      BitMapExtractor bitmapExtractor = BitMapExtractor.fromBitMapArray(bitMap);
      IndexExtractor extractor = IndexExtractor.fromBitMapExtractor(bitmapExtractor);
      
      // Should return 64 indices (bits set in one long)
      int[] indices = extractor.asIndexArray();
      assertEquals(64, indices.length);
  }

  @Test(timeout = 4000)
  public void testContainsWithSingleZeroIndexReturnsFalse()  throws Throwable  {
      // Test that empty filter doesn't contain even the zero index
      int[] zeroIndexArray = {0};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(zeroIndexArray);
      
      Shape shape = Shape.fromNM(1624, 1624);
      ArrayCountingBloomFilter emptyFilter = new ArrayCountingBloomFilter(shape);
      
      assertFalse(emptyFilter.contains(extractor));
  }

  @Test(timeout = 4000)
  public void testAsIndexArrayFromBitMapExtractorWithSpecificValue()  throws Throwable  {
      // Test bit map extraction with specific numeric value
      long[] bitMap = {-2401L}; // Has 60 bits set
      BitMapExtractor bitmapExtractor = BitMapExtractor.fromBitMapArray(bitMap);
      IndexExtractor extractor = IndexExtractor.fromBitMapExtractor(bitmapExtractor);
      
      int[] indices = extractor.asIndexArray();
      assertEquals(60, indices.length);
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesRemovesDuplicates()  throws Throwable  {
      // Test that uniqueIndices() removes duplicate indices
      int[] duplicateIndices = {0, 0, 0, 0};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(duplicateIndices);
      IndexExtractor uniqueExtractor = extractor.uniqueIndices();
      
      int[] uniqueIndices = uniqueExtractor.asIndexArray();
      assertArrayEquals(new int[] {0}, uniqueIndices);
  }

  @Test(timeout = 4000)
  public void testUniqueIndicesOnUniqueExtractorReturnsSameInstance()  throws Throwable  {
      // Test that uniqueIndices() is idempotent for unique extractors
      int[] uniqueIndices = {1, 2, 3};
      IndexExtractor extractor = IndexExtractor.fromIndexArray(uniqueIndices);
      IndexExtractor uniqueExtractor = extractor.uniqueIndices();
      IndexExtractor doubleUniqueExtractor = uniqueExtractor.uniqueIndices();
      
      assertSame(uniqueExtractor, doubleUniqueExtractor);
  }
}