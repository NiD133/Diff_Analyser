/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 19 14:18:41 GMT 2025
 */

package org.joda.time.chrono;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTimeZone;
import org.joda.time.chrono.AssembledChronology;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.LenientChronology;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class EthiopicChronology_ESTest extends EthiopicChronology_ESTest_scaffolding {

    private static final int MIN_DAYS_IN_FIRST_WEEK = 4;
    private static final int MAX_YEAR = 292272984;
    private static final int MIN_YEAR = -292269337;
    private static final long APPROX_MILLIS_AT_EPOCH = 30962844000000L;

    // Test cases for getInstance() and constructor
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testGetInstance_WithCustomZoneAndMinDays_EEConstantIsOne() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-1962);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone, 1);
        assertEquals(1, EthiopicChronology.EE);
    }

    @Test(timeout = 4000)
    public void testGetInstance_WithInvalidMinDays_ThrowsIllegalArgumentException() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(1900);
        int invalidMinDays = -4898;
        try {
            EthiopicChronology.getInstance(zone, invalidMinDays);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Invalid min days in first week: -4898", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testGetInstance_WithAnotherInvalidMinDays_ThrowsIllegalArgumentException() {
        int invalidMinDays = 1767;
        try {
            EthiopicChronology.getInstance(null, invalidMinDays);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Invalid min days in first week: 1767", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testConstructor_WithInvalidMinDays_ThrowsIllegalArgumentException() {
        int invalidMinDays = -159;
        try {
            new EthiopicChronology(null, null, invalidMinDays);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertEquals("Invalid min days in first week: -159", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testConstructor_WithLenientChronologyAndMinDays_CreatesNewInstance() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-1962);
        EthiopicChronology base = EthiopicChronology.getInstance(zone);
        LenientChronology lenient = LenientChronology.getInstance(base);
        EthiopicChronology chrono = new EthiopicChronology(lenient, new Object(), 1);
        assertNotEquals(base, chrono);
    }

    // Test cases for isLeapDay()
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testIsLeapDay_WithNegativeInstant_ReturnsFalse() {
        EthiopicChronology chrono = EthiopicChronology.getInstance((DateTimeZone) null);
        boolean isLeap = chrono.isLeapDay(-56623968000000L);
        assertFalse(isLeap);
    }

    @Test(timeout = 4000)
    public void testIsLeapDay_WithMinLong_ThrowsIllegalArgumentException() {
        EthiopicChronology chrono = EthiopicChronology.getInstanceUTC();
        try {
            chrono.isLeapDay(Long.MIN_VALUE);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("The instant is below the supported minimum"));
        }
    }

    @Test(timeout = 4000)
    public void testIsLeapDay_WithMinLongAndNegativeOffset_ThrowsArithmeticException() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-4246);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        try {
            chrono.isLeapDay(Long.MIN_VALUE);
            fail("Expecting exception: ArithmeticException");
        } catch (ArithmeticException e) {
            assertEquals("Adding time zone offset caused overflow", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void testIsLeapDay_WithSpecificInstant_ReturnsTrue() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-833);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        long leapInstant = 3461702400000L;  // Known leap day
        boolean isLeap = chrono.isLeapDay(leapInstant);
        assertTrue(isLeap);
    }

    @Test(timeout = 4000)
    public void testIsLeapDay_WithAnotherInstant_ReturnsFalse() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-2263);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        long nonLeapInstant = 1209600011L;  // Known non-leap day
        boolean isLeap = chrono.isLeapDay(nonLeapInstant);
        assertFalse(isLeap);
    }

    @Test(timeout = 4000)
    public void testIsLeapDay_WithSmallInstant_ReturnsFalse() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-1962);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        boolean isLeap = chrono.isLeapDay(-2899);
        assertFalse(isLeap);
    }

    // Test cases for calculateFirstDayOfYearMillis()
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testCalculateFirstDayOfYearMillis_WithLargeYear_ReturnsExpectedValue() {
        EthiopicChronology chrono = EthiopicChronology.getInstanceUTC();
        int year = 15271875;
        long expected = 481881796790400000L;
        long actual = chrono.calculateFirstDayOfYearMillis(year);
        assertEquals(expected, actual);
    }

    @Test(timeout = 4000)
    public void testCalculateFirstDayOfYearMillis_WithYear1_ReturnsNegativeValue() {
        EthiopicChronology chrono = EthiopicChronology.getInstance();
        long actual = chrono.calculateFirstDayOfYearMillis(1);
        assertEquals(-61894108800000L, actual);
    }

    @Test(timeout = 4000)
    public void testCalculateFirstDayOfYearMillis_WithMaxYear_ReturnsExpectedValue() {
        EthiopicChronology chrono = EthiopicChronology.getInstanceUTC();
        long expected = 9223371994233600000L;
        long actual = chrono.calculateFirstDayOfYearMillis(MAX_YEAR);
        assertEquals(expected, actual);
    }

    // Test cases for getMaxYear(), getMinYear(), and getApproxMillisAtEpochDividedByTwo()
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testGetMaxYear_ReturnsConstantValue() {
        EthiopicChronology chrono = EthiopicChronology.getInstanceUTC();
        assertEquals(MAX_YEAR, chrono.getMaxYear());
    }

    @Test(timeout = 4000)
    public void testGetMinYear_ReturnsConstantValue() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-1962);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        assertEquals(MIN_YEAR, chrono.getMinYear());
    }

    @Test(timeout = 4000)
    public void testGetApproxMillisAtEpochDividedByTwo_ReturnsConstantValue() {
        EthiopicChronology chrono = EthiopicChronology.getInstance();
        assertEquals(APPROX_MILLIS_AT_EPOCH, chrono.getApproxMillisAtEpochDividedByTwo());
    }

    // Test cases for assemble()
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testAssemble_AfterAssembly_EEConstantIsOne() {
        EthiopicChronology chrono = EthiopicChronology.getInstanceUTC();
        AssembledChronology.Fields fields = new AssembledChronology.Fields();
        chrono.assemble(fields);  // Verify no exception
        assertEquals(1, EthiopicChronology.EE);
    }

    // Test cases for withZone() and withUTC()
    //--------------------------------------------------------------------

    @Test(timeout = 4000)
    public void testWithZone_NullZone_ReturnsSameChronology() {
        EthiopicChronology chrono = EthiopicChronology.getInstance((DateTimeZone) null);
        Chronology result = chrono.withZone((DateTimeZone) null);
        assertSame(chrono, result);
    }

    @Test(timeout = 4000)
    public void testWithZone_UTC_ReturnsChronologyWithSameEE() {
        EthiopicChronology chrono = EthiopicChronology.getInstance();
        Chronology utcChrono = chrono.withZone(DateTimeZone.UTC);
        assertEquals(1, EthiopicChronology.EE);
    }

    @Test(timeout = 4000)
    public void testWithUTC_FromCustomZone_ReturnsDifferentChronology() {
        DateTimeZone zone = DateTimeZone.forOffsetMillis(-1962);
        EthiopicChronology chrono = EthiopicChronology.getInstance(zone);
        Chronology utcChrono = chrono.withUTC();
        assertNotSame(chrono, utcChrono);
    }
}