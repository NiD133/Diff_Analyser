/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 19 13:39:59 GMT 2025
 */

package org.jsoup.parser;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.UncheckedIOException;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.CDataNode;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.LeafNode;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;
import org.jsoup.parser.StreamParser;
import org.jsoup.parser.TagSet;
import org.jsoup.parser.Token;
import org.jsoup.parser.Tokeniser;
import org.jsoup.parser.XmlTreeBuilder;
import org.jsoup.select.Elements;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class XmlTreeBuilder_ESTest extends XmlTreeBuilder_ESTest_scaffolding {

    // Test handling of start tags and stack operations
    @Test(timeout = 4000)
    public void testProcessStartTagAndPopStackToClose() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        // Setup elements and parse fragment
        Element element = new Element("http://www.w3.org/1998/Math/MathML", "http://www.w3.org/XML/1998/namespace");
        streamParser.parseFragment("http://www.w3.org/XML/1998/namespace", element, "http://www.w3.org/1999/xhtml");
        
        // Process start tags
        builder.processStartTag("http://www.w3.org/1998/Math/MathML", null);
        Token.EndTag endTag = new Token.EndTag(builder);
        boolean processResult = builder.processStartTag("~BQ~ug8>");
        assertTrue(processResult);
        
        // Close stack and verify namespace
        builder.popStackToClose(endTag);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test NullPointerException when processing start tag with missing context
    @Test(timeout = 4000)
    public void testProcessStartTagThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse("jHQIs@:5#c&", "2#0f[w|.T$lBU[oa^f");
        
        try {
            builder.processStartTag(":contains(%s)");
            fail("Expected NullPointerException due to missing context");
        } catch (NullPointerException e) {
            // Expected: TreeBuilder state not initialized properly
        }
    }

    // Test exception during fragment initialization
    @Test(timeout = 4000)
    public void testInitialiseParseFragmentThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = new Document("d/uP=K>");
        Element element = doc.head();
        
        try {
            builder.initialiseParseFragment(element);
            fail("Expected NullPointerException due to invalid context");
        } catch (NullPointerException e) {
            // Expected: HashMap requires non-null key in namespace handling
        }
    }

    // Test namespace consistency after stack operations
    @Test(timeout = 4000)
    public void testPopStackToCloseMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse(">: ", ">: ");
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        // Parse fragment and close stack
        streamParser.parseFragment("http://www.w3.org/2000/svg", doc, "http://www.w3.org/XML/1998/namespace");
        Token.EndTag endTag = new Token.EndTag(builder);
        builder.popStackToClose(endTag);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test insertion of comment node maintains namespace
    @Test(timeout = 4000)
    public void testInsertCommentNodeMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse(">: ", ">: ");
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        streamParser.parseFragment("http://www.w3.org/2000/svg", doc, "http://www.w3.org/XML/1998/namespace");
        Comment comment = new Comment("KRq7");
        builder.insertLeafNode(comment);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test doctype insertion maintains namespace
    @Test(timeout = 4000)
    public void testInsertDoctypeMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("http://www.w3.org/1999/xhtml", "http://www.w3.org/XML/1998/namespace");
        streamParser.parseFragment("z>!GVh", element, "u");
        Token.Doctype doctype = new Token.Doctype();
        builder.insertDoctypeFor(doctype);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test comment insertion maintains namespace
    @Test(timeout = 4000)
    public void testInsertCommentForTokenMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse(">: ", ">: ");
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        streamParser.parseFragment("}VF\"~1WF,kf?;\"Lf2", doc, "");
        Token.Comment commentToken = new Token.Comment();
        builder.insertCommentFor(commentToken);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test character insertion maintains namespace
    @Test(timeout = 4000)
    public void testInsertCharacterForTokenMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse("", "");
        Elements elements = doc.getAllElements();
        builder.stack = (ArrayList<Element>) elements;
        Token.Character characterToken = new Token.Character();
        builder.insertCharacterFor(characterToken);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test namespace after parser initialization
    @Test(timeout = 4000)
    public void testInitialiseParseSetsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        StringReader reader = new StringReader("xmlns:#text");
        Parser parser = Parser.xmlParser();
        builder.initialiseParse(reader, "xmlns:#text", parser);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test namespace after completing fragment parse
    @Test(timeout = 4000)
    public void testCompleteParseFragmentMaintainsNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse("ME;}", "ME;}");
        builder.completeParseFragment();
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test XML declaration processing
    @Test(timeout = 4000)
    public void testProcessXmlDeclaration() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse(">: ", ">: ");
        Tokeniser tokeniser = new Tokeniser(builder);
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        streamParser.parseFragment("http://www.w3.org/2000/svg", doc, "http://www.w3.org/XML/1998/namespace");
        Token.XmlDecl xmlDecl = tokeniser.createXmlDeclPending(true);
        boolean result = builder.process(xmlDecl);
        assertTrue(result);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test XML declaration insertion
    @Test(timeout = 4000)
    public void testInsertXmlDeclaration() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("Doctype", "nfHa(P+.f");
        streamParser.parseFragment("$M{RJ]hM9&ek.Vtk$I", element, "http://www.w3.org/1999/xhtml");
        Tokeniser tokeniser = new Tokeniser(builder);
        Token.XmlDecl xmlDecl = tokeniser.createXmlDeclPending(true);
        builder.insertXmlDeclarationFor(xmlDecl);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test doctype processing
    @Test(timeout = 4000)
    public void testProcessDoctype() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("Doctype", "nfHa(P+.f");
        streamParser.parseFragment("$M{RJ]hM9&ek.Vtk$I", element, "http://www.w3.org/1999/xhtml");
        Token.Doctype doctype = new Token.Doctype();
        boolean result = builder.process(doctype);
        assertTrue(result);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test comment processing
    @Test(timeout = 4000)
    public void testProcessComment() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Document doc = builder.parse(">: ", ">: ");
        Tokeniser tokeniser = new Tokeniser(builder);
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        streamParser.parseFragment("http://www.w3.org/2000/svg", doc, "http://www.w3.org/XML/1998/namespace");
        Token.Comment comment = tokeniser.commentPending;
        boolean result = builder.process(comment);
        assertTrue(result);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test element popping after start tag
    @Test(timeout = 4000)
    public void testPopAfterProcessStartTag() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("http://www.w3.org/2000/svg", "http://www.w3.org/1999/xhtml");
        streamParser.parseFragment("7~n", element, "7~n");
        boolean result = builder.processStartTag("http://www.w3.org/2000/svg");
        assertTrue(result);
        
        Element popped = builder.pop();
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
        assertEquals("http://www.w3.org/2000/svg", popped.tagName());
    }

    // Test default tag set retrieval
    @Test(timeout = 4000)
    public void testDefaultTagSetNotNull() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        TagSet tagSet = builder.defaultTagSet();
        assertNotNull(tagSet);
    }

    // Test default parse settings
    @Test(timeout = 4000)
    public void testDefaultSettingsPreserveTagCase() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        ParseSettings settings = builder.defaultSettings();
        assertTrue(settings.preserveTagCase());
    }

    // Test stack closing without initialization
    @Test(timeout = 4000)
    public void testPopStackToCloseThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.EndTag endTag = new Token.EndTag(builder);
        
        try {
            builder.popStackToClose(endTag);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test element popping without initialization
    @Test(timeout = 4000)
    public void testPopThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse(",Ix<T(pi#>?mbGzH", ",Ix<T(pi#>?mbGzH");
        
        try {
            builder.pop();
            fail("Expected NullPointerException due to stack handling issue");
        } catch (NullPointerException e) {
            // Expected: TreeBuilder state issue
        }
    }

    // Test parsing with null base URI
    @Test(timeout = 4000)
    public void testParseThrowsIllegalArgumentExceptionForNullBaseUri() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.parse(",Ix<T(pi#>?mbGzH", null);
            fail("Expected IllegalArgumentException for null baseUri");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notNull violation
        }
    }

    // Test parsing with null input
    @Test(timeout = 4000)
    public void testParseThrowsNullPointerExceptionForNullInput() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.parse(null, null);
            fail("Expected NullPointerException for null input");
        } catch (NullPointerException e) {
            // Expected: StringReader requires non-null input
        }
    }

    // Test parsing with null base URI (Reader version)
    @Test(timeout = 4000)
    public void testParseReaderThrowsIllegalArgumentExceptionForNullBaseUri() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        PipedWriter writer = new PipedWriter();
        PipedReader reader = new PipedReader(writer);
        
        try {
            builder.parse(reader, null);
            fail("Expected IllegalArgumentException for null baseUri");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notNull violation
        }
    }

    // Test parsing with disconnected pipe
    @Test(timeout = 4000)
    public void testParseReaderThrowsUncheckedIOException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        PipedReader reader = new PipedReader();
        
        try {
            builder.parse(reader, "kxrewut");
            fail("Expected UncheckedIOException due to disconnected pipe");
        } catch (UncheckedIOException e) {
            // Expected: CharacterReader cannot read from disconnected pipe
        }
    }

    // Test null XML declaration insertion
    @Test(timeout = 4000)
    public void testInsertXmlDeclarationForNullThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.insertXmlDeclarationFor(null);
            fail("Expected NullPointerException for null token");
        } catch (NullPointerException e) {
            // Expected: Null token handling
        }
    }

    // Test null leaf node insertion
    @Test(timeout = 4000)
    public void testInsertLeafNodeNullThrowsIllegalArgumentException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        Document doc = parser.parseInput("class", "class");
        streamParser.parseFragment("{FDP|4G0#6", doc, "_',=~G~eEf3?aX_HU");
        
        try {
            builder.insertLeafNode(null);
            fail("Expected IllegalArgumentException for null node");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notNull violation
        }
    }

    // Test leaf node insertion without context
    @Test(timeout = 4000)
    public void testInsertLeafNodeThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        CDataNode node = new CDataNode("xl`t");
        
        try {
            builder.insertLeafNode(node);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test element insertion with empty tag name
    @Test(timeout = 4000)
    public void testInsertElementForEmptyTagNameThrowsIllegalArgumentException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse(",Ix<T(pi#>?mbGzH", "jsoup.xmlns-");
        Token.StartTag startTag = new Token.StartTag(builder);
        
        try {
            builder.insertElementFor(startTag);
            fail("Expected IllegalArgumentException for empty tag name");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notEmpty violation
        }
    }

    // Test null start tag insertion
    @Test(timeout = 4000)
    public void testInsertElementForNullThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.insertElementFor(null);
            fail("Expected NullPointerException for null token");
        } catch (NullPointerException e) {
            // Expected: Null token handling
        }
    }

    // Test doctype insertion without context
    @Test(timeout = 4000)
    public void testInsertDoctypeForThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.Doctype doctype = new Token.Doctype();
        
        try {
            builder.insertDoctypeFor(doctype);
            fail("Expected NullPointerException due to uninitialized document");
        } catch (NullPointerException e) {
            // Expected: Document not initialized
        }
    }

    // Test initialization with null reader
    @Test(timeout = 4000)
    public void testInitialiseParseThrowsIllegalArgumentExceptionForNullReader() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = Parser.xmlParser();
        
        try {
            builder.initialiseParse(null, "ScriptData", parser);
            fail("Expected IllegalArgumentException for null reader");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notNull violation
        }
    }

    // Test initialization with disconnected pipe
    @Test(timeout = 4000)
    public void testInitialiseParseThrowsUncheckedIOException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        PipedReader reader = new PipedReader();
        Parser parser = new Parser(builder);
        
        try {
            builder.initialiseParse(reader, "IuI=", parser);
            fail("Expected UncheckedIOException due to disconnected pipe");
        } catch (UncheckedIOException e) {
            // Expected: CharacterReader cannot read from disconnected pipe
        }
    }

    // Test complete fragment without initialization
    @Test(timeout = 4000)
    public void testCompleteParseFragmentThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.completeParseFragment();
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test token processing without initialization
    @Test(timeout = 4000)
    public void testProcessTokenThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.Comment comment = new Token.Comment();
        
        try {
            builder.process(comment);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test default namespace value
    @Test(timeout = 4000)
    public void testDefaultNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        String namespace = builder.defaultNamespace();
        assertEquals("http://www.w3.org/XML/1998/namespace", namespace);
    }

    // Test end tag processing
    @Test(timeout = 4000)
    public void testProcessEndTag() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("http://www.w3.org/1998/Math/MathML", "http://www.w3.org/XML/1998/namespace");
        streamParser.parseFragment("http://www.w3.org/XML/1998/namespace", element, "http://www.w3.org/1999/xhtml");
        Token.EndTag endTag = new Token.EndTag(builder);
        boolean result = builder.process(endTag);
        assertTrue(result);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test XML declaration with attributes
    @Test(timeout = 4000)
    public void testProcessXmlDeclWithAttributesThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.XmlDecl xmlDecl = new Token.XmlDecl(builder);
        xmlDecl.newAttribute();
        
        try {
            builder.process(xmlDecl);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test character insertion without context
    @Test(timeout = 4000)
    public void testInsertCharacterForThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.CData cdata = new Token.CData("");
        
        try {
            builder.insertCharacterFor(cdata);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test start tag with empty name
    @Test(timeout = 4000)
    public void testProcessStartTagWithEmptyNameThrowsIllegalArgumentException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse("xmlns:{2u;3rllkw{s)I", "xmlns:{2u;3rllkw{s)I");
        CDataNode node = new CDataNode("xmlns:{2u;3rllkw{s)I");
        Attributes attributes = node.attributes();
        attributes.add("xmlns:{2u;3rllkw{s)I", "6x J(VBX=|so_zGPsa");
        Tokeniser tokeniser = new Tokeniser(builder);
        Token.StartTag startTag = tokeniser.startPending;
        startTag.nameAttr(null, attributes);
        
        try {
            builder.process(startTag);
            fail("Expected IllegalArgumentException for empty tag name");
        } catch (IllegalArgumentException e) {
            // Expected: Validate.notEmpty violation
        }
    }

    // Test start tag processing with namespace attributes
    @Test(timeout = 4000)
    public void testProcessStartTagWithNamespaceAttributesThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse(",Ix<T(pi#>?mbGzH", ",Ix<T(pi#>?mbGzH");
        Token.StartTag startTag = new Token.StartTag(builder);
        CDataNode node = new CDataNode("1'm<`CcR11r1m =@q");
        Attributes attributes = node.attributes();
        attributes.add("xmlns", "1'm<`CcR11r1m =@q");
        Token.StartTag modifiedTag = startTag.nameAttr("X7,c,ddhqJ", attributes);
        
        try {
            builder.process(modifiedTag);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test start tag processing with namespace prefix
    @Test(timeout = 4000)
    public void testProcessStartTagWithNamespacePrefixThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.parse("http://www.w3.org/XML/1998/namespace", "http://www.w3.org/XML/1998/namespace");
        Tokeniser tokeniser = new Tokeniser(builder);
        Token.StartTag startTag = tokeniser.startPending;
        Attributes attributes = new Attributes();
        attributes.add("http://www.w3.org/XML/1998/namespace", "}5ov4zKP6");
        startTag.nameAttr("numeric referencD with no nu)erals", attributes);
        
        try {
            builder.process(startTag);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test element insertion
    @Test(timeout = 4000)
    public void testInsertElementFor() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Parser parser = new Parser(builder);
        StreamParser streamParser = new StreamParser(parser);
        
        Element element = new Element("http://www.w3.org/XML/1998/namespace", "http://www.w3.org/2000/svg");
        streamParser.parseFragment("http://www.w3.org/2000/svg", element, "http://www.w3.org/1998/Math/MathML");
        Tokeniser tokeniser = new Tokeniser(builder);
        Token.StartTag startTag = tokeniser.startPending;
        Attributes attributes = new Attributes();
        Token.StartTag modifiedTag = startTag.nameAttr("V#,{/v8G", attributes);
        builder.insertElementFor(modifiedTag);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test fragment initialization with null context
    @Test(timeout = 4000)
    public void testInitialiseParseFragmentWithNullContext() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        builder.initialiseParseFragment(null);
        assertEquals("http://www.w3.org/XML/1998/namespace", builder.defaultNamespace());
    }

    // Test parsing XML content
    @Test(timeout = 4000)
    public void testParseXmlContent() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        StringReader reader = new StringReader("xmlns");
        builder.parse(reader, "xmlns");
    }

    // Test comment insertion without context
    @Test(timeout = 4000)
    public void testInsertCommentForThrowsNullPointerException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        Token.Comment comment = new Token.Comment();
        
        try {
            builder.insertCommentFor(comment);
            fail("Expected NullPointerException due to uninitialized stack");
        } catch (NullPointerException e) {
            // Expected: Stack not initialized
        }
    }

    // Test new instance namespace
    @Test(timeout = 4000)
    public void testNewInstanceHasDefaultNamespace() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        XmlTreeBuilder newInstance = builder.newInstance();
        assertEquals("http://www.w3.org/XML/1998/namespace", newInstance.defaultNamespace());
    }

    // Test element popping from empty stack
    @Test(timeout = 4000)
    public void testPopThrowsNoSuchElementException() throws Throwable {
        XmlTreeBuilder builder = new XmlTreeBuilder();
        
        try {
            builder.pop();
            fail("Expected NoSuchElementException for empty stack");
        } catch (NoSuchElementException e) {
            // Expected: Stack is empty
        }
    }
}