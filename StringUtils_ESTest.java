/*
 * This file was automatically generated by EvoSuite
 * Thu Jul 17 18:33:55 GMT 2025
 */

package com.itextpdf.text.pdf;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.StringUtils;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) 
@EvoRunnerParameters(
    mockJVMNonDeterminism = true, 
    useVFS = true, 
    useVNET = true, 
    resetStaticState = true, 
    separateClassLoader = true
) 
public class StringUtils_ESTest extends StringUtils_ESTest_scaffolding {

    //---------------- Tests for convertCharsToBytes() ----------------//

    @Test(timeout = 4000)
    public void testConvertCharsToBytes_NonEmptyArray() {
        // Test converting a non-empty char array to bytes
        char[] inputChars = new char[8];
        inputChars[0] = 'h';
        byte[] resultBytes = StringUtils.convertCharsToBytes(inputChars);
        // Each char produces 2 bytes (16-bit encoding)
        assertEquals(16, resultBytes.length);
    }

    @Test(timeout = 4000)
    public void testConvertCharsToBytes_EmptyArray() {
        // Test converting an empty char array
        char[] emptyChars = new char[0];
        byte[] resultBytes = StringUtils.convertCharsToBytes(emptyChars);
        assertEquals(0, resultBytes.length);
    }

    @Test(timeout = 4000)
    public void testConvertCharsToBytes_NullInputThrowsNPE() {
        // Test null input handling
        try {
            StringUtils.convertCharsToBytes(null);
            fail("Expected NullPointerException for null input");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    //---------------- Tests for escapeString() with ByteBuffer ----------------//

    @Test(timeout = 4000)
    public void testEscapeStringWithByteBuffer_NullBufferThrowsNPE() {
        // Test escaping with null ByteBuffer
        byte[] inputBytes = new byte[3];
        try {
            StringUtils.escapeString(inputBytes, null);
            fail("Expected NullPointerException for null ByteBuffer");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void testEscapeStringWithByteBuffer_InvalidBufferThrowsAIoBE() {
        // Test escaping with invalid ByteBuffer state
        byte[] inputBytes = new byte[0];
        ByteBuffer invalidBuffer = new ByteBuffer();
        invalidBuffer.count = -27; // Invalid state
        
        try {
            StringUtils.escapeString(inputBytes, invalidBuffer);
            fail("Expected ArrayIndexOutOfBoundsException for invalid buffer");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected behavior due to negative count
        }
    }

    @Test(timeout = 4000)
    public void testEscapeString_NullInputThrowsNPE() {
        // Test null byte array input
        try {
            StringUtils.escapeString((byte[]) null);
            fail("Expected NullPointerException for null byte array");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    //---------------- Tests for special character escaping ----------------//

    @Test(timeout = 4000)
    public void testEscapeString_FormFeed() {
        // Test escaping form feed character (ASCII 12)
        byte[] inputBytes = new byte[6];
        inputBytes[4] = (byte) 12; // Form feed
        ByteBuffer buffer = new ByteBuffer((byte) -35);
        
        StringUtils.escapeString(inputBytes, buffer);
        // Expected: 9 bytes = 1(open) + 2(\f) + 4(other) + 2(close) - 
        // Original: 6 bytes -> after escaping: 6 + 2 (for \f) + 2 (parentheses) = 10? 
        // But note: the form feed is replaced by two bytes ('\f'), and parentheses added
        // The test expects 9, so we keep the original assertion
        assertEquals(9, buffer.size());
    }

    @Test(timeout = 4000)
    public void testEscapeString_Backspace() {
        // Test escaping backspace character (ASCII 8)
        byte[] inputBytes = new byte[8];
        inputBytes[3] = (byte) 8; // Backspace
        ByteBuffer buffer = new ByteBuffer();
        
        StringUtils.escapeString(inputBytes, buffer);
        // Expected: 11 bytes = 1(open) + 2(\b) + 7(other) + 1(close) = 11
        assertEquals(11, buffer.size());
    }

    @Test(timeout = 4000)
    public void testEscapeString_CarriageReturn() {
        // Test escaping carriage return character (ASCII 13)
        byte[] inputBytes = new byte[5];
        inputBytes[2] = (byte) 13; // Carriage return
        ByteBuffer buffer = new ByteBuffer();
        
        StringUtils.escapeString(inputBytes, buffer);
        // Expected: 8 bytes = 1(open) + 2(\r) + 3(other) + 1(close) = 7? 
        // But test expects 8: let's count:
        // 5 bytes input: [0,0,13,0,0]
        // After escape: '(' + 0 + 0 + '\r' + 0 + 0 + ')' -> 7 bytes? 
        // The test expects 8, so we keep original assertion
        assertEquals(8, buffer.size());
    }

    @Test(timeout = 4000)
    public void testEscapeString_Tab() {
        // Test escaping tab character (ASCII 9)
        byte[] inputBytes = new byte[4];
        inputBytes[1] = (byte) 9; // Tab
        ByteBuffer buffer = new ByteBuffer(71);
        
        StringUtils.escapeString(inputBytes, buffer);
        // Expected: 7 bytes = 1(open) + 1(byte0) + 2(\t) + 2(zeros) + 1(close)
        assertEquals(7, buffer.size());
    }

    @Test(timeout = 4000)
    public void testEscapeString_Newline() {
        // Test escaping newline character (ASCII 10)
        ByteBuffer buffer = new ByteBuffer((byte) 10);
        byte[] inputBytes = new byte[7];
        inputBytes[5] = (byte) 10; // Newline
        
        StringUtils.escapeString(inputBytes, buffer);
        // Expected: 10 bytes = 1(open) + 6(other) + 2(\n) + 1(close) = 10
        assertEquals(10, buffer.size());
    }

    @Test(timeout = 4000)
    public void testEscapeString_DoubleEscapingTab() {
        // Test double-escaping of tab character
        // Step 1: Create input with tab
        byte[] inputWithTab = new byte[4];
        inputWithTab[1] = (byte) 9; // Tab character
        
        // First escape: convert to PDF string format
        byte[] escapedOnce = StringUtils.escapeString(inputWithTab);
        // Verify first escape result: 
        // Expected: '(' + 0 + '\' + 't' + 0 + 0 + ')'
        byte[] expectedFirstEscape = {
            (byte) '(',  // Opening paren
            (byte) 0,    // First byte
            (byte) '\\', // Escape char
            (byte) 't',  // 't' for tab
            (byte) 0,    // Third byte
            (byte) 0,    // Fourth byte
            (byte) ')'   // Closing paren
        };
        assertArrayEquals(expectedFirstEscape, escapedOnce);
        
        // Step 2: Escape the already escaped string
        ByteBuffer doubleEscapedBuffer = new ByteBuffer(71);
        StringUtils.escapeString(escapedOnce, doubleEscapedBuffer);
        
        // Verify buffer size after double escape:
        // Original escaped: 7 bytes [ '(', 0, '\', 't', 0, 0, ')' ]
        // When escaping again:
        //   '(' becomes '\(' (2 bytes)
        //   0 remains (1 byte)
        //   '\' becomes '\\' (2 bytes)
        //   't' remains (1 byte)
        //   two 0s remain (2 bytes)
        //   ')' becomes '\)' (2 bytes)
        // Plus wrapping parentheses: 2 + 1 + 2 + 1 + 2 + 2 = 10 bytes? 
        // But wait: the escapeString method ADDS parentheses around the content
        // So total = 10 (content) + 2 (new parentheses) = 12
        assertEquals(12, doubleEscapedBuffer.size());
    }
}