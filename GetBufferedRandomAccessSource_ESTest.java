/*
 * This file was automatically generated by EvoSuite
 * Refactored for improved understandability
 */
package com.itextpdf.text.io;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.itextpdf.text.io.ArrayRandomAccessSource;
import com.itextpdf.text.io.ByteBufferRandomAccessSource;
import com.itextpdf.text.io.GetBufferedRandomAccessSource;
import com.itextpdf.text.io.MappedChannelRandomAccessSource;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.WindowRandomAccessSource;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(
    mockJVMNonDeterminism = true,
    useVFS = true,
    useVNET = true,
    resetStaticState = true,
    separateClassLoader = true
)
public class GetBufferedRandomAccessSource_ESTest extends GetBufferedRandomAccessSource_ESTest_scaffolding {

    // Constructor Tests
    @Test(timeout = 4000)
    public void constructorWithNullSourceThrowsNullPointerException() {
        try {
            new GetBufferedRandomAccessSource(null);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Verify exception comes from expected location
            verifyException("com.itextpdf.text.io.GetBufferedRandomAccessSource", e);
        }
    }

    // length() Tests
    @Test(timeout = 4000)
    public void lengthWithNullWindowSourceReturnsZero() throws IOException {
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(null, 0L, 0L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        assertEquals(0L, source.length());
    }

    @Test(timeout = 4000)
    public void lengthWithNegativeWindowReturnsNegativeValue() throws IOException {
        byte[] emptyData = new byte[0];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(emptyData);
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(arraySource, -782L, -782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        assertEquals(-782L, source.length());
    }

    @Test(timeout = 4000)
    public void lengthReturnsCorrectSourceLength() throws IOException {
        byte[] data = new byte[8];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        assertEquals(8L, source.length());
    }

    @Test(timeout = 4000)
    public void lengthAfterCloseThrowsException() throws IOException {
        byte[] data = new byte[1];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        source.close();
        
        try {
            source.length();
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            // Verify exception comes from underlying source
            verifyException("com.itextpdf.text.io.ArrayRandomAccessSource", e);
        }
    }

    // get(long position) Tests
    @Test(timeout = 4000)
    public void getAtNegativePositionWithWrappedSourceReturnsZero() throws IOException {
        byte[] emptyData = new byte[0];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(emptyData);
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(arraySource, -782L, -782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        assertEquals(0, source.get(-1L));
    }

    @Test(timeout = 4000)
    public void getAtPositionReturnsCorrectByteValue() throws IOException {
        byte[] data = new byte[]{(byte) -56}; // -56 unsigned is 200
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        assertEquals(200, source.get(0L));
    }

    @Test(timeout = 4000)
    public void getAtPositionBeyondLengthReturnsMinusOne() throws IOException {
        byte[] emptyData = new byte[0];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(emptyData);
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(arraySource, -782L, -782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        assertEquals(-1, source.get(3322L));
    }

    @Test(timeout = 4000)
    public void getAtSamePositionTwiceReturnsConsistentValue() throws IOException {
        byte[] data = new byte[15];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        source.get(0L); // Prime buffer
        assertEquals(0, source.get(0L)); // Read from buffer
    }

    @Test(timeout = 4000)
    public void getAfterCloseThrowsException() throws IOException {
        byte[] data = new byte[8];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        source.close();
        
        try {
            source.get(-155L);
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            // Verify exception comes from underlying source
            verifyException("com.itextpdf.text.io.ArrayRandomAccessSource", e);
        }
    }

    @Test(timeout = 4000)
    public void getAtNegativePositionAfterPreviousReadThrowsException() throws IOException {
        byte[] data = new byte[8];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        source.get(0L); // Prime buffer
        
        try {
            source.get(-1L);
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected behavior
        }
    }

    // get(long, byte[], int, int) Tests
    @Test(timeout = 4000)
    public void getArrayWithinSourceBoundsReadsFullAvailableData() throws IOException {
        byte[] data = new byte[16];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        byte[] buffer = new byte[16];
        int read = source.get(0L, buffer, 0, 610); // Request more than available
        assertEquals(16, read); // Should only read available data
    }

    @Test(timeout = 4000)
    public void getArrayWithZeroLengthReturnsZero() throws IOException {
        byte[] data = new byte[15];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        byte[] buffer = new byte[15];
        assertEquals(0, source.get(0L, buffer, 0, 0));
    }

    @Test(timeout = 4000)
    public void getArrayWithNegativeLengthReturnsMinusOne() throws IOException {
        byte[] emptyData = new byte[0];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(emptyData);
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(arraySource, -782L, -782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        byte[] buffer = new byte[0];
        assertEquals(-1, source.get(0L, buffer, 465, -1134));
    }

    @Test(timeout = 4000)
    public void getArrayAfterSourceCloseThrowsException() throws IOException {
        byte[] emptyData = new byte[0];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(emptyData);
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(arraySource, -782L, -782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        windowSource.close();
        
        try {
            byte[] buffer = new byte[0];
            source.get(-2836L, buffer, -1, -1);
            fail("Expected IllegalStateException");
        } catch (IllegalStateException e) {
            // Verify exception comes from underlying source
            verifyException("com.itextpdf.text.io.ArrayRandomAccessSource", e);
        }
    }

    @Test(timeout = 4000)
    public void getArrayWithNullBufferThrowsNullPointerException() throws IOException {
        byte[] data = new byte[4];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        
        try {
            source.get(-1780L, null, -213, -213);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Expected behavior
        }
    }

    @Test(timeout = 4000)
    public void getArrayWithNegativeOffsetThrowsException() throws IOException {
        byte[] data = new byte[1];
        ArrayRandomAccessSource arraySource = new ArrayRandomAccessSource(data);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(arraySource);
        
        try {
            byte[] buffer = new byte[1];
            source.get(0L, buffer, -328, 762);
            fail("Expected ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException e) {
            // Expected behavior
        }
    }

    // close() Tests
    @Test(timeout = 4000)
    public void closeWithNullSourceThrowsNullPointerException() {
        WindowRandomAccessSource windowSource = new WindowRandomAccessSource(null, 0L, 0L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(windowSource);
        
        try {
            source.close();
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // Verify exception comes from underlying source
            verifyException("com.itextpdf.text.io.WindowRandomAccessSource", e);
        }
    }

    // The following tests verify exception types from underlying implementations
    @Test(timeout = 4000)
    public void getArrayWithByteBufferSourceThrowsExpectedException() {
        byte[] data = new byte[1];
        ByteBuffer byteBuffer = ByteBuffer.wrap(data);
        ByteBufferRandomAccessSource bufferSource = new ByteBufferRandomAccessSource(byteBuffer);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(bufferSource);
        
        try {
            byte[] buffer = new byte[1];
            source.get(0L, buffer, -89, -89);
            fail("Expected NoSuchMethodError");
        } catch (NoSuchMethodError e) {
            // Verify exception comes from expected location
            verifyException("com.itextpdf.text.io.ByteBufferRandomAccessSource", e);
        }
    }

    @Test(timeout = 4000)
    public void getWithByteBufferSourceThrowsExpectedException() {
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1);
        ByteBufferRandomAccessSource bufferSource = new ByteBufferRandomAccessSource(byteBuffer);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(bufferSource);
        
        try {
            source.get(-1269L);
            fail("Expected NoSuchMethodError");
        } catch (NoSuchMethodError e) {
            // Verify exception comes from expected location
            verifyException("com.itextpdf.text.io.ByteBufferRandomAccessSource", e);
        }
    }

    @Test(timeout = 4000)
    public void getArrayWithMappedChannelThrowsIOException() {
        MappedChannelRandomAccessSource mappedSource = new MappedChannelRandomAccessSource(null, 2782L, 2782L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(mappedSource);
        
        try {
            byte[] buffer = new byte[1];
            source.get(2782L, buffer, -27, 0);
            fail("Expected IOException");
        } catch (IOException e) {
            // Verify exception message
            assertEquals("RandomAccessSource not opened", e.getMessage());
        }
    }

    @Test(timeout = 4000)
    public void getWithMappedChannelThrowsIOException() {
        MappedChannelRandomAccessSource mappedSource = new MappedChannelRandomAccessSource(null, 1760L, 1760L);
        GetBufferedRandomAccessSource source = new GetBufferedRandomAccessSource(mappedSource);
        
        try {
            source.get(1760L);
            fail("Expected IOException");
        } catch (IOException e) {
            // Verify exception message
            assertEquals("RandomAccessSource not opened", e.getMessage());
        }
    }
}