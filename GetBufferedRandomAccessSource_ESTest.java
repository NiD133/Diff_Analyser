package com.itextpdf.text.io;

import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.*;

/**
 * Understandable, focused tests for GetBufferedRandomAccessSource.
 *
 * These tests avoid environment-specific behavior and odd edge cases generated by EvoSuite.
 * They focus on:
 * - basic length delegation
 * - single-byte reads (unsigned)
 * - multi-byte reads (including zero-length reads)
 * - behavior when reading past EOF
 * - input validation (nulls / invalid ranges)
 */
public class GetBufferedRandomAccessSourceTest {

    private static GetBufferedRandomAccessSource wrap(byte[] data) {
        return new GetBufferedRandomAccessSource(new ArrayRandomAccessSource(data));
    }

    @Test(expected = NullPointerException.class)
    public void constructor_shouldRejectNullSource() {
        // The constructor calls source.length(), so a null source must throw NPE.
        new GetBufferedRandomAccessSource(null);
    }

    @Test
    public void length_shouldDelegateToSource() {
        byte[] data = new byte[8];
        GetBufferedRandomAccessSource ras = wrap(data);

        assertEquals(8L, ras.length());
    }

    @Test
    public void get_singleByte_shouldReturnUnsignedValue() throws IOException {
        byte[] data = new byte[] { (byte) 0xC8 }; // -56 signed, 200 unsigned
        GetBufferedRandomAccessSource ras = wrap(data);

        int b = ras.get(0L);

        assertEquals(200, b);
    }

    @Test
    public void get_singleByte_pastEOF_shouldReturnMinusOne() throws IOException {
        byte[] data = new byte[2];
        GetBufferedRandomAccessSource ras = wrap(data);

        assertEquals(-1, ras.get(2L));     // exactly at EOF
        assertEquals(-1, ras.get(10L));    // well beyond EOF
    }

    @Test
    public void get_bulk_shouldReadUpToLen() throws IOException {
        // Prepare predictable source bytes
        byte[] source = new byte[] { 10, 20, 30, 40, 50, 60 };
        GetBufferedRandomAccessSource ras = wrap(source);

        byte[] dest = new byte[10]; // larger than the requested length
        int read = ras.get(0L, dest, 0, 6);

        assertEquals(6, read);
        assertArrayEquals(new byte[] { 10, 20, 30, 40, 50, 60, 0, 0, 0, 0 }, dest);
    }

    @Test
    public void get_bulk_zeroLength_shouldReturnZeroAndNotModifyArray() throws IOException {
        byte[] source = new byte[] { 1, 2, 3 };
        GetBufferedRandomAccessSource ras = wrap(source);

        byte[] dest = new byte[] { 9, 9, 9 };
        int read = ras.get(1L, dest, 1, 0);

        assertEquals(0, read);
        assertArrayEquals(new byte[] { 9, 9, 9 }, dest);
    }

    @Test
    public void get_bulk_startWithinButExtendPastEOF_shouldReturnAvailableBytes() throws IOException {
        byte[] source = new byte[] { 1, 2, 3, 4 };
        GetBufferedRandomAccessSource ras = wrap(source);

        byte[] dest = new byte[5];
        int read = ras.get(2L, dest, 0, 5); // only 2 bytes available (positions 2 and 3)

        assertEquals(2, read);
        assertArrayEquals(new byte[] { 3, 4, 0, 0, 0 }, dest);
    }

    @Test(expected = NullPointerException.class)
    public void get_bulk_nullDestination_shouldThrowNPE() throws IOException {
        byte[] source = new byte[] { 1, 2, 3 };
        GetBufferedRandomAccessSource ras = wrap(source);

        ras.get(0L, null, 0, 1);
    }

    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void get_bulk_negativeOffset_shouldThrowAIOOBE() throws IOException {
        byte[] source = new byte[] { 1, 2, 3 };
        GetBufferedRandomAccessSource ras = wrap(source);

        byte[] dest = new byte[3];
        ras.get(0L, dest, -1, 1);
    }

    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void get_bulk_lengthPastArrayEnd_shouldThrowAIOOBE() throws IOException {
        byte[] source = new byte[] { 1, 2, 3 };
        GetBufferedRandomAccessSource ras = wrap(source);

        byte[] dest = new byte[3];
        // off + len exceeds dest length
        ras.get(0L, dest, 2, 2);
    }

    @Test
    public void get_singleByte_multipleCalls_shouldBeConsistent() throws IOException {
        byte[] source = new byte[] { 0, 1, 2, 3, 4 };
        GetBufferedRandomAccessSource ras = wrap(source);

        assertEquals(0, ras.get(0L));
        assertEquals(1, ras.get(1L));
        assertEquals(2, ras.get(2L));
        assertEquals(3, ras.get(3L));
        assertEquals(4, ras.get(4L));
        assertEquals(-1, ras.get(5L)); // EOF
    }
}