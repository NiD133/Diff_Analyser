package com.google.common.hash;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import junit.framework.TestCase;

/**
 * Tests for {@link AbstractStreamingHasher}.
 */
public class AbstractStreamingHasherTest extends TestCase {

  /**
   * A test spy for {@link AbstractStreamingHasher} that captures the bytes passed to the
   * {@code process} methods and records invocations. This allows tests to verify the abstract
   * class's behavior from the perspective of a concrete implementation.
   */
  private static class SpyStreamingHasher extends AbstractStreamingHasher {

    private final int chunkSize;
    private final int bufferSize;
    private final ByteArrayOutputStream processedBytes = new ByteArrayOutputStream();
    private int processCallCount = 0;
    private boolean processRemainingCalled = false;

    SpyStreamingHasher(int chunkSize) {
      super(chunkSize);
      this.chunkSize = chunkSize;
      this.bufferSize = chunkSize;
    }

    SpyStreamingHasher(int chunkSize, int bufferSize) {
      super(chunkSize, bufferSize);
      this.chunkSize = chunkSize;
      this.bufferSize = bufferSize;
    }

    @Override
    protected HashCode makeHash() {
      // The actual hash value is not important for these tests, only the bytes processed.
      return HashCode.fromBytes(processedBytes.toByteArray());
    }

    @Override
    protected void process(ByteBuffer bb) {
      processCallCount++;
      assertEquals("Buffer must be in little-endian order", ByteOrder.LITTLE_ENDIAN, bb.order());
      assertTrue(
          "Buffer must have at least one full chunk", bb.remaining() >= chunkSize);
      for (int i = 0; i < chunkSize; i++) {
        processedBytes.write(bb.get());
      }
    }

    @Override
    protected void processRemaining(ByteBuffer bb) {
      assertFalse("processRemaining should only be called once", processRemainingCalled);
      processRemainingCalled = true;
      assertEquals("Buffer must be in little-endian order", ByteOrder.LITTLE_ENDIAN, bb.order());
      assertTrue("Remaining buffer must not be empty", bb.remaining() > 0);
      assertTrue(
          "Remaining buffer must be smaller than the buffer size", bb.remaining() < bufferSize);

      // The default AbstractStreamingHasher#processRemaining implementation pads the buffer
      // with zeros and delegates to process(). We want to verify this behavior.
      int callsBefore = processCallCount;
      super.processRemaining(bb); // This will call this.process() one more time.
      int callsAfter = processCallCount;
      assertEquals(
          "super.processRemaining() should delegate to process() exactly once",
          callsBefore + 1,
          callsAfter);

      // For our accounting, we only want to count chunks from the original input, not the
      // final padded chunk generated by processRemaining. We undo the increment here.
      processCallCount--;
    }

    // --- Accessors for test assertions ---

    byte[] getProcessedBytes() {
      return processedBytes.toByteArray();
    }

    int getProcessCallCount() {
      return processCallCount;
    }

    boolean wasProcessRemainingCalled() {
      return processRemainingCalled;
    }
  }

  public void testPutInt_withInputMatchingChunkSize_processesOneChunk() {
    // Arrange
    // A streaming hasher with a chunk size of 4 bytes (the size of an integer).
    SpyStreamingHasher hasher = new SpyStreamingHasher(4);
    // An integer where the byte representation is easy to identify (0x01, 0x02, 0x03, 0x04)
    // in little-endian order, which is the default for AbstractStreamingHasher.
    int input = 0x04030201;
    byte[] expectedBytes = {1, 2, 3, 4};

    // Act
    hasher.putInt(input);
    hasher.hash(); // Finalize the hash, processing any buffered data.

    // Assert
    // The 4 bytes from the integer should have been processed as a single, full chunk.
    assertEquals("Number of full chunks processed", 1, hasher.getProcessCallCount());
    assertFalse(
        "processRemaining should not be called when input is a multiple of chunk size",
        hasher.wasProcessRemainingCalled());

    // The hasher should have processed the little-endian bytes of the integer.
    assertArrayEquals(
        "Processed bytes should match the little-endian representation of the input",
        expectedBytes,
        hasher.getProcessedBytes());
  }
}